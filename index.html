<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KPI Viewer and Report</title>

    <!-- XLSX & Chart.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- MSAL cho ƒëƒÉng nh·∫≠p OneDrive (Microsoft Graph) -->
    <script src="https://alcdn.msauth.net/browser/2.38.0/js/msal-browser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
                Ubuntu, Cantarell, sans-serif;
            background: #f3f4f6; /* x√°m tr·∫Øng nh·∫π */
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: #111827;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #3749a5; /* xanh ƒë·∫≠m hi·ªán ƒë·∫°i */
            text-shadow: 0 2px 4px rgba(55, 73, 165, 0.15);
        }
        /* Disable hai n√∫t ch·ªçn file / th∆∞ m·ª•c Excel */
        .upload-sub-btn.disabled-upload {
            opacity: 0.4;
            pointer-events: none;
            box-shadow: none;
            transform: none;
        }
        .upload-section {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.25);
            margin-bottom: 24px;
            text-align: center;
        }

        .upload-area {
            border: 2px dashed #667eea;
            border-radius: 12px;
            padding: 24px 16px;
            background: #f8f9ff;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f2ff;
            transform: scale(1.02);
        }

        .upload-area.dragover {
            border-color: #4caf50;
            background: #e8f5e9;
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 12px;
        }

        .upload-area h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.5em;
        }

        .file-input {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 32px;
            border-radius: 30px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .file-info {
            margin-top: 16px;
            padding: 12px 16px;
            background: #e8f5e9;
            border-radius: 10px;
            display: none;
            text-align: left;
            font-size: 0.9em;
        }

        .file-info.show {
            display: block;
        }

        .charts-section {
            display: none;
        }

        .charts-section.show {
            display: block;
        }

        .chart-controls {
            background: white;
            border-radius: 15px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.18);
        }

        .chart-controls h3 {
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-grid {
            display: flex;
            gap: 16px;
            flex-wrap: nowrap;          /* 3 combobox lu√¥n c√πng 1 h√†ng tr√™n desktop */
            align-items: flex-end;      /* canh ƒë√°y cho ƒë·∫πp */
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1;                    /* m·ªói combobox chi·∫øm ƒë·ªÅu chi·ªÅu ngang */
        }

        .control-group label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        .control-group select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 0.95em;
            cursor: pointer;
            background: white;
            transition: border-color 0.3s;
        }

        .control-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .chart-card {
            background: white;
            border-radius: 20px;
            padding: 24px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.18);
        }

        .chart-card h3 {
            color: #333;
            margin-bottom: 16px;
            font-size: 1.2em;
            text-align: center;
        }

        .chart-wrapper {
            position: relative;
            height: 380px;
        }

        #chartsContainer {
            display: grid;
            gap: 20px;
            --charts-per-row: 2;
            grid-template-columns: repeat(var(--charts-per-row), minmax(0, 1fr));
            margin-bottom: 24px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 10px;
            color: #667eea;
            font-size: 1em;
        }

        .loading.show {
            display: block;
        }

        .data-table {
            background: white;
            border-radius: 20px;
            padding: 24px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.18);
            margin-top: 24px;
            margin-bottom: 24px;
            overflow-x: auto;
        }

        .data-table h3 {
            color: #111827;
            margin-bottom: 10px;
            font-size: 1.15em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        th,
        td {
            padding: 6px 8px;
            border-bottom: 1px solid #e5e7eb;
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        /* === STYLE B·∫¢NG TI·∫æN ƒê·ªò ƒêO KI·ªÇM === */
        .progress-table {
            font-size: 14px;
            border-collapse: collapse;
            margin: 8px 0;
            width: auto;                /* kh√¥ng b·∫Øt bu·ªôc 100% */
            table-layout: fixed;        /* ƒë·ªÉ t√≠nh left sticky ·ªïn ƒë·ªãnh */
        }

        /* header xanh gi·ªëng Worst Cell */
        .progress-table th {
            background: #1e3a8a;
            color: #fff;
            font-weight: 600;
            padding: 8px 10px;
            text-align: center;
            white-space: nowrap;
            border: 1px solid #d1d5db;
        }

        .progress-table td {
            padding: 6px 10px;
            text-align: center;
            white-space: nowrap;
            border: 1px solid #e5e7eb;
        }

        .progress-table tr:hover {
            background: #f3f4ff;
        }

        /* chi·ªÅu r·ªông 4 c·ªôt ƒë·∫ßu ‚Äì c√≥ th·ªÉ ch·ªânh th√™m n·∫øu mu·ªën */
        .progress-table th:nth-child(1),
        .progress-table td:nth-child(1) { min-width: 40px; }  /* STT  */
        .progress-table th:nth-child(2),
        .progress-table td:nth-child(2) { min-width: 60px; }  /* PO   */
        .progress-table th:nth-child(3),
        .progress-table td:nth-child(3) { min-width: 80px; }  /* T·ªânh */
        .progress-table th:nth-child(4),
        .progress-table td:nth-child(4) { min-width: 80px; }  /* S·ªë tr·∫°m */

        /* Sticky 4 c·ªôt ƒë·∫ßu: ch·ªâ d√πng class .sticky-col do JS g·∫Øn */
        .progress-table .sticky-col {
            z-index: 3;
        }

        /* Header sticky ƒë√® l√™n body m·ªôt ch√∫t ƒë·ªÉ kh√¥ng b·ªã g√£y */
        .progress-table thead .sticky-col {
            z-index: 4;
        }


        /* H√†ng t·ªïng h·ª£p d∆∞·ªõi c√πng */
        .progress-summary-row td {
            background: #fff9c4 !important;
            font-weight: 600 !important;
        }


        /* ==== WORST CELL WRAPPER ==== */
        #worstCellWrapper {
            max-height: 700px;      /* gi·ªõi h·∫°n chi·ªÅu cao */
            overflow-y: auto;       /* scroll d·ªçc */
            overflow-x: auto;
            position: relative;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            margin-top: 4px;
        }

        /* ==== STICKY HEADER WORST CELL ==== */
        #worstCellWrapper table thead th {
            position: sticky;
            top: 0;
            z-index: 5;                 /* cao h∆°n body */
            background: #1e3a8a;        /* ƒë√∫ng m√†u header Worst Cell */
            color: #fff;
        }



        /* === STYLE B·∫¢NG KPI TH·ªúI ƒêI·ªÇM G·∫¶N NH·∫§T === */
        #latestTableWrapper {
            max-height: 700px;              /* n·∫øu b·∫£ng cao h∆°n s·∫Ω c√≥ scroll d·ªçc */
            overflow-y: auto;
            overflow-x: auto;
            position: relative;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            margin-top: 4px;
        }




        #latestTableWrapper table {
            width: auto;                    /* auto width theo n·ªôi dung */
            table-layout: auto;
            border-collapse: collapse;
        }



        /* C·ªë ƒë·ªãnh c·ªôt 1 */
        #latestTableWrapper table th:first-child,
        #latestTableWrapper table td:first-child {
            position: sticky;
            left: 0;
            z-index: 3;
            background: #f9fafb;
            white-space: nowrap;
        }

        /* Header n·∫±m tr√™n c√πng khi scroll */
        #latestTableWrapper table thead th {
            top: 0;
            z-index: 4;
        }
        #latestTableWrapper table thead th:first-child {
            z-index: 5;
        }

        #kpiThresholdPanel select,
        #kpiThresholdPanel input[type="number"] {
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            border-radius: 8px;   /* BO TR√íN */
            font-size: 0.9em;
            background: #fff;
        }

        .wc-filter-input {
            padding: 4px 8px !important;
            height: 30px !important;
            min-width: 90px !important;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 6px;
        }

        tr:hover {
            background: #f3f4ff;
        }

        /* WS_NAME filter */
        #wsFilterContainer {
            background: #f8fafc;
            border-radius: 10px;
            padding: 8px;
            border: 1px dashed #cbd5f5;
            max-height: 400px;
            overflow-y: auto;
        }

        /* N√∫t n·ªïi g·ªçi popup WS/SITE/CELL_NAME */
        .ws-floating-btn {
            position: fixed;
            right: 18px;
            bottom: 18px;
            padding: 8px 14px;
            border-radius: 999px;
            background: #111827;
            color: #f9fafb;
            font-size: 12px;
            box-shadow: 0 4px 12px rgba(15, 23, 42, 0.35);
            cursor: pointer;
            z-index: 1200;
            display: none;         /* ch·ªâ hi·ªán khi scroll xu·ªëng */
            align-items: center;
            gap: 6px;
            opacity: 0.9;
            transition: opacity 0.15s ease, transform 0.15s ease;
        }

        .ws-floating-btn:hover {
            opacity: 1;
            transform: translateY(-1px);
        }

        /* Overlay t·ªëi to√†n m√†n h√¨nh */
        .ws-popup-overlay{
        position: fixed;
        inset: 0;
        background: transparent;     /* ‚ùå b·ªè n·ªÅn t·ªëi */
        display: none;
        z-index: 1300;
        }

        /* Khi m·ªü popup */
        .ws-popup-overlay.show{
        display: block; /* ‚úÖ kh√¥ng d√πng flex ƒë·ªÉ kh·ªèi can thi·ªáp v·ªã tr√≠ */
        }

        /* H·ªôp popup ch√≠nh */
        .ws-popup{
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);

        width: min(600px, 92vw);
        max-height: 80vh;
        background: #fff;
        border-radius: 14px;
        box-shadow: 0 20px 40px rgba(15, 23, 42, 0.4);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        }

        /* Header popup */
        .ws-popup-header{
        padding: 10px 14px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid #e5e7eb;
        font-weight: 600;
        font-size: 14px;

        cursor: move;
        user-select: none;
        }

        .ws-popup-close{
        border: none;
        background: transparent;
        font-size: 20px;
        line-height: 1;
        cursor: pointer;
        padding: 0 4px;
        color: #6b7280;
        }
        .ws-popup-close:hover{ color:#111827; }

        /* Body */
        .ws-popup-body{
        padding: 10px 12px;
        overflow: auto;
        max-height: calc(80vh - 44px);
        }
        .ws-popup-body #wsFilterContainer{ max-height: 60vh; }


        #kpiFilterContainer {
            background: #f8fafc;
            border-radius: 10px;
            padding: 8px;
            border: 1px dashed #e5e7eb;
            max-height: 260px;
            overflow-y: auto;
        }

        .kpi-filter-list {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 6px 10px;
        }

        .ws-filter-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 8px;
        }

        .ws-filter-search {
            flex: 1 1 160px;
            min-width: 0;
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid #d1d5db;
            font-size: 0.85em;
        }

        .ws-filter-toolbar button {
            border: none;
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 0.8em;
            cursor: pointer;
            background: #e0e7ff;
            color: #374151;
            white-space: nowrap;
        }

        .ws-filter-toolbar button:hover {
            background: #c7d2fe;
        }

        .ws-filter-list {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 6px 10px;
        }

        .ws-chip {
            background: #eef2ff;
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 0.8em;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;
        }

        .ws-chip input {
            accent-color: #667eea;
        }

        /* KPI Overview header row */
        .excel-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .excel-date-filter {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .excel-date-filter label {
            font-size: 0.9em;
            color: #555;
        }

        .excel-date-filter input[type="date"] {
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            font-size: 0.85em;
        }

        #excelTable table {
            width: auto;
            border-collapse: collapse;
            font-size: 0.9em;
            table-layout: auto;
        }

        #excelTable {
            position: relative;
        }

        #excelTable table th,
        #excelTable table td {
            position: relative;
        }

        #excelTable .sticky-col {
            z-index: 3;
        }

        #excelTable thead .sticky-col {
            z-index: 4;
        }

        #excelTable table th:nth-child(1),
        #excelTable table td:nth-child(1),
        #excelTable table th:nth-child(2),
        #excelTable table td:nth-child(2),
        #excelTable table th:nth-child(3),
        #excelTable table td:nth-child(3),
        #excelTable table th:nth-child(4),
        #excelTable table td:nth-child(4) {
            white-space: nowrap;
        }

        /* C·ªë ƒë·ªãnh & auto-fit 4 c·ªôt ƒë·∫ßu cho Worst Cell + Cell Non-Traffic */
        #worstCellTable,
        #nonTrafficTable {
            position: relative;
        }

        #worstCellTable table th,
        #worstCellTable table td,
        #nonTrafficTable table th,
        #nonTrafficTable table td {
            position: relative;
        }

        /* 4 c·ªôt ƒë·∫ßu kh√¥ng xu·ªëng d√≤ng ‚Üí auto-fit theo n·ªôi dung */
        #worstCellTable table th:nth-child(-n+4),
        #worstCellTable table td:nth-child(-n+4),
        #nonTrafficTable table th:nth-child(-n+4),
        #nonTrafficTable table td:nth-child(-n+4) {
            white-space: nowrap;
        }
        /* Header Worst Cell & Cell Non-Traffic d√≠nh tr√™n khi scroll d·ªçc */
        #worstCellTable table thead th,
        #nonTrafficTable table thead th {
            position: sticky;
            top: 0;
            z-index: 5;              /* cao h∆°n sticky-col */
            background: #203864;     /* tr√πng m√†u header hi·ªán t·∫°i */
        }


        #worstCellTable .sticky-col,
        #nonTrafficTable .sticky-col {
            z-index: 3;
        }

        #worstCellTable thead .sticky-col,
        #nonTrafficTable thead .sticky-col {
            z-index: 4;
        }





        .excel-latest-btn {
            border: none;
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 0.8em;
            cursor: pointer;
            background: #e0e7ff;
            color: #374151;
            white-space: nowrap;
        }

        .excel-latest-btn:hover {
            background: #c7d2fe;
        }

        /* Email form */
        .email-section {
            margin-top: 24px;
        }

        .email-form-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 12px;
            text-align: left;
        }

        .email-form-group label {
            font-weight: 600;
            color: #555;
            margin-bottom: 4px;
            font-size: 0.9em;
        }

        .email-form-group input,
        .email-form-group textarea {
            padding: 8px 10px;
            border-radius: 8px;
            border: 2px solid #ddd;
            font-size: 0.9em;
            transition: border-color 0.3s;
            font-family: inherit;
        }

        .email-form-group textarea {
            min-height: 120px;
            resize: vertical;
        }

        .email-form-group input:focus,
        .email-form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .email-status {
            margin-top: 8px;
            font-size: 0.85em;
            min-height: 18px;
        }

        .email-status.success {
            color: #43a047;
        }

        .email-status.error {
            color: #e53935;
        }

        .email-section-options {
            display: flex;
            flex-wrap: wrap;
            gap: 6px 10px;
            font-size: 0.85em;
        }

        .email-section-options label {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 999px;
            background: #eef2ff;
            cursor: pointer;
            user-select: none;
        }

        .email-section-options input[type="checkbox"] {
            accent-color: #667eea;
        }

        .email-actions-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            margin-top: 8px;
        }

        @media (max-width: 768px) {
            .control-grid {
                flex-direction: column;
                flex-wrap: nowrap;
            }
            #chartsContainer {
                --charts-per-row: 1;
            }
        }
        .upload-sub-actions {
            margin-top: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 14px;
        }

        .upload-sub-btn {
            background: rgba(102, 126, 234, 0.12);
            padding: 8px 16px;
            border-radius: 999px;
            cursor: pointer;
            color: #4f46e5;
            font-weight: 600;
            font-size: 0.9em;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: all 0.25s ease;
        }

        .upload-sub-btn:hover {
            background: rgba(102, 126, 234, 0.22);
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(102, 126, 234, 0.25);
        }

        .upload-sub-separator {
            color: #9ca3af;
            font-size: 0.85em;
        }

        .hide-col {
            display: none !important;
        }
                
    </style>
</head>
<body>
    <!-- Logo gi·ªØ ki·ªÉu c≈©: kh√¥ng √©p CSS, ch·ªâ l√† 1 ·∫£nh -->
    <img src="Logo.png" class="corner-logo" alt="Logo" />

    <div class="container">
        <div class="header">
            <h1>üìä KPI Viewer and Report</h1>
            <div style="font-size: 0.95em; color:#6b7280; margin-top:-6px;">
                Version: v1.7.6.2
            </div>
        </div>

        <!-- Upload -->
<!-- Upload -->
<div class="upload-section">
    <div class="upload-area" id="uploadArea">
        <div class="upload-icon">üìÅ</div>
        <h3>T·∫£i file Excel KPI</h3>

<div class="upload-sub-actions">
    <!-- 1. Ch·ªçn file Excel tr√™n m√°y -->
    <label class="upload-sub-btn">
        üìÑ Ch·ªçn file Excel
        <input
            type="file"
            id="fileInputFiles"
            class="file-input"
            accept=".xlsx,.xls"
            multiple
            onchange="handleFileFromFiles(event)"
        />
    </label>

    <span class="upload-sub-separator">ho·∫∑c</span>

    <!-- 2. Ch·ªçn th∆∞ m·ª•c Excel tr√™n m√°y -->
    <label class="upload-sub-btn">
        üìÇ Ch·ªçn th∆∞ m·ª•c Excel
        <input
            type="file"
            id="fileInputFolder"
            class="file-input"
            webkitdirectory
            directory
            onchange="handleFileFromFolder(event)"
        />
    </label>

    <span class="upload-sub-separator">ho·∫∑c</span>

    <!-- 3. ƒêƒÉng nh·∫≠p OneDrive -->
    <button
        type="button"
        class="upload-sub-btn"
        id="odLoginBtn"
    >
        üîë ƒêƒÉng nh·∫≠p OneDrive
    </button>
</div>

<!-- Textbox nh·∫≠p ƒë∆∞·ªùng d·∫´n th∆∞ m·ª•c KPI tr√™n OneDrive -->
<div style="margin-top:10px;">
    <label>
        üóÇÔ∏è ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c KPI:
        <input 
            type="text" 
            id="kpiFolderInput"
            placeholder="/KPI Scheduler"
            style="width:300px; padding:6px 10px; border-radius:8px; border:1px solid #ccc;"
        />
    </label>

    <!-- D√πng id ƒë·ªÉ JS b·∫Øt s·ª± ki·ªán, KH√îNG d√πng onclick inline n·ªØa -->
    <button 
        type="button"
        id="kpiFolderUpdateBtn"
        style="margin-left:8px; padding:6px 12px; border-radius:8px; background:#4f46e5; color:white; border:none; cursor:pointer;"
    >
        C·∫≠p nh·∫≠t
    </button>
</div>



    </div>
    <!-- ‚úÖ Thanh tr·∫°ng th√°i + combobox nh√≥m file OneDrive -->
<div
    id="odGroupBar"
    style="
        margin-top:8px;
        display:none;   /* CH·ªà hi·ªán sau khi login */
        gap:8px;
        align-items:center;
        flex-wrap:wrap;
        font-size:0.9em;
    "
>

    <!-- ‚≠ê Tr·∫°ng th√°i ƒëƒÉng nh·∫≠p ‚Äî n·∫±m 1 h√†ng ri√™ng -->
    <span
        id="odStatus"
        style="
            color:#4b5563;
            width:100%;
            display:block;
            margin-bottom:4px;
        "
    >
        Ch∆∞a ƒëƒÉng nh·∫≠p
    </span>
    <!-- Th∆∞ m·ª•c OneDrive -->
    <label>
        Th∆∞ m·ª•c:
        <select
            id="odFolderSelect"
            style="margin-left:4px; padding:4px 8px; min-width:180px;"
        ></select>
    </label>

    <!-- Nh√≥m file OneDrive -->
    <label>
        Nh√≥m file:
        <select
            id="odGroupSelect"
            style="margin-left:4px; padding:4px 8px; min-width:220px;"
        ></select>
    </label>

    <!-- N√∫t ƒë·ªçc nh√≥m -->
    <button
        type="button"
        id="odLoadGroupBtn"
        style="
            padding:4px 10px;
            border-radius:6px;
            border:1px solid #2563eb;
            background:#2563eb;
            color:#fff;
            font-size:0.9em;
            cursor:pointer;
        "
    >
        üì• ƒê·ªçc nh√≥m t·ª´ OneDrive
    </button>
</div>
    <div class="file-info" id="fileInfo"></div>

    <!-- ‚úÖ Combobox ch·ªçn folder + nh√≥m file trong folder -->
    <div
        id="folderFileSelectors"
        style="
            margin-top:8px;
            display:none;
            gap:8px;
            align-items:center;
            flex-wrap:wrap;
        "
    >
        <label style="font-size:0.9em;">
            Th∆∞ m·ª•c:
            <select id="folderSelect" style="margin-left:4px; padding:4px 8px;"></select>
        </label>

        <label style="font-size:0.9em;">
            Nh√≥m file:
            <select
                id="fileGroupSelect"
                style="margin-left:4px; padding:4px 8px; min-width:220px;"
            ></select>
        </label>

        <button
            type="button"
            id="loadGroupBtn"
            style="
                padding:4px 10px;
                border-radius:6px;
                border:1px solid #2563eb;
                background:#2563eb;
                color:#fff;
                font-size:0.9em;
                cursor:pointer;
            "
        >
            Ch·ªçn nh√≥m file
        </button>
    </div>

    <div class="loading" id="loading">‚è≥ ƒêang x·ª≠ l√Ω file...</div>
</div>


<!-- TI·∫æN ƒê·ªò ƒêO KI·ªÇM (IMPORT FILE EXCEL) gi·ªØ nguy√™n ph√≠a d∆∞·ªõi -->

        <!-- TI·∫æN ƒê·ªò ƒêO KI·ªÇM (IMPORT FILE EXCEL) -->
        <div class="data-table" id="progressCard" style="margin-top: 16px;">
            <h3>Ti·∫øn ƒê·ªô ƒêo Ki·ªÉm</h3>
            <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:8px;">
                <label style="
                    display:inline-flex;
                    align-items:center;
                    padding:6px 10px;
                    border-radius:6px;
                    background:#f0f4ff;
                    border:1px solid #b0c4ff;
                    font-size:0.9em;
                    cursor:pointer;
                ">
                    üìÇ Ch·ªçn file Excel ti·∫øn ƒë·ªô
                    <input type="file" id="progressFileInput" accept=".xlsx,.xls" style="display:none;">
                </label>
                <span id="progressStatus" style="font-size:0.85em;color:#666;">
                    Ch·ªçn file Excel ti·∫øn ƒë·ªô ƒëo ki·ªÉm (t·∫£i t·ª´ Google Sheet v·ªÅ m√°y, sheet "CQT-SSV").
                </span>
                <select id="progressPOFilter" style="padding:6px 10px; border-radius:6px; border:1px solid #b0b0b0; display:none;">
                    <option value="ALL">T·∫•t c·∫£ PO</option>
                </select>
            </div>

            <!-- B·ªô l·ªçc b·∫≠t/t·∫Øt c·ªôt -->
            <div class="email-section-options" style="margin:8px 0;">
                <label>
                    <input type="checkbox" id="toggleCQT" checked>
                    CQT
                </label>

                <label>
                    <input type="checkbox" id="toggleSSV" checked>
                    SSV
                </label>

                <label>
                    <input type="checkbox" id="toggleATP" checked>
                    ATP report
                </label>
            </div>


            <div id="progressTable"></div>

        </div>

        <!-- WORST CELL OVERVIEW -->
        <div class="data-table" id="worstOverviewCard" style="margin-top: 10px; display:none;">
            <h3>Worst Cell Overview</h3>
            <div style="margin-bottom:8px;">
                <select id="worstOverviewPoFilter" style="padding:6px 10px; border-radius:6px; border:1px solid #b0b0b0;">
                    <option value="ALL">T·∫•t c·∫£ PO</option>
                </select>
            </div>
            <div id="worstOverviewTable"></div>
        </div>


        <div class="charts-section" id="chartsSection">
            <!-- 1. T√ôY CH·ªàNH BI·ªÇU ƒê·ªí -->
            <div class="chart-controls">
                <h3>‚öôÔ∏è T√πy ch·ªânh bi·ªÉu ƒë·ªì</h3>
                <div class="control-grid">
                    <div class="control-group">
                        <label>üìÑ Sheet:</label>
                        <select id="sheetSelect" onchange="updateCharts()"></select>
                    </div>

                    <div class="control-group">
                        <label>üß© S·ªë chart tr√™n 1 h√†ng:</label>
                        <select id="chartsPerRowSelect">
                            <option value="1">1 chart / h√†ng</option>
                            <option value="2" selected>2 chart / h√†ng</option>
                            <option value="3">3 chart / h√†ng</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label>‚è± Kho·∫£ng ng√†y g·∫ßn nh·∫•t:</label>
                        <select id="daysWindowSelect">
                            <option value="7">7 ng√†y</option>
                            <option value="14" selected>14 ng√†y</option>
                            <option value="30">30 ng√†y</option>
                            <option value="40">40 ng√†y</option>
                            <option value="ALL">To√†n b·ªô</option>
                        </select>
                    </div>
                </div>

                <div class="control-group" style="margin-top: 14px">
                    <!-- ƒê√É ƒê·ªîI WS_NAME -> CELL_NAME -->
                    <label>üßµ Ch·ªçn WS/SITE/CELL_NAME hi·ªÉn th·ªã:</label>
                    <div id="wsFilterContainer"></div>
                </div>

                <!-- Ch·ªçn KPI hi·ªÉn th·ªã -->
                <div class="control-group" style="margin-top:12px;">
                    <label>üìå Ch·ªçn KPI hi·ªÉn th·ªã:</label>
                    <div id="kpiFilterContainer"></div>
                </div>


                <div class="control-group" style="margin-top:12px; max-width:240px;">
                    <label>üîÄ Th·ª© t·ª± s·∫Øp x·∫øp Funnel:</label>
                    <select id="funnelSortSelect">
                        <option value="desc" selected>L·ªõn ‚Üí nh·ªè</option>
                        <option value="asc">Nh·ªè ‚Üí l·ªõn</option>
                    </select>
                </div>

                <p style="margin-top: 10px; font-size: 0.85em; color: #666">
                    üî¢ H·ªá th·ªëng t·ª± ƒë·ªông nh·∫≠n di·ªán c·ªôt <strong>Period Time</strong> &
                    <strong>WS_NAME / LNCEL name / NRCEL name</strong> theo t√™n c·ªôt. V·∫Ω bi·ªÉu ƒë·ªì cho t·∫•t c·∫£ c√°c c·ªôt s·ªë
                    (tr·ª´ 2 c·ªôt ƒë·∫ßu). M·ªói c·ªôt s·ªë l√† m·ªôt chart, b·∫°n c√≥ th·ªÉ ch·ªçn
                    <strong>ki·ªÉu chart (line / bar / pie / doughnut / stacked area)</strong> v√†
                    <strong>s·ªë chart tr√™n 1 h√†ng</strong>.
                </p>
            </div>

            <!-- 2. KPI OVERVIEW THEO M·∫™U EXCEL -->
            <div
                class="data-table"
                id="excelTableCard"
                style="margin-top: 16px; margin-bottom: 24px"
            >
                <div class="excel-header-row">
                    <h3 id="excelTableTitle">KPI Overview (Ng√†y: ...)</h3>
                    <div class="excel-date-filter">
                        <label for="excelDateInput">Ng√†y:</label>
                        <input type="date" id="excelDateInput" />
                        <button type="button" id="excelLatestBtn" class="excel-latest-btn">Latest</button>
                    </div>
                </div>
                    <div
                id="kpiThresholdPanel"
                style="
                    margin-bottom: 10px;
                    padding: 8px 10px;
                    border-radius: 8px;
                    border: 1px dashed #d1d5db;
                    background: #f9fafb;
                    font-size: 0.85em;
                    display: none;
                "
            >
            <div style="display:flex; flex-wrap:wrap; gap:12px; align-items:center;">

                <!-- H√†ng 1: Ti√™u ƒë·ªÅ -->
                <strong>‚öôÔ∏è T√πy ch·ªânh ng∆∞·ª°ng:</strong>

                <!-- B·∫ÆT BU·ªòC TH√äM D√íNG N√ÄY ƒë·ªÉ xu·ªëng h√†ng -->
                <div style="width:100%;"></div>

                <!-- H√†ng 2: KPI + Operator + Threshold + Button -->
                <label style="display:flex; align-items:center;">
                    KPI:
                    <select
                        id="thresholdKpiSelect"
                        style="margin-left:4px; padding:4px 8px; min-width:220px;"
                    ></select>
                </label>

                <label style="display:flex; align-items:center;">
                    Operator:
                    <select
                        id="thresholdOpSelect"
                        style="margin-left:4px; padding:4px 8px; min-width:80px;"
                    >
                        <option value="">--</option>
                        <option value="<">&lt;</option>
                        <option value="<=">&lt;=</option>
                        <option value=">">&gt;</option>
                        <option value=">=">&gt;=</option>
                        <option value="=">=</option>
                        <option value="==">==</option>
                    </select>
                </label>

                <label style="display:flex; align-items:center;">
                    Threshold:
                    <input
                        id="thresholdValueInput"
                        type="number"
                        step="any"
                        style="margin-left:4px; padding:4px 6px; width:110px;"
                    />
                </label>

                <button
                    type="button"
                    id="thresholdApplyBtn"
                    style="
                        padding:6px 12px;
                        border-radius:6px;
                        border:1px solid #2563eb;
                        background:#2563eb;
                        color:#fff;
                        cursor:pointer;
                    "
                >
                    √Åp d·ª•ng
                </button>
                
                <div class="email-section-options">
                    <label>
                        <input type="checkbox" id="thresholdGlobalToggle">
                        K√≠ch ho·∫°t t√πy ch·ªânh
                    </label>
                </div>

            </div>

                </div>

                <div id="excelTable"></div>
            </div>

            </div>

            <!-- Charts -->
            <!-- B·ªô l·ªçc th·ªùi gian + m·ªëc line d·ªçc -->
            <div style="display:flex; align-items:flex-end; gap:16px; flex-wrap:wrap; margin:10px 0 6px;">

                <!-- Kho·∫£ng th·ªùi gian hi·ªÉn th·ªã -->
                <div class="control-group" id="chartTimeFilterBar" style="max-width:480px;">
                    <label>‚è± Kho·∫£ng th·ªùi gian hi·ªÉn th·ªã:</label>
                    <div style="display:flex; align-items:center; gap:6px;">
                        <select id="chartTimeFrom">
                            <option value="">T·ª´ (t·∫•t c·∫£)</option>
                        </select>
                        <span style="font-size:0.85em; color:#555;">‚Üí</span>
                        <select id="chartTimeTo">
                            <option value="">ƒê·∫øn (t·∫•t c·∫£)</option>
                        </select>
                        <button id="chartTimeClearBtn"
                            style="margin-left:4px; padding:4px 10px; font-size:0.8em;
                                border-radius:6px; border:1px solid #ccc;
                                background:#f8f8f8; cursor:pointer;">
                            Reset
                        </button>
                    </div>
                </div>

                <!-- M·ªëc th·ªùi gian v·∫Ω line d·ªçc -->
                <div class="control-group" style="max-width:420px;">
                    <label>üìç M·ªëc th·ªùi gian (v·∫Ω line d·ªçc):</label>
                    <div style="display:flex; align-items:center; gap:6px;">
                        <select id="chartVerticalTime">
                            <option value="">-- Kh√¥ng v·∫Ω --</option>
                        </select>
                        <button id="chartVerticalClearBtn"
                            style="padding:4px 10px; font-size:0.8em;
                                border-radius:6px; border:1px solid #ccc;
                                background:#f8f8f8; cursor:pointer;">
                            Reset
                        </button>
                    </div>
                </div>

            </div>


            <div id="chartsContainer"></div>

            <!-- WORST CELL -->
            <div class="data-table" id="worstCellCard" style="margin-top: 16px; display:none;">
                <h3 id="worstCellTitle">Worst Cell (Th·ªùi ƒëi·ªÉm g·∫ßn nh·∫•t)</h3>

                <!-- üîé B·ªô l·ªçc gi√° tr·ªã cho b·∫£ng Worst Cell -->
                <div id="worstFilterBar"
                    style="margin:4px 0 8px; font-size:0.85em; display:flex; flex-wrap:wrap; gap:8px; align-items:center;">
                    <strong>L·ªçc theo KPI:</strong>

                    <label style="display:flex; align-items:center; gap:4px;">
                        Logic:
                        <select
                            id="worstFilterLogic"
                            style="padding:4px 6px; border-radius:6px; border:1px solid #cbd5e1;"
                        >
                            <option value="AND">AND</option>
                            <option value="OR">OR</option>
                        </select>
                    </label>

                    <!-- üîç Filter Province -->


                    <button type="button" id="worstFilterAddBtn"
                            style="padding:4px 8px; border-radius:6px; border:1px solid #2563eb; background:#2563eb; color:#fff; cursor:pointer;">
                        + Th√™m ƒëi·ªÅu ki·ªán
                    </button>

                    <button type="button" id="worstFilterClearBtn"
                            style="padding:4px 8px; border-radius:6px; border:1px solid #6b7280; background:#f3f4f6; color:#111827; cursor:pointer;">
                        X√≥a filter
                    </button>



                    <label style="display:flex; align-items:center; gap:4px; margin-left:auto;">
                        Province:
                        <input 
                            type="text" 
                            id="worstProvinceFilter"
                            class="wc-filter-input"
                            placeholder="VD: LCI;LCU"
                            style="width:120px;"
                        />
                    </label>
                    <div style="margin-bottom:0px;">
                        <select id="worstPoFilter" style="padding:6px 10px;border-radius:6px;border:1px solid #b0b0b0;">
                            <option value="ALL">T·∫•t c·∫£ PO</option>
                        </select>
                    </div>
                    <!-- Danh s√°ch c√°c d√≤ng ƒëi·ªÅu ki·ªán KPI -->
                    <div id="worstFilterRules"
                        style="width:100%; margin-top:4px; display:flex; flex-direction:column; gap:4px;"></div>
                </div>



                <div id="worstCellTable"></div>

            </div>


            <!-- CELL NON-TRAFFIC -->
            <div class="data-table" id="nonTrafficCard" style="margin-top: 16px; display:none;">
                <h3 id="nonTrafficTitle">Cell Non-Traffic (Cell avail R = 0)</h3>
                <div id="nonTrafficTable"></div>
            </div>

            <!-- CQI -->
            <div class="data-table" id="cqiCard" style="margin-top: 16px; display:none;">

                <h3 id="cqiTitle">CQI</h3>

                <div style="
                    display:flex;
                    align-items:center;
                    gap:20px;
                    margin-bottom:10px;
                    flex-wrap:wrap;
                ">
                    <!-- Combobox PO -->
                    <label style="display:flex; align-items:center; gap:6px;">
                        <select id="cqiPoFilter" style="padding:4px 8px; border-radius:6px;">
                            <option value="ALL">T·∫•t c·∫£</option>
                        </select>
                    </label>

                    <!-- Checkbox Not Pass -->
                    <div class="email-section-options">
                        <label>
                            <input type="checkbox" id="cqiShowNotPassOnly">
                            Hi·ªÉn th·ªã danh s√°ch cell kh√¥ng ƒë·∫°t
                        </label>
                    </div>
                </div>

                <!-- B·∫£ng t·ªïng h·ª£p CQI (summary) -->
                <div style="font-style: italic; font-size: 14px; margin: 4px 0 6px 0;">
                    CQI Summary
                </div>
                <div id="cqiSummaryTable" style="margin-bottom:8px;"></div>

                <!-- B·∫£ng chi ti·∫øt CQI -->
                <div style="font-style: italic; font-size: 14px; margin: 14px 0 6px 0;">
                    CQI Details
                </div>
                <div id="cqiTable"></div>
            </div>


            <!-- B·∫¢NG KPI TH·ªúI ƒêI·ªÇM G·∫¶N NH·∫§T -->
            <div class="data-table" id="latestTableCard" style="margin-top: 16px;display:none;">
                <h3 id="latestTableTitle">B·∫£ng KPI th·ªùi ƒëi·ªÉm g·∫ßn nh·∫•t</h3>
                <div id="latestTable"></div>
            </div>

            <!-- EMAIL -->
            <div class="email-section">
                <div class="chart-card">
                    <h3>üìß G·ª≠i Email b√°o c√°o</h3>
                    <p
                        style="
                            text-align: center;
                            color: #666;
                            margin-bottom: 16px;
                            font-size: 0.9em;
                        "
                    >
                    </p>
                    <form id="emailForm">
                        <div class="email-form-group">
                            <label for="emailTo">Danh s√°ch email (c√°ch nhau b·ªüi d·∫•u ph·∫©y)</label>
                            <input
                                type="text"
                                id="emailTo"
                                name="to"
                                placeholder="vd: a@example.com, b@example.com"
                            />
                        </div>

                        <div class="email-form-group">
                            <label for="emailSubject">Ti√™u ƒë·ªÅ</label>
                            <input
                                type="text"
                                id="emailSubject"
                                name="subject"
                                placeholder="B√°o c√°o hi·ªáu su·∫•t theo ng√†y..."
                                required
                            />
                        </div>

                        <div class="email-form-group">
                            <label for="emailMessage">N·ªôi dung (m·ªü ƒë·∫ßu email)</label>
                            <textarea
                                id="emailMessage"
                                name="message"
                                placeholder="Nh·∫≠p n·ªôi dung email..."
                                required
                            ></textarea>
                            <div style="font-size: 12px; color: #6b7280; margin-top: 4px;">
                                G·ª£i √Ω: Ti√™u ƒë·ªÅ v√† N·ªôi dung c√≥ th·ªÉ d√πng placeholder 
                                <code>(POx)</code>, <code>(ng√†y g·∫ßn nh·∫•t)</code>, 
                                <code>(S·ªë tr·∫°m onair)</code>, <code>(T·ªïng s·ªë tr·∫°m POx)</code>. 
                                Khi xu·∫•t file .eml, c√°c placeholder n√†y s·∫Ω t·ª± thay b·∫±ng s·ªë li·ªáu th·ª±c t·∫ø.
                            </div>
                        </div>




                        <!-- Tick box PNG: n·∫±m NGAY d∆∞·ªõi label, m·∫∑c ƒë·ªãnh t√≠ch s·∫µn -->
                        <div style="margin:4px 0 8px 0;">
                            <label style="font-size:13px;">
                                <input
                                    type="checkbox"
                                    id="emailTablesAsImages"
                                    checked
                                >
                                Xu·∫•t c√°c b·∫£ng d∆∞·ªõi d·∫°ng h√¨nh PNG
                            </label>
                        </div>

                        <!-- CH·ªåN SECTION ƒê∆ØA V√ÄO EMAIL -->
                        <div class="email-form-group">
                        <label>C√°c ph·∫ßn s·∫Ω ch√®n v√†o email</label>

                        <div class="email-section-options">
                            <label>
                                <input type="checkbox" class="email-section-checkbox" value="progress" checked>
                                Ti·∫øn ƒë·ªô ƒëo ki·ªÉm
                            </label>
                            <label>
                                <input type="checkbox" class="email-section-checkbox" value="worstOverview" checked>
                                Worst Cell Overview
                            </label>
                            <label>
                                <input type="checkbox" class="email-section-checkbox" value="excel" checked>
                                KPI Overview
                            </label>
                            <label>
                                <input type="checkbox" class="email-section-checkbox" value="charts" checked>
                                Bi·ªÉu ƒë·ªì KPI
                            </label>
                            <label>
                                <input type="checkbox" class="email-section-checkbox" value="worst" checked>
                                Worst Cell
                            </label>
                            <label>
                                <input type="checkbox" class="email-section-checkbox" value="nonTraffic" checked>
                                Cell Non-Traffic
                            </label>
                            <label>
                                <input type="checkbox" class="email-section-checkbox" value="cqiSummary" checked>
                                CQI Summary
                            </label>
                        </div>



                        </div>

                        <div class="email-actions-row">
                            <button type="button" id="exportEmlChartsBtn" class="btn">
                                üíæ Xu·∫•t file Outlook
                            </button>


                        </div>
                        <div class="email-status" id="emailStatus"></div>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <script>
        let workbook = null;
        let currentData = null;
        let chartInstances = {};
        let numericColumns = [];
        let wsFilterValues = null;
        let currentWsValues = [];
        let periodColumnName = null;
        let wsNameColumnName = null;
        let chartDaysWindow = 14;
        let selectedKpiColumns = new Set();
        let mergedDataPerSheet = null;

        let wsSearchKeywords = ["", "", ""];
        let kpiMetaMap = {};
        let kpiMetaList = [];
        let excelSelectedDate = null;
        let funnelSortOrder = "desc";
        let emailIntroTouched = false;
        let chartConfigAppliedOnce = false;   // √°p sheet t·ª´ c·∫•u h√¨nh c≈© ƒë√∫ng 1 l·∫ßn
        let chartTargetVisible = {}; // NEW: l∆∞u tr·∫°ng th√°i checkbox "Target" theo t·ª´ng KPI
        let globalThresholdEnabled = false; // Checkbox t·ªïng: Target column + highlight + target line
        const chartYAxisRange = {}; // { [valueCol]: { min: number|null, max: number|null } }
        let chartVerticalTimeValue = null; // m·ªëc th·ªùi gian ƒë∆∞·ª£c ch·ªçn

        // ===== LINK TH∆Ø M·ª§C KPI TR√äN ONEDRIVE (C√ÅCH 2) =====
        const ONEDRIVE_KPI_URL = "https://rnovnpt-my.sharepoint.com/personal/anhnqt_rnovnpt_onmicrosoft_com/_layouts/15/onedrive.aspx?id=%2Fpersonal%2Fanhnqt%5Frnovnpt%5Fonmicrosoft%5Fcom%2FDocuments%2FKPI%20Scheduler&ga=1";

        // M·ªü th∆∞ m·ª•c KPI tr√™n OneDrive trong tab m·ªõi
        function openOneDriveKpiFolder() {
            // N·∫øu sau n√†y ƒë·ªïi link, ch·ªâ c·∫ßn s·ª≠a ONEDRIVE_KPI_URL ·ªü tr√™n
            window.open(ONEDRIVE_KPI_URL, "_blank");
        }


        // B·∫¢NG NG∆Ø·ª†NG KPI
        let kpiThresholdMap = null;
        let customThresholdMap = {}; // l∆∞u t√πy ch·ªânh vƒ©nh vi·ªÖn
        let worstCellThresholdMap = null;   // sheet "WorstCell Threshold"
        // Map ph·ª•c v·ª• b·∫£ng CQI
        let provinceAreaMap = {};      // Province -> Area (t·ª´ file KPI Threshhold / sheet "Province Area")
        let cqiConfigMap    = {};      // ID -> { config, target } (t·ª´ sheet "CQI Threshold")
        let progressPoBySiteMap = {};  // Site Name (LNBTS) -> PO (t·ª´ file ti·∫øn ƒë·ªô CQT-SSV)

        // ==== C·∫§U H√åNH FILE KPI N·∫∂NG ====
        const HEAVY_KPI_ROW_THRESHOLD = 5000;   // > 3k d√≤ng coi l√† file n·∫∑ng
        let isHeavyKpiFile = false;

        Chart.register(ChartDataLabels);
        
        const verticalLinePlugin = {
            id: 'verticalLinePlugin',
            afterDraw(chart) {
                if (!chartVerticalTimeValue) return;

                const xScale = chart.scales.x;
                if (!xScale) return;

                const x = xScale.getPixelForValue(chartVerticalTimeValue);
                if (isNaN(x)) return;

                const ctx = chart.ctx;
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(x, chart.chartArea.top);
                ctx.lineTo(x, chart.chartArea.bottom);
                ctx.strokeStyle = '#ef4444';   // ƒë·ªè
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.stroke();
                ctx.restore();
            }
        };

        Chart.register(verticalLinePlugin);

        function updateWsSearchKeywordsFromInputs() {
            const i1 = document.getElementById("wsSearchInput1");
            const i2 = document.getElementById("wsSearchInput2");
            const i3 = document.getElementById("wsSearchInput3");
            wsSearchKeywords = [
                i1 ? i1.value : "",
                i2 ? i2.value : "",
                i3 ? i3.value : "",
            ];
        }

        // L·∫•y Area theo Province t·ª´ provinceAreaMap
        function getAreaFromProvince(province) {
            if (!province) return "";
            const key   = String(province).trim().toUpperCase();
            const entry = provinceAreaMap[key];
            if (!entry) return "";
            if (typeof entry === "string") return entry;   // t∆∞∆°ng th√≠ch code c≈©
            return entry.area || "";
        }


        // Load custom thresholds t·ª´ LocalStorage
        function loadCustomThresholds() {
            try {
                const data = localStorage.getItem("customThresholdMap");
                if (data) {
                    customThresholdMap = JSON.parse(data);
                }
            } catch (e) {
                console.error("Cannot load custom thresholds", e);
            }
        }
        loadCustomThresholds();
        function wsPassesTextFilters(wsLower) {
            for (const kw of wsSearchKeywords) {
                const trimmed = (kw || "").trim().toLowerCase();
                if (!trimmed) continue;

                const terms = trimmed
                    .split(";")
                    .map((t) => t.trim())
                    .filter(Boolean);
                if (!terms.length) continue;

                const matchesThisBox = terms.some((term) => wsLower.includes(term));
                if (!matchesThisBox) {
                    return false;
                }
            }
            return true;
        }

        // Drag & drop ch·ªâ ho·∫°t ƒë·ªông khi tr√™n trang c√≥ ph·∫ßn t·ª≠ #uploadArea
const uploadArea = document.getElementById("uploadArea");

if (uploadArea) {
    uploadArea.addEventListener("dragover", (e) => {
        e.preventDefault();
        uploadArea.classList.add("dragover");
    });

    uploadArea.addEventListener("dragleave", () => {
        uploadArea.classList.remove("dragover");
    });

    uploadArea.addEventListener("drop", (e) => {
        e.preventDefault();
        uploadArea.classList.remove("dragover");

        const files = Array.from(e.dataTransfer.files || []).filter(f =>
            /\.(xlsx|xls)$/i.test(f.name)
        );

        if (!files.length) {
            alert("K√©o th·∫£ kh√¥ng c√≥ file Excel (.xlsx, .xls) h·ª£p l·ªá!");
            return;
        }

        if (files.length === 1) {
            processFile(files[0]);
        } else {
            processMultipleFiles(files);
        }
    });
}


        function handleFileFromFiles(e) {
            const files = Array.from(e.target.files || []).filter(f =>
                /\.(xlsx|xls)$/i.test(f.name)
            );
            if (!files.length) return;

            if (files.length === 1) {
                processFile(files[0]);
            } else {
                processMultipleFiles(files);
            }
        }

        // ====== Bi·∫øn global l∆∞u map folder & nh√≥m file ======
        let folderFileMap = {};      // { folderName: File[] }
        let currentFolderName = "";
        let currentGroupMap = {};    // { groupName: File[] }

// L·∫•y t√™n folder con.
// N·∫øu t·∫•t c·∫£ file n·∫±m ngay trong th∆∞ m·ª•c ƒë∆∞·ª£c ch·ªçn (kh√¥ng c√≥ folder con)
// th√¨ tr·∫£ v·ªÅ "(ROOT)"
        function getFolderNameFromFile(file) {
            const rel = file.webkitRelativePath;

            if (!rel) {
                // Tr∆∞·ªùng h·ª£p ch·ªçn t·ª´ng file (kh√¥ng ph·∫£i ch·ªçn th∆∞ m·ª•c)
                return "(ROOT)";
            }

            // Chu·∫©n h√≥a c·∫£ / v√† \
            const parts = rel.split(/[\\/]/);
            // V√≠ d·ª•:
            //  - Ch·ªçn folder: KPI Scheduler
            //    + Kh√¥ng c√≥ folder con: "KPI Scheduler\\file1.xlsx"  -> parts.length = 2
            //    + C√≥ folder con:       "KPI Scheduler\\Sub\\f1.xlsx" -> parts.length >= 3

            if (parts.length <= 2) {
                // Ch·ªâ c√≥ [T√™n th∆∞ m·ª•c ƒë∆∞·ª£c ch·ªçn, T√™n file]
                return "(ROOT)";
            }

            // C√≥ folder con
            return parts[1] || "(ROOT)";
        }



        // L·∫•y group name = ph·∫ßn tr∆∞·ªõc d·∫•u "-" trong t√™n file
        // 5G_KPI_Daily_Report-vnpt_tec-2025_11_20-... -> 5G_KPI_Daily_Report
        function getGroupNameFromFile(file) {
            const name = file.name || "";
            const idx = name.indexOf("-");
            if (idx > 0) {
                return name.substring(0, idx);
            }
            // kh√¥ng c√≥ d·∫•u "-" th√¨ tr·∫£ lu√¥n full name
            return name;
        }

// Gi√° tr·ªã ƒë·∫∑c bi·ªát cho l·ª±a ch·ªçn "T·∫•t c·∫£"
// Gi√° tr·ªã ƒë·∫∑c bi·ªát cho l·ª±a ch·ªçn "T·∫•t c·∫£"
const ALL_FOLDERS_VALUE = "__ALL__";

function populateFolderSelectOptions() {
    const folderSelect = document.getElementById("folderSelect");
    const groupSelect  = document.getElementById("fileGroupSelect");
    const wrapper      = document.getElementById("folderFileSelectors");

    if (!folderSelect || !groupSelect || !wrapper) return;

    // T·∫•t c·∫£ folder ƒë·ªçc ƒë∆∞·ª£c t·ª´ th∆∞ m·ª•c KPI (local)
    const allFolderNames = Object.keys(folderFileMap);

    if (!allFolderNames.length) {
        wrapper.style.display = "none";
        return;
    }

    // Tr∆∞·ªùng h·ª£p ch·ªâ c√≥ ROOT
    const hasOnlyRoot =
        allFolderNames.length === 1 && allFolderNames[0] === "(ROOT)";

    wrapper.style.display = "flex";

    if (hasOnlyRoot) {
        // Ch·ªâ c√≥ ROOT ‚Üí ·∫©n combobox Th∆∞ m·ª•c, ch·ªâ hi·ªán Nh√≥m file
        folderSelect.parentElement.style.display = "none";

        currentFolderName = "(ROOT)";
        buildGroupMapForCurrentFolder("(ROOT)");
        return;
    }

    // üîπ C√≥ folder con ‚Üí ch·ªâ gi·ªØ nh·ªØng th∆∞ m·ª•c b·∫Øt ƒë·∫ßu b·∫±ng "NA"
    let folderNames = allFolderNames.filter((name) => /^NA/i.test(name));

    // N·∫øu kh√¥ng c√≥ th∆∞ m·ª•c NAxx n√†o th√¨ fallback v·ªÅ to√†n b·ªô danh s√°ch
    // (ƒë·ªÉ tr√°nh tr∆∞·ªùng h·ª£p th∆∞ m·ª•c kh√¥ng c√≥ NA nh∆∞ng v·∫´n d√πng ƒë∆∞·ª£c)
    if (!folderNames.length) {
        folderNames = allFolderNames;
    }

    // Hi·ªán combobox Th∆∞ m·ª•c + th√™m l·ª±a ch·ªçn "T·∫•t c·∫£"
    folderSelect.parentElement.style.display = "inline-block";

    folderSelect.innerHTML = "";

    // ‚ûï Option "T·∫•t c·∫£"
    const allOpt = document.createElement("option");
    allOpt.value = ALL_FOLDERS_VALUE;
    allOpt.textContent = "T·∫•t c·∫£";
    folderSelect.appendChild(allOpt);

    // C√°c folder c√≤n l·∫°i (ƒë√£ l·ªçc)
    folderNames.sort().forEach((folder) => {
        const opt = document.createElement("option");
        opt.value = folder;
        opt.textContent = folder;
        folderSelect.appendChild(opt);
    });

    // M·∫∑c ƒë·ªãnh ch·ªçn "T·∫•t c·∫£"
    currentFolderName = ALL_FOLDERS_VALUE;
    folderSelect.value = ALL_FOLDERS_VALUE;
    buildGroupMapForCurrentFolder(ALL_FOLDERS_VALUE);
}

function buildGroupMapForCurrentFolder(folderName) {
    const folderSelect = document.getElementById("folderSelect");
    const groupSelect = document.getElementById("fileGroupSelect");
    if (!groupSelect) return;

    // ∆Øu ti√™n: tham s·ªë truy·ªÅn v√†o -> gi√° tr·ªã combobox -> folder hi·ªán t·∫°i
    let effectiveFolder =
        folderName ||
        (folderSelect && folderSelect.value) ||
        currentFolderName ||
        "(ROOT)";


    currentFolderName = effectiveFolder;

    let filesInFolder = [];

    if (effectiveFolder === ALL_FOLDERS_VALUE) {
        // ‚úÖ T·∫•t c·∫£ folder: g·ªôp to√†n b·ªô file trong folderFileMap
        Object.values(folderFileMap).forEach(list => {
            filesInFolder = filesInFolder.concat(list);
        });
    } else {
        // M·ªôt folder c·ª• th·ªÉ
        filesInFolder = folderFileMap[effectiveFolder] || [];
    }

    currentGroupMap = {};

    filesInFolder.forEach((file) => {
        const gName = getGroupNameFromFile(file); // h√†m anh ƒëang d√πng
        if (!currentGroupMap[gName]) currentGroupMap[gName] = [];
        currentGroupMap[gName].push(file);
    });

    const groupNames = Object.keys(currentGroupMap).sort();

    groupSelect.innerHTML = "";
    groupNames.forEach((g) => {
        const opt = document.createElement("option");
        opt.value = g;
        opt.textContent = `${g} (${currentGroupMap[g].length} file)`;
        groupSelect.appendChild(opt);
    });

    if (groupNames.length) {
        groupSelect.value = groupNames[0];
    }
}

        function loadSelectedGroupFiles() {
            const groupSelect = document.getElementById("fileGroupSelect");
            if (!groupSelect) return;
            const gName = groupSelect.value;
            const files = currentGroupMap[gName] || [];

            if (!files.length) {
                alert("Nh√≥m file ƒëang ch·ªçn kh√¥ng c√≥ file Excel n√†o.");
                return;
            }

            // G·ªçi l·∫°i logic g·ªôp nhi·ªÅu file c√≥ s·∫µn
            processMultipleFiles(files);
        }
// ========== OneDrive Graph API ‚Äì ƒë·ªçc tr·ª±c ti·∫øp file (KPI Scheduler) ==========

// 1. C·∫•u h√¨nh ·ª©ng d·ª•ng Azure AD (anh T·ª∞ THAY clientId / tenantId cho ƒë√∫ng)
const msalConfig = {
    auth: {
        clientId: "25293ad9-adbd-4a01-b437-790c1846deb6", // TODO: thay b·∫±ng Application (client) ID t·ª´ Azure portal
        authority: "https://login.microsoftonline.com/59368d93-4334-44cb-86ac-acd0bde56fcd", // TODO: thay b·∫±ng Directory (tenant) ID
        redirectUri: window.location.origin
    }
};

// Ph·∫°m vi ch·ªâ c·∫ßn ƒë·ªÉ ƒë·ªçc file trong OneDrive
const loginRequest = {
    scopes: ["Files.Read.All"]
};

// ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c KPI trong OneDrive (t∆∞∆°ng ƒë·ªëi so v·ªõi root)
// V√≠ d·ª• chu·∫©n v·ªõi link anh g·ª≠i: "/Documents/KPI Scheduler"
const graphKpiConfig = {
    kpiFolderPath: "/KPI Scheduler"
};

// Bi·∫øn d√πng chung
let msalInstance = null;
let oneDriveAccount = null;
// Map th∆∞ m·ª•c OneDrive -> danh s√°ch file (metadata)
let oneDriveFolderFileMap = {}; // { folderName: [{ itemId, name, downloadUrl, lastModified }] }
let oneDriveCurrentFolderName = "";
// Map nh√≥m file trong th∆∞ m·ª•c ƒëang ch·ªçn
let oneDriveGroupMap = {}; // { groupName: [{ itemId, name, downloadUrl, lastModified }] }

function setLocalExcelInputsEnabled(enabled) {
    const fileInput   = document.getElementById("fileInputFiles");
    const folderInput = document.getElementById("fileInputFolder");

    const fileLabel = fileInput
        ? fileInput.closest("label.upload-sub-btn")
        : null;
    const folderLabel = folderInput
        ? folderInput.closest("label.upload-sub-btn")
        : null;

    [fileInput, folderInput].forEach((el) => {
        if (el) el.disabled = !enabled;
    });

    [fileLabel, folderLabel].forEach((lbl) => {
        if (!lbl) return;
        if (enabled) {
            lbl.classList.remove("disabled-upload");
        } else {
            lbl.classList.add("disabled-upload");
        }
    });
}

// Kh·ªüi t·∫°o UI OneDrive: g·∫Øn event cho c√°c n√∫t / select
function initOneDriveGraphUI() {
    if (typeof msal === "undefined") {
        console.warn(
            "MSAL library ch∆∞a ƒë∆∞·ª£c load ‚Äì ki·ªÉm tra <script src='...msal-browser.min.js'>"
        );
        return;
    }

    msalInstance = new msal.PublicClientApplication(msalConfig);

    // N·∫øu ƒë√£ c√≥ account t·ª´ session tr∆∞·ªõc th√¨ l·∫•y l·∫°i
    const accounts = msalInstance.getAllAccounts();
    if (accounts && accounts.length > 0) {
        oneDriveAccount = accounts[0];
    }

    const loginBtn           = document.getElementById("odLoginBtn");
    const loadGroupBtn       = document.getElementById("odLoadGroupBtn");
    const statusSpan         = document.getElementById("odStatus");
    const statusRow          = document.getElementById("odGroupBar"); // d√πng ƒë√∫ng id
    const kpiFolderInput     = document.getElementById("kpiFolderInput");
    const kpiFolderUpdateBtn = document.getElementById("kpiFolderUpdateBtn");

    // G√°n s·∫µn ƒë∆∞·ªùng d·∫´n ƒëang c·∫•u h√¨nh v√†o textbox
    if (kpiFolderInput) {
        kpiFolderInput.value = graphKpiConfig.kpiFolderPath || "/";
    }

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i ban ƒë·∫ßu
    if (statusSpan) {
        if (oneDriveAccount) {
            if (statusRow) statusRow.style.display = "flex";
            statusSpan.textContent =
                "ƒê√£ ƒëƒÉng nh·∫≠p: " +
                (oneDriveAccount.username || oneDriveAccount.name || "") +
                " ‚Äì Th∆∞ m·ª•c: " +
                (graphKpiConfig.kpiFolderPath || "/");

            // ‚úÖ ƒê√£ c√≥ session OneDrive ‚Üí cho ph√©p ch·ªçn file/folder Excel local
            setLocalExcelInputsEnabled(true);

            // N·∫øu ƒë√£ c√≥ session ƒëƒÉng nh·∫≠p ‚Üí load lu√¥n danh s√°ch nh√≥m
            odLoadKpiGroupsFromOneDrive();
        } else {
            statusSpan.textContent = "Ch∆∞a ƒëƒÉng nh·∫≠p OneDrive";
            if (statusRow) statusRow.style.display = "none";

            // üîí Ch∆∞a ƒëƒÉng nh·∫≠p ‚Üí v·∫´n kho√°
            setLocalExcelInputsEnabled(false);
        }
    }

    if (loginBtn) {
        loginBtn.addEventListener("click", async () => {
            await handleOneDriveLogin();
        });
    }

    if (loadGroupBtn) {
        loadGroupBtn.addEventListener("click", async () => {
            await odLoadSelectedGroupFromOneDrive();
        });
    }

    // Khi b·∫•m ‚ÄúC·∫≠p nh·∫≠t‚Äù ‚Üí ƒë·ªïi kpiFolderPath + load l·∫°i combobox
    if (kpiFolderUpdateBtn) {
        kpiFolderUpdateBtn.addEventListener("click", async () => {
            await updateKpiFolderPathAndReload();
        });
    }

    // Nh·∫•n Enter trong textbox c≈©ng nh∆∞ b·∫•m n√∫t C·∫≠p nh·∫≠t
    if (kpiFolderInput) {
        kpiFolderInput.addEventListener("keydown", async (evt) => {
            if (evt.key === "Enter") {
                evt.preventDefault();
                await updateKpiFolderPathAndReload();
            }
        });
    }
}

async function updateKpiFolderPathAndReload() {
    const input = document.getElementById("kpiFolderInput");
    const statusSpan = document.getElementById("odStatus");

    if (!input) return;

    const newPath = input.value.trim();

    if (!newPath) {
        alert("Vui l√≤ng nh·∫≠p ƒë∆∞·ªùng d·∫´n th∆∞ m·ª•c, v√≠ d·ª•: /KPI Scheduler");
        return;
    }

    // C·∫≠p nh·∫≠t c·∫•u h√¨nh
    graphKpiConfig.kpiFolderPath = newPath;

    // C·∫≠p nh·∫≠t text tr·∫°ng th√°i (n·∫øu ƒë√£ ƒëƒÉng nh·∫≠p)
    if (statusSpan && oneDriveAccount) {
        statusSpan.textContent =
            "ƒê√£ ƒëƒÉng nh·∫≠p: " +
            (oneDriveAccount.username || oneDriveAccount.name || "") +
            " ‚Äì Th∆∞ m·ª•c: " +
            (graphKpiConfig.kpiFolderPath || "/");
    }

    // N·∫øu ƒë√£ ƒëƒÉng nh·∫≠p OneDrive ‚Üí load l·∫°i danh s√°ch nh√≥m theo path m·ªõi
    if (oneDriveAccount) {
        await odLoadKpiGroupsFromOneDrive();
    } else {
        alert("ƒê√£ c·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n, h√£y ƒëƒÉng nh·∫≠p OneDrive ƒë·ªÉ ƒë·ªçc danh s√°ch file.");
    }
}

// ƒêƒÉng nh·∫≠p OneDrive (popup)
async function handleOneDriveLogin() {
    const statusSpan = document.getElementById("odStatus");
    const statusRow  = document.getElementById("odGroupBar");

    try {
        if (!msalInstance) {
            msalInstance = new msal.PublicClientApplication(msalConfig);
        }

        const loginResp = await msalInstance.loginPopup(loginRequest);
        oneDriveAccount = loginResp.account;

        if (statusRow) statusRow.style.display = "flex";
        if (statusSpan) {
            statusSpan.textContent =
                "ƒê√£ ƒëƒÉng nh·∫≠p: " +
                (oneDriveAccount.username || oneDriveAccount.name || "") +
                " ‚Äì Th∆∞ m·ª•c: " +
                (graphKpiConfig.kpiFolderPath || "/");
        }

        // ‚úÖ Login th√†nh c√¥ng ‚Üí m·ªü kho√° 2 n√∫t Excel local
        setLocalExcelInputsEnabled(true);

        // Sau khi login xong ‚Üí load danh s√°ch nh√≥m file trong th∆∞ m·ª•c KPI Scheduler
        await odLoadKpiGroupsFromOneDrive();
        } catch (err) {
            console.error("L·ªói ƒëƒÉng nh·∫≠p OneDrive:", err);
            if (statusSpan) {
                statusSpan.textContent = "ƒêƒÉng nh·∫≠p th·∫•t b·∫°i";
            }
            if (statusRow) statusRow.style.display = "flex"; // v·∫´n hi·ªán ƒë·ªÉ th·∫•y l·ªói

            // üîí L·ªói ƒëƒÉng nh·∫≠p ‚Üí ti·∫øp t·ª•c kh√≥a
            setLocalExcelInputsEnabled(false);

            alert(
                "Kh√¥ng ƒëƒÉng nh·∫≠p ƒë∆∞·ª£c OneDrive. Ki·ªÉm tra l·∫°i c·∫•u h√¨nh Azure AD v√† th·ª≠ l·∫°i.\n" +
                    err.message
            );
        }
}


// L·∫•y access token ƒë·ªÉ g·ªçi Graph
async function getGraphAccessToken() {
    if (!msalInstance) {
        msalInstance = new msal.PublicClientApplication(msalConfig);
    }

    const account = oneDriveAccount || (msalInstance.getAllAccounts()[0] || null);
    if (!account) {
        // Ch∆∞a login ‚Üí b·∫≠t popup
        const loginResp = await msalInstance.loginPopup(loginRequest);
        oneDriveAccount = loginResp.account;
    }

    const request = {
        ...loginRequest,
        account: oneDriveAccount || msalInstance.getAllAccounts()[0]
    };

    try {
        const tokenResp = await msalInstance.acquireTokenSilent(request);
        return tokenResp.accessToken;
    } catch (silentErr) {
        console.warn("Silent token th·∫•t b·∫°i, fallback loginPopup:", silentErr);
        const tokenResp = await msalInstance.acquireTokenPopup(request);
        return tokenResp.accessToken;
    }
}

// Helper g·ªçi Graph API tr·∫£ v·ªÅ JSON
async function graphGetJson(endpoint) {
    const token = await getGraphAccessToken();
    const url = "https://graph.microsoft.com/v1.0" + endpoint;

    const res = await fetch(url, {
        headers: {
            Authorization: "Bearer " + token
        }
    });

    if (!res.ok) {
        const txt = await res.text();
        throw new Error("Graph API l·ªói " + res.status + ": " + txt);
    }

    return res.json();
}


function odPopulateFolderSelectOptions() {
    const folderSelect = document.getElementById("odFolderSelect");
    const groupSelect  = document.getElementById("odGroupSelect");

    if (!folderSelect || !groupSelect) return;

    const allFolders = Object.keys(oneDriveFolderFileMap);

    console.log("=== Build combobox Th∆∞ m·ª•c OneDrive ===");
    console.log("T·∫•t c·∫£ folder keys trong oneDriveFolderFileMap:", allFolders);

    if (!allFolders.length) {
        folderSelect.parentElement.style.display = "none";
        groupSelect.innerHTML = "";
        oneDriveGroupMap = {};
        console.log("Kh√¥ng c√≥ folder n√†o -> ·∫©n combobox Th∆∞ m·ª•c.");
        return;
    }

    const hasOnlyRoot = allFolders.length === 1 && allFolders[0] === "(ROOT)";

    if (hasOnlyRoot) {
        // Ch·ªâ c√≥ ROOT ‚Üí ·∫©n combobox Th∆∞ m·ª•c, ch·ªâ ƒë·ªÉ "Nh√≥m file"
        folderSelect.parentElement.style.display = "none";

        oneDriveCurrentFolderName = "(ROOT)";
        console.log(
            "Ch·ªâ c√≥ (ROOT), kh√¥ng c√≥ subfolder -> Th∆∞ m·ª•c = (ROOT), build group cho (ROOT)"
        );
        odBuildGroupMapForCurrentFolder("(ROOT)");
        return;
    }

    // üîé L·ªçc c√°c folder b·∫Øt ƒë·∫ßu b·∫±ng "NA" (NA08, NA12, ...)
    let displayFolders = allFolders.filter(name => /^NA/i.test(name || ""));

    // N·∫øu kh√¥ng folder n√†o b·∫Øt ƒë·∫ßu "NA" th√¨ d√πng t·∫•t c·∫£ (tr·ª´ (ROOT))
    if (!displayFolders.length) {
        displayFolders = allFolders.filter(name => name !== "(ROOT)");
    }

    console.log("Folder s·∫Ω hi·ªÉn th·ªã trong combobox Th∆∞ m·ª•c:", displayFolders);

    // Hi·ªán combobox Th∆∞ m·ª•c
    folderSelect.parentElement.style.display = "inline-block";
    folderSelect.innerHTML = "";

    // Option "T·∫•t c·∫£"
    const allOpt = document.createElement("option");
    allOpt.value = ALL_FOLDERS_VALUE;
    allOpt.textContent = "T·∫•t c·∫£";
    folderSelect.appendChild(allOpt);

    // C√°c folder c√≤n l·∫°i
    displayFolders.sort().forEach((folder) => {
        const opt = document.createElement("option");
        opt.value = folder;
        opt.textContent = folder;
        folderSelect.appendChild(opt);

        const files = oneDriveFolderFileMap[folder] || [];
        console.log(
            `  - Folder trong combobox "${folder}": ${files.length} file`,
            files.map(f => f.name)
        );
    });

    // Default = "T·∫•t c·∫£"
    oneDriveCurrentFolderName = ALL_FOLDERS_VALUE;
    folderSelect.value = ALL_FOLDERS_VALUE;
    console.log('Th∆∞ m·ª•c m·∫∑c ƒë·ªãnh = "T·∫•t c·∫£" -> gom', displayFolders.length, "folder.");
    odBuildGroupMapForCurrentFolder(ALL_FOLDERS_VALUE);
}

function odBuildGroupMapForCurrentFolder(folderName) {
    const folderSelect  = document.getElementById("odFolderSelect");
    const groupSelect   = document.getElementById("odGroupSelect");
    if (!groupSelect) return;

    let effectiveFolder =
        folderName ||
        (folderSelect && folderSelect.value) ||
        oneDriveCurrentFolderName ||
        "(ROOT)";

    oneDriveCurrentFolderName = effectiveFolder;

    console.log("=== Build Nh√≥m file cho Th∆∞ m·ª•c =", effectiveFolder, "===");

    let filesInFolder = [];

    if (effectiveFolder === ALL_FOLDERS_VALUE) {
        // Gom t·∫•t c·∫£ folder (∆∞u ti√™n folder NAxx, n·∫øu kh√¥ng c√≥ th√¨ l·∫•y h·∫øt)
        const allFolders = Object.keys(oneDriveFolderFileMap);
        let includeFolders = allFolders.filter((name) => /^NA/i.test(name || ""));
        if (!includeFolders.length) {
            includeFolders = allFolders;
        }

        includeFolders.forEach((name) => {
            const list = oneDriveFolderFileMap[name] || [];
            filesInFolder = filesInFolder.concat(list);
        });

        console.log(
            "Gom file t·ª´ c√°c folder:",
            includeFolders,
            "| T·ªïng file =", filesInFolder.length
        );
    } else {
        filesInFolder = oneDriveFolderFileMap[effectiveFolder] || [];
        console.log(
            "Files trong folder",
            effectiveFolder,
            "=",
            filesInFolder.length
        );
    }

    console.log(
        "Danh s√°ch file (tr∆∞·ªõc khi l·ªçc [S]):",
        filesInFolder.map((f) => f.name)
    );

    // Ch·ªâ gi·ªØ file t√™n b·∫Øt ƒë·∫ßu b·∫±ng "[S]"
    filesInFolder = filesInFolder.filter((item) => {
        const n = (item.name || "").trim();
        return n.startsWith("[S]");
    });

    console.log(
        'Danh s√°ch file (sau khi l·ªçc ch·ªâ c√≤n "[S]..."):',
        filesInFolder.map((f) => f.name)
    );

    // Reset group map
    oneDriveGroupMap = {};
    groupSelect.innerHTML = "";

    // Gom group theo prefix tr∆∞·ªõc d·∫•u '-' (d√πng l·∫°i h√†m getGroupNameFromFile ƒë√£ c√≥ s·∫µn)
    filesInFolder.forEach((item) => {
        const group = getGroupNameFromFile(item);   // ‚úÖ d√πng helper c≈©, KH√îNG c√≤n l·ªói

        if (!oneDriveGroupMap[group]) {
            oneDriveGroupMap[group] = [];
        }
        oneDriveGroupMap[group].push(item);
    });

    const groupNames = Object.keys(oneDriveGroupMap).sort();
    console.log("C√°c nh√≥m file [S] t√¨m ƒë∆∞·ª£c:", groupNames);

    if (!groupNames.length) {
        console.warn("Kh√¥ng c√≥ group n√†o -> combobox Nh√≥m file s·∫Ω r·ªóng.");
        return;
    }

    groupNames.forEach((g) => {
        const opt = document.createElement("option");
        opt.value = g;
        opt.textContent = `${g} (${oneDriveGroupMap[g].length} file)`;
        groupSelect.appendChild(opt);
    });

    groupSelect.value = groupNames[0];
}

// Fetch t·∫•t c·∫£ trang (paging) c·ªßa Graph: gom h·∫øt .value
async function graphGetAll(endpoint) {
  const token = await getGraphAccessToken();
  const base = "https://graph.microsoft.com/v1.0";

  // c√≥ th·ªÉ endpoint l√† relative (/me/...) ho·∫∑c absolute (nextLink)
  let url = endpoint.startsWith("http") ? endpoint : (base + endpoint);

  const all = [];
  while (url) {
    const res = await fetch(url, { headers: { Authorization: "Bearer " + token } });
    if (!res.ok) {
      const txt = await res.text();
      throw new Error("Graph API l·ªói " + res.status + ": " + txt);
    }

    const data = await res.json();
    all.push(...(data.value || []));
    url = data["@odata.nextLink"] || null;
  }

  return { value: all };
}


// ƒê·ªçc c√°c file Excel ƒë∆∞·ª£c share (SharedWithMe) c√≥ li√™n quan t·ªõi ƒë∆∞·ªùng d·∫´n KPI
async function odLoadSharedExcelFilesForKpiPath() {
    // L·∫•y t·ª´ kh√≥a cu·ªëi c·ªßa ƒë∆∞·ªùng d·∫´n KPI, v√≠ d·ª•: "/Documents/KPI Scheduler" -> "KPI Scheduler"
    const rawPath = graphKpiConfig.kpiFolderPath || "/";
    let keyword = rawPath
        .split("/")
        .filter(Boolean)
        .pop() || "";
    keyword = keyword.toLowerCase();

    // G·ªçi Graph API sharedWithMe
    const data = await graphGetJson("/me/drive/sharedWithMe");
    const items = (data && data.value) || [];

    console.log("OD root items:", items.map(i => i.name)); // üëà xem t√™n th∆∞ m·ª•c / file th·ª±c t·∫ø

    const isExcel = (name) => /\.(xlsx|xlsm?|xls)$/i.test(name || "");
    const resultMap = {}; // { folderName: [item...] }

    items.forEach((it) => {
        const remote = it.remoteItem || {};
        const name = remote.name || it.name || "";
        if (!isExcel(name)) return;

        const parentRef  = remote.parentReference || {};
        const parentPath = (parentRef.path || "").toLowerCase();

        // N·∫øu c√≥ c·∫•u h√¨nh KPI path, ch·ªâ gi·ªØ c√°c file m√† path cha c√≥ ch·ª©a keyword (vd "KPI Scheduler")
        if (keyword && parentPath && !parentPath.includes(keyword)) {
            return;
        }

        const folderName = parentRef.name || "Shared (t·ª´ ng∆∞·ªùi kh√°c)";

        if (!resultMap[folderName]) {
            resultMap[folderName] = [];
        }

        resultMap[folderName].push({
            itemId: remote.id || it.id,
            name,
            downloadUrl:
                (remote["@microsoft.graph.downloadUrl"]) ||
                it["@microsoft.graph.downloadUrl"] ||
                null,
            lastModified:
                remote.lastModifiedDateTime ||
                it.lastModifiedDateTime ||
                ""
        });
    });

    return resultMap;
}

// ƒê·ªçc th∆∞ m·ª•c KPI ƒë∆∞·ª£c share (SharedWithMe) b·∫±ng remoteItem
// D√πng t√™n th∆∞ m·ª•c cu·ªëi trong graphKpiConfig.kpiFolderPath, v√≠ d·ª•:
//  "/KPI Scheduler"  -> t√¨m folder share t√™n "KPI Scheduler"

// ƒê·ªá quy duy·ªát to√†n b·ªô c√¢y th∆∞ m·ª•c trong 1 drive, l·∫•y t·∫•t c·∫£ file Excel
async function getAllExcelFiles(driveId, rootFolderId) {
    const result = [];
    const isExcel = (name) => /\.(xlsx|xlsm?|xls)$/i.test(name || "");

    async function traverse(folderId) {
        const childrenData = await graphGetAll(`/drives/${enc(driveId)}/items/${enc(folderId)}/children?$top=999`);
        const children = (childrenData && childrenData.value) || [];

        for (const c of children) {
            if (c.folder) {
                // üëâ c√≥ subfolder th√¨ ƒëi ti·∫øp
                await traverse(c.id);
            } else if (isExcel(c.name)) {
                result.push({
                    itemId: c.id,
                    name: c.name,
                    downloadUrl: c["@microsoft.graph.downloadUrl"] || null,
                    lastModified: c.lastModifiedDateTime || ""
                });
            }
        }
    }

    await traverse(rootFolderId);
    return result;
}


// ƒê·ªçc T·∫§T C·∫¢ th∆∞ m·ª•c ƒë∆∞·ª£c share cho m√¨nh (SharedWithMe) v√† gom file Excel
// Tr·∫£ v·ªÅ: { folderName: [ { itemId, name, downloadUrl, lastModified } ] }
async function odLoadKpiSharedFolderViaRemoteItem() {
    console.log("=== SharedWithMe: b·∫Øt ƒë·∫ßu load T·∫§T C·∫¢ shared folders ===");

    const data  = await graphGetAll("/me/drive/sharedWithMe?$top=999");
    const items = (data && data.value) || [];
    console.log("/me/drive/sharedWithMe items =", items.length);

    const resultMap = {};  // { rootFolderName: [files...] }
    const enc = encodeURIComponent;
    const isExcel = (name) => /\.(xlsx|xls)$/i.test(name || "");

    // ƒê·ªá quy duy·ªát 1 shared folder (c√≥ th·ªÉ n·∫±m tr√™n drive kh√°c)
    async function traverseSharedFolder(driveId, folderId, rootLabel, pathParts) {
        const currentPath = pathParts.join("/") || "(g·ªëc)";
        const childrenData = await graphGetAll(`/drives/${enc(driveId)}/items/${enc(folderId)}/children?$top=999`);
        const children = (childrenData && childrenData.value) || [];

        console.log(
            `Traverse shared "${rootLabel}" path = ${currentPath}, children =`,
            children.length
        );

        for (const c of children) {
            if (c.folder) {
                const nextParts = pathParts.concat(c.name || "");
                await traverseSharedFolder(driveId, c.id, rootLabel, nextParts);
                } else if (isExcel(c.name)) {
                    // üîπ N·∫øu file n·∫±m trong NA08/NA09/... th√¨ d√πng t√™n th∆∞ m·ª•c c·∫•p 1 l√†m key
                    //    VD: KPI Scheduler/NA08/...  -> folderKey = "NA08"
                    // üîπ N·∫øu file n·∫±m tr·ª±c ti·∫øp trong KPI Scheduler (kh√¥ng c√≥ NAxx)
                    //    th√¨ d√πng rootLabel = "KPI Scheduler"
                    let folderKey;
                    if (pathParts.length > 0) {
                        folderKey = pathParts[0];       // 'NA08', 'NA09', 'NA10', 'NA11', 'NA12', ...
                    } else {
                        folderKey = rootLabel;          // file n·∫±m ngay d∆∞·ªõi "KPI Scheduler"
                    }

                    if (!resultMap[folderKey]) {
                        resultMap[folderKey] = [];
                    }

                    const item = {
                        itemId:       c.id,
                        name:         c.name,
                        downloadUrl:  c["@microsoft.graph.downloadUrl"] || null,
                        lastModified: c.lastModifiedDateTime || ""
                    };
                    resultMap[folderKey].push(item);

                    console.log(
                        "  + Excel (shared): folderKey =",
                        folderKey,
                        "| name =",
                        c.name
                    );
                }

        }
    }

    // L·∫∑p qua to√†n b·ªô SharedWithMe, ch·ªçn nh·ªØng c√°i l√† th∆∞ m·ª•c
    for (let idx = 0; idx < items.length; idx++) {
        const it     = items[idx];
        const remote = it.remoteItem;

        if (!remote || !remote.folder) {
            console.log(
                `[SharedWithMe] #${idx}: SKIP (kh√¥ng ph·∫£i th∆∞ m·ª•c)`,
                it.name || remote && remote.name
            );
            continue;
        }

        const driveId = remote.parentReference
            ? remote.parentReference.driveId
            : null;
        const itemId  = remote.id;
        const name    = remote.name || it.name || `SharedFolder_${idx}`;

        console.log(
            `[SharedWithMe] #${idx}: FOLDER name="${name}", driveId=${driveId}, itemId=${itemId}`
        );

        if (!driveId || !itemId) {
            console.warn("  -> B·ªè qua, thi·∫øu driveId ho·∫∑c itemId:", remote);
            continue;
        }

        // Duy·ªát to√†n b·ªô c√¢y con c·ªßa folder n√†y
        await traverseSharedFolder(driveId, itemId, name, []);
    }

    console.log("K·∫øt qu·∫£ SharedWithMe resultMap (folder -> file[]):");
    Object.entries(resultMap).forEach(([folder, files]) => {
        console.log(
            `  - [SHARED] Folder "${folder}": ${files.length} file`,
            files.map((f) => f.name)
        );
    });

    console.log("=== K·∫øt th√∫c load SharedWithMe ===");
    return resultMap;
}



async function odLoadKpiGroupsFromOneDrive() {
    const loading      = document.getElementById("loading");
    const folderSelect = document.getElementById("odFolderSelect");
    const groupSelect  = document.getElementById("odGroupSelect");

    if (loading) {
        loading.textContent = "‚è≥ ƒêang t·∫£i danh s√°ch file t·ª´ OneDrive...";
        loading.classList.add("show");
    }

    // reset map
    oneDriveFolderFileMap     = {};
    oneDriveGroupMap          = {};
    oneDriveCurrentFolderName = "";

    try {
        const rawPath = graphKpiConfig.kpiFolderPath || "/";
        const folderName = (rawPath.split("/").filter(Boolean).pop() || "").trim();
        const folderNameLower = folderName.toLowerCase();

        console.log("=== OneDrive KPI: B·∫ÆT ƒê·∫¶U load danh s√°ch file ===");
        console.log("kpiFolderPath =", rawPath, "| folderName =", folderName || "(r·ªóng)");

        const isExcel = (name) => /\.(xlsx|xls)$/i.test(name || "");
        const enc     = encodeURIComponent;

        // 1Ô∏è‚É£ Helper: ƒë·ªçc Excel t·ª´ 1 th∆∞ m·ª•c g·ªëc (ƒë√£ bi·∫øt driveId + itemId)
        async function collectExcelFromKpiRoot(driveId, rootItemId, rootLabel) {
            const data  = await graphGetAll("/me/drive/sharedWithMe?$top=999");
            const items = (data && data.value) || [];
            console.log(`KPI root "${rootLabel}" children =`, items.length);

            const rootFiles  = [];
            const subFolders = [];

            items.forEach((it, idx) => {
                const isFolder = !!it.folder;
                const name     = it.name || "(no-name)";

                if (isFolder) {
                    console.log(`[KPI root] FOLDER #${idx}:`, name, "| id =", it.id);
                    subFolders.push({ id: it.id, name });
                } else if (isExcel(it.name)) {
                    console.log(`[KPI root] EXCEL  #${idx}:`, name, "| id =", it.id);
                    rootFiles.push({
                        itemId:       it.id,
                        name,
                        downloadUrl:  it["@microsoft.graph.downloadUrl"],
                        lastModified: it.lastModifiedDateTime || ""
                    });
                } else {
                    console.log(`[KPI root] SKIP   #${idx}:`, name);
                }
            });

            if (rootFiles.length) {
                oneDriveFolderFileMap["(ROOT)"] = rootFiles;
            }

            // Duy·ªát t·ª´ng subfolder ƒë·ªÉ l·∫•y file Excel b√™n trong
            for (const f of subFolders) {
                try {
                    const childData  = await graphGetJson(
                        `/drives/${enc(driveId)}/items/${enc(f.id)}/children`
                    );
                    const childItems = (childData && childData.value) || [];
                    console.log(
                        `Subfolder "${f.name}" children =`,
                        childItems.length
                    );

                    const excelInFolder = childItems
                        .filter((it) => !it.folder && isExcel(it.name))
                        .map((it) => ({
                            itemId:       it.id,
                            name:         it.name,
                            downloadUrl:  it["@microsoft.graph.downloadUrl"],
                            lastModified: it.lastModifiedDateTime || ""
                        }));

                    console.log(
                        `  -> Excel trong "${f.name}" =`,
                        excelInFolder.length,
                        excelInFolder.map((x) => x.name)
                    );

                    if (excelInFolder.length) {
                        oneDriveFolderFileMap[f.name] = excelInFolder;
                    }
                } catch (e) {
                    console.warn("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c children c·ªßa subfolder", f.name, e);
                }
            }
        }

        // 2Ô∏è‚É£ T√¨m KPI folder trong /root (folder th·∫≠t ho·∫∑c shortcut)
        async function resolveFromRootOrShortcut() {
            try {
                const data  = await graphGetJson("/me/drive/root/children");
                const items = (data && data.value) || [];
                console.log("/me/drive/root/children items =", items.length);

                let kpiRoot = null;

                items.forEach((it, idx) => {
                    const isFolder  = !!it.folder;
                    const hasRemote = !!it.remoteItem;
                    const name      = it.name || "";
                    const nameLower = name.toLowerCase();

                    console.log(
                        `[ROOT] #${idx}: name="${name}", isFolder=${isFolder}, hasRemoteItem=${hasRemote}`
                    );

                    if (!folderName) return; // kh√¥ng config t√™n folder -> b·ªè qua b∆∞·ªõc n√†y

                    if (!kpiRoot && nameLower === folderNameLower) {
                        // 2a. Shortcut: c√≥ remoteItem.folder
                        if (it.remoteItem && it.remoteItem.folder) {
                            const remote  = it.remoteItem;
                            const driveId = remote.parentReference
                                ? remote.parentReference.driveId
                                : null;
                            const itemId  = remote.id;

                            kpiRoot = {
                                driveId,
                                itemId,
                                source: "shortcut (remoteItem)",
                                displayName: name
                            };
                        }
                        // 2b. Folder th·∫≠t trong root
                        else if (isFolder) {
                            const driveId = it.parentReference
                                ? it.parentReference.driveId
                                : null;
                            const itemId  = it.id;

                            kpiRoot = {
                                driveId,
                                itemId,
                                source: "root folder",
                                displayName: name
                            };
                        }
                    }
                });

                if (!kpiRoot) {
                    console.warn("Kh√¥ng t√¨m th·∫•y KPI folder theo t√™n trong /root.");
                    return false;
                }
                if (!kpiRoot.driveId || !kpiRoot.itemId) {
                    console.warn("KPI folder kh√¥ng c√≥ driveId/itemId ƒë·∫ßy ƒë·ªß:", kpiRoot);
                    return false;
                }

                console.log(
                    "‚úî D√πng KPI folder t·ª´",
                    kpiRoot.source,
                    "| name =", kpiRoot.displayName,
                    "| driveId =", kpiRoot.driveId,
                    "| itemId =", kpiRoot.itemId
                );

                await collectExcelFromKpiRoot(
                    kpiRoot.driveId,
                    kpiRoot.itemId,
                    kpiRoot.displayName
                );
                return true;
            } catch (e) {
                console.error("L·ªói ƒë·ªçc /me/drive/root/children:", e);
                return false;
            }
        }

        let ok = false;

        // B∆∞·ªõc 1: /root (folder + shortcut)
        if (folderName) {
            ok = await resolveFromRootOrShortcut();
        }

        // B∆∞·ªõc 2: n·∫øu v·∫´n kh√¥ng ok ‚Üí SharedWithMe
        if (!ok) {
            console.log("Fallback sang SharedWithMe...");
            const sharedMap = await odLoadKpiSharedFolderViaRemoteItem();
            const sharedFolders = Object.keys(sharedMap || {});
            console.log("Shared folder map keys:", sharedFolders);

            sharedFolders.forEach((folderName) => {
                const list = sharedMap[folderName] || [];
                if (!list.length) return;

                if (!oneDriveFolderFileMap[folderName]) {
                    oneDriveFolderFileMap[folderName] = [];
                }
                oneDriveFolderFileMap[folderName] =
                    oneDriveFolderFileMap[folderName].concat(list);

                console.log(
                    `  + Merge SHARED folder "${folderName}", t·ªïng file =`,
                    oneDriveFolderFileMap[folderName].length
                );
            });
        }

        console.log(
            "oneDriveFolderFileMap (sau root/shortcut + shared):",
            Object.keys(oneDriveFolderFileMap)
        );
        Object.entries(oneDriveFolderFileMap).forEach(([folder, files]) => {
            console.log(
                `  - Folder "${folder}": ${files.length} file`,
                files.map((f) => f.name)
            );
        });

        const allFolders = Object.keys(oneDriveFolderFileMap);

        if (!allFolders.length) {
            if (groupSelect) groupSelect.innerHTML = "";
            alert(
                "Kh√¥ng t√¨m th·∫•y file Excel n√†o trong th∆∞ m·ª•c KPI.\n" +
                "Ki·ªÉm tra l·∫°i ƒë∆∞·ªùng d·∫´n ho·∫∑c quy·ªÅn share."
            );
            return;
        }

        // ƒê·ªï d·ªØ li·ªáu v√†o combobox "Th∆∞ m·ª•c" v√† "Nh√≥m file"
        odPopulateFolderSelectOptions();
    } catch (err) {
        console.error("L·ªói t·∫£i danh s√°ch file KPI t·ª´ OneDrive:", err);
        alert("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c danh s√°ch file t·ª´ OneDrive.\n" + err.message);
    } finally {
        if (loading) {
            loading.textContent = "‚è≥ ƒêang x·ª≠ l√Ω file...";
            loading.classList.remove("show");
        }
        console.log("=== OneDrive KPI: K·∫æT TH√öC odLoadKpiGroupsFromOneDrive ===");
    }
}

// T·∫£i c√°c file trong nh√≥m ƒë√£ ch·ªçn t·ª´ OneDrive ‚Üí chuy·ªÉn th√†nh File[] ‚Üí processMultipleFiles
async function odLoadSelectedGroupFromOneDrive() {
    const groupSelect = document.getElementById("odGroupSelect");
    if (!groupSelect) {
        alert("Kh√¥ng t√¨m th·∫•y combobox Nh√≥m file OneDrive.");
        return;
    }

    const gName = groupSelect.value;
    const list = oneDriveGroupMap[gName] || [];
    if (!list.length) {
        alert("Nh√≥m file OneDrive ƒëang ch·ªçn kh√¥ng c√≥ file.");
        return;
    }

    const loading = document.getElementById("loading");
    if (loading) {
        loading.textContent = "‚è≥ ƒêang t·∫£i file nh√≥m '" + gName + "' t·ª´ OneDrive...";
        loading.classList.add("show");
    }

    try {
        // C√≥ th·ªÉ sort theo lastModified (m·ªõi nh·∫•t tr∆∞·ªõc)
        const sorted = [...list].sort((a, b) =>
            (b.lastModified || "").localeCompare(a.lastModified || "")
        );

        const fileObjs = [];

        for (const item of sorted) {
            let downloadUrl = item.downloadUrl;

            // üîÅ Fallback: n·∫øu ch∆∞a c√≥ downloadUrl (th∆∞·ªùng g·∫∑p v·ªõi SharedWithMe)
            if (!downloadUrl && item.itemId) {
                try {
                    const detail = await graphGetJson(
                        `/me/drive/items/${encodeURIComponent(item.itemId)}`
                    );
                    downloadUrl = detail["@microsoft.graph.downloadUrl"];
                } catch (e) {
                    console.warn("Kh√¥ng l·∫•y ƒë∆∞·ª£c downloadUrl cho", item.name, e);
                }
            }

            if (!downloadUrl) {
                console.warn("B·ªè qua file v√¨ kh√¥ng c√≥ downloadUrl:", item.name);
                continue;
            }

            const res = await fetch(downloadUrl);
            if (!res.ok) {
                console.warn("Kh√¥ng t·∫£i ƒë∆∞·ª£c file:", item.name, res.status);
                continue;
            }

            const blob = await res.blob();
            const file = new File([blob], item.name, {
                type:
                    blob.type ||
                    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            });
            fileObjs.push(file);
        }

        if (!fileObjs.length) {
            alert("Kh√¥ng t·∫£i ƒë∆∞·ª£c file n√†o trong nh√≥m n√†y.");
            return;
        }

        // D√πng l·∫°i logic g·ªôp nhi·ªÅu file ƒëang c√≥
        processMultipleFiles(fileObjs);
    } catch (err) {
        console.error("L·ªói t·∫£i file t·ª´ OneDrive:", err);
        alert("L·ªói khi t·∫£i file nh√≥m t·ª´ OneDrive.\n" + err.message);
    } finally {
        if (loading) {
            loading.textContent = "‚è≥ ƒêang x·ª≠ l√Ω file...";
            loading.classList.remove("show");
        }
    }
}

// G·∫Øn event cho combobox local + kh·ªüi t·∫°o OneDrive
window.addEventListener("DOMContentLoaded", () => {
    // üîí M·∫∑c ƒë·ªãnh kh√≥a 2 n√∫t Excel local
    setLocalExcelInputsEnabled(false);

    // --- Folder/Group LOCAL (ch·ªçn th∆∞ m·ª•c tr√™n m√°y) ---
    const folderSelect = document.getElementById("folderSelect");
    const loadBtn = document.getElementById("loadGroupBtn");

    if (folderSelect) {
        folderSelect.addEventListener("change", () => {
            buildGroupMapForCurrentFolder(folderSelect.value);
        });
    }

    if (loadBtn) {
        loadBtn.addEventListener("click", () => {
            loadSelectedGroupFiles();
        });
    }

    // --- OneDrive: Folder + Group (gi·ªëng local) ---
    const odFolderSelect = document.getElementById("odFolderSelect");
    if (odFolderSelect) {
        odFolderSelect.addEventListener("change", () => {
            odBuildGroupMapForCurrentFolder(odFolderSelect.value);
        });
    }

    // --- OneDrive (Graph API) ---
    initOneDriveGraphUI();
});




        // ‚úÖ H√†m x·ª≠ l√Ω khi ch·ªçn "üìÇ Ch·ªçn th∆∞ m·ª•c Excel"
        function handleFileFromFolder(e) {
            const files = Array.from(e.target.files || []).filter((f) =>
                /\.(xlsx|xls)$/i.test(f.name)
            );
            if (!files.length) {
                alert("Th∆∞ m·ª•c kh√¥ng c√≥ file Excel (.xlsx, .xls)");
                return;
            }

            // Build map folder -> danh s√°ch file
            folderFileMap = {};
            files.forEach((file) => {
                const folderName = getFolderNameFromFile(file);
                if (!folderFileMap[folderName]) folderFileMap[folderName] = [];
                folderFileMap[folderName].push(file);
            });

            // C·∫≠p nh·∫≠t UI combobox
            populateFolderSelectOptions();

            // M·∫∑c ƒë·ªãnh: c≈©ng c√≥ th·ªÉ auto load nh√≥m ƒë·∫ßu ti√™n lu√¥n n·∫øu anh mu·ªën
            // loadSelectedGroupFiles();
        }


        function handleFile(e) {
            const files = Array.from(e.target.files || []).filter(f =>
                /\.(xlsx|xls)$/i.test(f.name)
            );

            if (!files.length) {
                alert("Kh√¥ng t√¨m th·∫•y file Excel (.xlsx, .xls) trong th∆∞ m·ª•c ƒë√£ ch·ªçn!");
                return;
            }

            if (files.length === 1) {
                processFile(files[0]);
                return;
            }

            processMultipleFiles(files);
        }

// G·ªòP NHI·ªÄU FILE EXCEL
function processMultipleFiles(files) {
    if (!files || !files.length) return;

    // üîÅ Reset state gi·ªëng processFile ƒë·ªÉ kh√¥ng d√≠nh d·ªØ li·ªáu c≈©
    mergedDataPerSheet = {};
    currentData = null;
    wsFilterValues = null;
    selectedKpiColumns = new Set();
    isHeavyKpiFile = false;   // reset c·ªù file n·∫∑ng khi ch·ªçn b·ªô file m·ªõi
    // Xo√° chart c≈© n·∫øu c√≤n
    Object.values(chartInstances).forEach(ch => ch.destroy());
    chartInstances = {};
    const chartsContainer = document.getElementById("chartsContainer");
    if (chartsContainer) chartsContainer.innerHTML = "";

    const loading = document.getElementById("loading");
    const fileInfo = document.getElementById("fileInfo");

    loading.classList.add("show");
    fileInfo.innerHTML = "";
    fileInfo.classList.remove("show");

    let totalRows = 0;
    let pending = files.length;

    files.forEach((file, index) => {
        const reader = new FileReader();

        reader.onload = function (e) {
            try {
                const data = new Uint8Array(e.target.result);
                const wb = XLSX.read(data, { type: "array", cellStyles: true });

                // File ƒë·∫ßu ti√™n d√πng l√†m "workbook ch√≠nh"
                if (index === 0) {
                    workbook = wb;
                    buildGlobalKpiMetaMap();
                    loadProvinceAreaFromThresholdWorkbook(workbook);
                }

                wb.SheetNames.forEach((sheetName) => {
                    const lower = sheetName.toLowerCase();
                    if (lower.includes("report execution for")) return;
                    if (lower.includes("documentation for")) return;

                    const sheet = wb.Sheets[sheetName];
                    if (!sheet) return;

                    const jsonData = XLSX.utils.sheet_to_json(sheet, { defval: null });
                    if (!mergedDataPerSheet[sheetName]) {
                        mergedDataPerSheet[sheetName] = [];
                    }

                    jsonData.forEach((row) => {
                        // n·∫øu c·∫ßn bi·∫øt file g·ªëc th√¨ c√≥ th·ªÉ th√™m row.__file = file.name;
                        mergedDataPerSheet[sheetName].push(row);
                    });

                    totalRows += jsonData.length;
                });

                pending--;
                if (pending === 0) {
                    loading.classList.remove("show");

                    fileInfo.innerHTML = `
                        <strong>‚úÖ ƒê√£ t·∫£i ${files.length} file.</strong><br>
                        <strong>S·ªë sheets (theo file ƒë·∫ßu ti√™n):</strong> ${workbook.SheetNames.length}<br>
                        <strong>T·ªïng s·ªë d√≤ng (t·∫•t c·∫£ file):</strong> ${totalRows}
                    `;
                    fileInfo.classList.add("show");

                    // Sau khi g·ªôp xong ‚Üí build l·∫°i dropdown sheet + chart + worst cell
                    populateSheetSelect();
                    updateCharts();
                    renderWorstCellTable();

                    
                    // ‚úÖ ƒê·∫£m b·∫£o ƒë√£ load KPI Threshhold tr∆∞·ªõc khi v·∫Ω CQI
                    if (typeof ensureKpiThresholdsLoaded === "function") {
                        ensureKpiThresholdsLoaded().then(() => {
                            if (typeof renderCqiTable === "function") {
                                renderCqiTable();
                            }
                        });
                    } else if (typeof renderCqiTable === "function") {
                        renderCqiTable();
                    }

                    const chartsSection = document.getElementById("chartsSection");
                    if (chartsSection) chartsSection.classList.add("show");
                }
            } catch (error) {
                console.error("L·ªói ƒë·ªçc file Excel:", error);
                pending--;
                if (pending === 0) {
                    loading.classList.remove("show");
                    fileInfo.innerHTML =
                        `<span style="color:red;">‚ùå L·ªói khi ƒë·ªçc m·ªôt ho·∫∑c nhi·ªÅu file Excel.</span>`;
                    fileInfo.classList.add("show");
                }
            }
        };

        reader.readAsArrayBuffer(file);
    });
}

        function processFile(file) {
            mergedDataPerSheet = null;      // r·∫•t quan tr·ªçng: b·ªè d·ªØ li·ªáu g·ªôp c≈©
            currentData = null;
            wsFilterValues = null;
            selectedKpiColumns = new Set();
            isHeavyKpiFile = false;        // reset c·ªù file n·∫∑ng khi ch·ªçn file l·∫ª

            // xo√° chart c≈© n·∫øu c√≤n
            Object.values(chartInstances).forEach(ch => ch.destroy());
            chartInstances = {};
            const chartsContainer = document.getElementById("chartsContainer");
            if (chartsContainer) chartsContainer.innerHTML = "";

            const loading = document.getElementById("loading");
            const fileInfo = document.getElementById("fileInfo");

            loading.classList.add("show");
            fileInfo.innerHTML = "";
            fileInfo.classList.remove("show");

            const reader = new FileReader();

            reader.onload = function (e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    workbook = XLSX.read(data, { type: "array", cellStyles: true });

                    buildGlobalKpiMetaMap();
                    loadProvinceAreaFromThresholdWorkbook(workbook);

                    loading.classList.remove("show");
                    fileInfo.innerHTML = `
                        <strong>‚úÖ File ƒë√£ ƒë∆∞·ª£c t·∫£i:</strong> ${file.name}<br>
                        <strong>S·ªë sheets:</strong> ${
                            workbook.SheetNames.length
                        }<br>
                        <strong>K√≠ch th∆∞·ªõc:</strong> ${(
                            file.size / 1024
                        ).toFixed(2)} KB
                    `;
                    fileInfo.classList.add("show");

                    populateSheetSelect();
                    updateCharts();
                    renderWorstCellTable();


                    // ‚úÖ ƒê·∫£m b·∫£o ƒë√£ load KPI Threshhold (Province Area, CQI Threshold)
                    if (typeof ensureKpiThresholdsLoaded === "function") {
                        ensureKpiThresholdsLoaded().then(() => {
                            if (typeof renderCqiTable === "function") {
                                renderCqiTable();
                            }
                        });
                    } else if (typeof renderCqiTable === "function") {
                        // fallback n·∫øu v√¨ l√Ω do g√¨ ƒë√≥ kh√¥ng c√≥ ensureKpiThresholdsLoaded
                        renderCqiTable();
                    }

                    document
                        .getElementById("chartsSection")
                        .classList.add("show");
                } catch (error) {
                    loading.classList.remove("show");
                    alert("‚ùå L·ªói khi ƒë·ªçc file: " + error.message);
                }
                renderWorstCellTable();
            };

            reader.readAsArrayBuffer(file);
        }

        function populateSheetSelect() {
            const select = document.getElementById("sheetSelect");
            select.innerHTML = "";

            const filtered = workbook.SheetNames.filter((name) => {
                const lower = name.toLowerCase();
                if (lower.includes("report execution for")) return false;
                if (lower.includes("documentation for")) return false;
                return true;
            });

            const sheetList = filtered.length > 0 ? filtered : workbook.SheetNames;

            sheetList.forEach((name) => {
                const option = document.createElement("option");
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            });
        }

        function buildGlobalKpiMetaMap() {
            kpiMetaMap = {};
            kpiMetaList = [];

            if (!workbook) return;

            workbook.SheetNames.forEach((sheetName) => {
                if (!sheetName.toLowerCase().includes("documentation for")) return;

                const sheet = workbook.Sheets[sheetName];
                if (!sheet) return;

                const rows = XLSX.utils.sheet_to_json(sheet, {
                    header: 1,
                    defval: "",
                });
                if (!rows.length) return;

                let headerRowIndex = -1;
                for (let i = 0; i < rows.length; i++) {
                    const r0 = String(rows[i][0] || "").toLowerCase();
                    const r1 = String(rows[i][1] || "").toLowerCase();
                    if (r0.includes("kpi id") && r1.includes("kpi alias")) {
                        headerRowIndex = i;
                        break;
                    }
                }
                if (headerRowIndex === -1) return;

                for (let i = headerRowIndex + 1; i < rows.length; i++) {
                    const row = rows[i];
                    const id = String(row[0] || "").trim();
                    const alias = String(row[1] || "").trim();
                    const unit = String(row[4] || "").trim();
                    const category = "";

                    if (!id && !alias) continue;

                    const meta = { id, name: alias || id, unit, category };
                    kpiMetaList.push(meta);
                    if (alias) kpiMetaMap[alias] = meta;
                    if (id) kpiMetaMap[id] = meta;
                }
            });

            console.log("Loaded KPI meta count =", kpiMetaList.length);
        }

        function getKpiScaleForColumn(kpiCol) {
            const meta = findKpiMetaForColumn(kpiCol);
            if (!meta || !meta.unit) return 1;

            const unitNorm = String(meta.unit).trim().toLowerCase();
            if (unitNorm === "[mb]") {
                return 1 / 1024;
            }
            return 1;
        }

        function getKpiTitleWithUnit(kpiCol) {
            const meta = findKpiMetaForColumn(kpiCol) || {};
            const unitLabel = getDisplayUnit(meta);
            if (unitLabel) {
                return `${kpiCol} (${unitLabel})`;
            }
            return kpiCol;
        }

        function getDisplayUnit(meta) {
            if (!meta || !meta.unit) return '';
            const unitNorm = String(meta.unit).trim().toLowerCase();
            return unitNorm === "[mb]" ? "[GB]" : meta.unit;
        }

        function findKpiMetaForColumn(kpiCol) {
            if (!kpiCol) return null;
            const key = String(kpiCol).trim();

            if (kpiMetaMap[key]) return kpiMetaMap[key];

            if (!kpiMetaList || !kpiMetaList.length) return null;

            const lower = key.toLowerCase();
            let best = null;

            kpiMetaList.forEach((meta) => {
                ["name", "id"].forEach((field) => {
                    const v = meta[field];
                    if (!v) return;
                    const vLower = String(v).toLowerCase();

                    if (
                        vLower === lower ||
                        vLower.includes(lower) ||
                        lower.includes(vLower)
                    ) {
                        if (!best) best = meta;
                    }
                });
            });

            return best;
        }

        // ====== ƒê·ªåC FILE "KPI Threshhold.xlsx" ======
        async function ensureKpiThresholdsLoaded() {
            // N·∫øu ƒë√£ load KPI threshold + provinceAreaMap r·ªìi th√¨ th√¥i
            if (
                kpiThresholdMap !== null &&
                provinceAreaMap &&
                Object.keys(provinceAreaMap).length
            ) {
                return kpiThresholdMap;
            }

            kpiThresholdMap = {}; // tr√°nh null ƒë·ªÉ kh√¥ng g·ªçi l·∫°i nhi·ªÅu l·∫ßn

            try {
                // File KPI Threshhold.xlsx ƒë·ªÉ c√πng th∆∞ m·ª•c v·ªõi index.html
                const resp = await fetch("KPI Threshhold.xlsx");
                if (!resp.ok) throw new Error("HTTP " + resp.status);

                const buf = await resp.arrayBuffer();
                const wb = XLSX.read(buf, { type: "array" });

                // 1) Province -> Area (sheet "Province Area")
                //    => d√πng ri√™ng file KPI Threshhold ƒë·ªÉ nu√¥i provinceAreaMap
                loadProvinceAreaFromThresholdWorkbook(wb);

                // 2) MAP ID -> Config/Threshold cho CQI (sheet "CQI Threshold")
                cqiConfigMap = {};
                const cqiSheet = wb.Sheets["CQI Threshold"];
                if (cqiSheet) {
                    const cqiRows = XLSX.utils.sheet_to_json(cqiSheet, { defval: "" });

                    cqiRows.forEach((r) => {
                        // ID c√≥ th·ªÉ d·∫°ng "M41;M42;M43" ‚Üí t√°ch t·ª´ng m√£ ri√™ng
                        const idRaw = String(r["ID"] || r["Id"] || "")
                            .trim()
                            .toUpperCase();
                        if (!idRaw) return;

                        const config = String(r["Config ATP"] || r["Config"] || "").trim();
                        const thrVal = r["Threshold"];   // gi·ªØ nguy√™n text, v√≠ d·ª• "<8"

                        const idList = idRaw
                            .split(";")
                            .map((s) => s.trim())
                            .filter(Boolean);

                        idList.forEach((id) => {
                            cqiConfigMap[id] = {
                                config,
                                target: thrVal, // hi·ªÉn th·ªã ƒë√∫ng nh∆∞ file KPI Threshhold
                            };
                        });
                    });
                }


                // 3) Map KPI Threshold cho to√†n b·ªô KPI (sheet "KPI Threshold")
                const sheet =
                    wb.Sheets["KPI Threshold"] || wb.Sheets[wb.SheetNames[0]];

                if (!sheet) return kpiThresholdMap;

                const rows = XLSX.utils.sheet_to_json(sheet, { defval: "" });

                rows.forEach((r) => {
                    const id   = String(r["KPI ID"]   || "").trim();
                    const name = String(r["KPI Name"] || "").trim();
                    const op   = String(r["operator"] || "").trim();   // <, >, =
                    const thr  = parseFloat(r["Threshold"]);

                    if (!op || isNaN(thr)) return;

                    const entry = { op, value: thr };

                    // map theo KPI ID, KPI Name
                    if (id)   kpiThresholdMap[id]   = entry;
                    if (name) kpiThresholdMap[name] = entry;
                });

                console.log(
                    "Loaded KPI threshold count =",
                    Object.keys(kpiThresholdMap).length
                );
            } catch (e) {
                console.warn("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c KPI Threshhold.xlsx:", e);
                kpiThresholdMap = {}; // ƒë·ªÉ kh·ªèi th·ª≠ l·∫°i nhi·ªÅu l·∫ßn
            }

            return kpiThresholdMap;
        }



        function getThresholdForKpiColumn(kpiCol) {
            if (!kpiCol) return null;

            const meta = findKpiMetaForColumn(kpiCol) || {};
            const keysToTry = [];

            if (meta.id)   keysToTry.push(String(meta.id).trim());
            if (meta.name) keysToTry.push(String(meta.name).trim());
            keysToTry.push(String(kpiCol).trim());

            // 1. ∆Øu ti√™n custom threshold (k·ªÉ c·∫£ tr∆∞·ªùng h·ª£p T·∫ÆT NG∆Ø·ª†NG)
            for (const key of keysToTry) {
                if (Object.prototype.hasOwnProperty.call(customThresholdMap, key)) {
                    const entry = customThresholdMap[key];

                    // entry = null ho·∫∑c entry.disabled => t·∫Øt ho√†n to√†n ng∆∞·ª°ng cho KPI n√†y
                    if (!entry || entry.disabled) return null;

                    return entry; // { op, value }
                }
            }

            // 2. N·∫øu kh√¥ng c√≥ custom ‚Üí d√πng file KPI Threshold (load 1 l·∫ßn)
            if (kpiThresholdMap) {
                for (const key of keysToTry) {
                    if (kpiThresholdMap[key]) {
                        return kpiThresholdMap[key];
                    }
                }
            }

            return null;
        }


        function setCustomThresholdForKpiColumn(kpiCol, op, value) {
            if (!kpiCol) return;

            const key = String(kpiCol).trim();

            // Tr∆∞·ªùng h·ª£p T·∫ÆT NG∆Ø·ª†NG (op = "")
            if (!op) {
                customThresholdMap[key] = { disabled: true };

                try {
                    localStorage.setItem(
                        "customThresholdMap",
                        JSON.stringify(customThresholdMap)
                    );
                } catch (e) {
                    console.warn("Cannot save customThresholdMap", e);
                }

                // Kh√¥ng ghi ƒë√® v√†o kpiThresholdMap ƒë·ªÉ gi·ªØ nguy√™n default trong file,
                // nh∆∞ng do getThresholdForKpiColumn ∆∞u ti√™n custom n√™n KPI n√†y s·∫Ω KH√îNG d√πng ng∆∞·ª°ng n·ªØa.
                return;
            }

            // C√°c tr∆∞·ªùng h·ª£p c√≤n l·∫°i: ph·∫£i c√≥ value s·ªë
            if (value == null || isNaN(value)) return;

            const entry = { op, value: Number(value) };

            // L∆∞u v√†o custom map
            customThresholdMap[key] = entry;

            // L∆∞u vƒ©nh vi·ªÖn v√†o localStorage
            try {
                localStorage.setItem(
                    "customThresholdMap",
                    JSON.stringify(customThresholdMap)
                );
            } catch (e) {
                console.warn("Cannot save customThresholdMap", e);
            }

            // Ghi ƒë√® tr√™n map t·ªïng h·ª£p ƒë·ªÉ b·∫£ng/chart d√πng ngay
            if (!kpiThresholdMap) kpiThresholdMap = {};
            kpiThresholdMap[key] = entry;

            console.log("Saved custom threshold:", kpiCol, entry);
        }


        // ====== ƒê·ªåC SHEET "WorstCell Threshold" CHO WORST CELL & NON-TRAFFIC ======
        async function ensureWorstCellThresholdsLoaded() {
            // ƒê√£ load r·ªìi th√¨ th√¥i
            if (worstCellThresholdMap !== null) return worstCellThresholdMap;

            worstCellThresholdMap = {}; // tr√°nh null ƒë·ªÉ kh√¥ng g·ªçi l·∫°i nhi·ªÅu l·∫ßn

            try {
                const resp = await fetch("KPI Threshhold.xlsx");
                if (!resp.ok) throw new Error("HTTP " + resp.status);

                const buf = await resp.arrayBuffer();
                const wb  = XLSX.read(buf, { type: "array" });

                const sheet = wb.Sheets["WorstCell Threshold"];
                if (!sheet) {
                    console.warn('Kh√¥ng t√¨m th·∫•y sheet "WorstCell Threshold" trong KPI Threshhold.xlsx');
                    return worstCellThresholdMap;
                }

                const rows = XLSX.utils.sheet_to_json(sheet, { defval: "" });

                rows.forEach((r) => {
                    const name = String(r["KPI Name"] || "").trim();
                    const op   = String(r["operator"] || "").trim();   // <, >, <=, >=, =, ...
                    const thr  = parseFloat(r["Threshold"]);

                    if (!name || !op || isNaN(thr)) return;

                    worstCellThresholdMap[name] = { op, value: thr };
                });

                console.log(
                    "Loaded WorstCell threshold count =",
                    Object.keys(worstCellThresholdMap).length
                );
            } catch (e) {
                console.warn("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c sheet WorstCell Threshold:", e);
                worstCellThresholdMap = {}; // ƒë·ªÉ kh·ªèi th·ª≠ l·∫°i nhi·ªÅu l·∫ßn
            }

            return worstCellThresholdMap;
        }

        // L·∫•y threshold cho 1 KPI theo t√™n hi·ªÉn th·ªã c·ªôt (KPI Name)
        function getWorstCellThresholdByName(kpiDisplayName) {
    if (!worstCellThresholdMap || !Object.keys(worstCellThresholdMap).length) return null;
    if (!kpiDisplayName) return null;

    const key = String(kpiDisplayName).trim();
    return worstCellThresholdMap[key] || null;
}

        // üëâ KPI MAC SDU: d√πng ƒë·ªÉ set default chart = stackedArea
        function isMacSduKpi(kpiCol) {
            if (!kpiCol) return false;
            const lower = String(kpiCol).toLowerCase();
            return (
                lower.includes("mac sdu data vol trans dl dtch") ||
                lower.includes("mac sdu data vol rcvd ul dtch") ||
                lower.includes("pdcp sdu volume, dl") ||
                lower.includes("pdcp sdu volume, ul")
            );
        }

        function populateSheetSelectDirect() {
            const sheetSelect = document.getElementById("sheetSelect");

            sheetSelect.innerHTML = `
                <option value="merged" selected>üìÇ Merged Dataset (${originalRows.length} d√≤ng)</option>
            `;
        }

        function processMergedExcelData(rows) {
            originalRows = rows;
            currentData = [...rows];

            populateSheetSelectDirect();
            populateKpiSelect(currentData);
            populateDateSelect(currentData);

            updateCharts();
        }

        function updateCharts() {
            if (!workbook) return;

            const sheetSelect = document.getElementById("sheetSelect");

            // √Åp sheet ƒë√£ l∆∞u trong localStorage l·∫ßn ƒë·∫ßu sau khi c√≥ danh s√°ch sheet
            if (!chartConfigAppliedOnce && sheetSelect) {
                try {
                    const raw = localStorage.getItem("chartConfig");
                    if (raw) {
                        const cfg = JSON.parse(raw);
                        if (cfg.sheet) {
                            const hasOption = Array.from(sheetSelect.options).some(
                                (opt) => opt.value === cfg.sheet
                            );
                            if (hasOption) {
                                sheetSelect.value = cfg.sheet;
                            }
                        }
                    }
                } catch (e) {
                    console.warn("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c chartConfig:", e);
                }
                chartConfigAppliedOnce = true;
            }

            const sheetName =
                (sheetSelect && sheetSelect.value) || workbook.SheetNames[0];

            let jsonData;

            if (mergedDataPerSheet && mergedDataPerSheet[sheetName]) {
                jsonData = mergedDataPerSheet[sheetName];
            } else {
                const sheet = workbook.Sheets[sheetName];
                jsonData = XLSX.utils.sheet_to_json(sheet);
            }

            if (!jsonData || jsonData.length === 0) {
                alert("Sheet kh√¥ng c√≥ d·ªØ li·ªáu!");
                return;
            }

            currentData = jsonData;
            const columns = Object.keys(jsonData[0]);
            numericColumns = detectColumnsAndNumeric(columns);

            // ==== ƒê√ÅNH D·∫§U SHEET KPI N·∫∂NG ====
            // ƒêi·ªÅu ki·ªán file n·∫∑ng:
            // 1) S·ªë d√≤ng > ng∆∞·ª°ng
            // 2) S·ªë c·ªôt > 30
            const colCount = columns.length;

            isHeavyKpiFile =
                (Array.isArray(jsonData) && jsonData.length > HEAVY_KPI_ROW_THRESHOLD) ||
                colCount > 30;

            console.log(
                "S·ªë d√≤ng:", jsonData.length,
                "S·ªë c·ªôt:", colCount,
                "isHeavyKpiFile =", isHeavyKpiFile
            );


            // m·ªói l·∫ßn ƒë·ªïi sheet th√¨ reset l·∫°i KPI & filter
            //  - n·∫øu file n·∫∑ng -> T·∫ÆT H·∫æT KPI (set r·ªóng)
            //  - n·∫øu file b√¨nh th∆∞·ªùng -> b·∫≠t h·∫øt KPI nh∆∞ c≈©
            selectedKpiColumns = isHeavyKpiFile
                ? new Set()
                : new Set(numericColumns);

            wsFilterValues = null;


            buildWsFilterOptions(jsonData);
            buildKpiFilterOptions();
            buildExcelDateOptions();
            buildThresholdCustomUi();
            renderCharts();
            fillDefaultEmailText();
            recomputeWorstCellOverview();
            // Sau khi x·ª≠ l√Ω xong KPI, ƒë·∫£m b·∫£o ƒë√£ load KPI Threshhold (ƒë·ªÉ c√≥ Province -> Area & CQI config)
            if (kpiThresholdMap === null) {
                ensureKpiThresholdsLoaded().then(() => {
                    // N·∫øu c√≥ h√†m v·∫Ω CQI th√¨ v·∫Ω l·∫°i sau khi map ƒë√£ s·∫µn s√†ng
                    if (typeof renderCqiTable === "function") {
                        renderCqiTable();
                    }
                });
            } else {
                if (typeof renderCqiTable === "function") {
                    renderCqiTable();
                }
            }

            // l∆∞u l·∫°i c·∫•u h√¨nh (sheet, daysWindow, chartsPerRow, funnelSort)
            if (typeof saveChartConfig === "function") {
                saveChartConfig();
            }
        }


        // ==== CH·ªåN CH√çNH X√ÅC CELL_NAME (∆∞u ti√™n NRCEL / LNCEL) ====
        function getCellNameColumn() {
            if (!currentData || !currentData.length) return wsNameColumnName;

            const columns = Object.keys(currentData[0]);
            const meta = columns.map(c => ({
                name: c,
                lower: String(c).toLowerCase().trim()
            }));

            const candidates = [];

            function pushIf(testFn, weight) {
                meta.forEach(col => {
                    if (testFn(col.lower)) {
                        candidates.push({ name: col.name, weight });
                    }
                });
            }

            // 1. ∆ØU TI√äN CAO NH·∫§T: NRCEL name (ƒë√∫ng case c·ªßa b·∫°n)
            pushIf(l => l === "nrcel name" || l === "nrcell name", 110);
            pushIf(l =>
                (l.includes("nrcel") || l.includes("nrcell")) &&
                l.includes("name"),
                100
            );

            // 2. LNCEL name
            pushIf(l => l === "lncel name", 95);
            pushIf(l => l.includes("lncel") && l.includes("name"), 90);

            // 3. CELL_NAME chung chung
            pushIf(l =>
                l === "cell name" ||
                l === "cell_name" ||
                l === "cellname",
                80
            );
            pushIf(l => l.includes("cell") && l.includes("name"), 75);

            // 4. WS_NAME / site name fallback
            pushIf(l =>
                l === "ws_name" ||
                l === "wsname" ||
                l === "ws name",
                60
            );
            pushIf(l => l.includes("ws") && l.includes("name"), 55);

            // 5. NRBTS / MRBTS ch·ªâ l√† fallback th·∫•p (trong file b·∫°n c√≥ 2 c·ªôt n√†y)
            pushIf(l => l.includes("nrbts") && l.includes("name"), 40);
            pushIf(l => l.includes("mrbts") && l.includes("name"), 35);

            // N·∫øu t√¨m ƒë∆∞·ª£c ·ª©ng vi√™n th√¨ l·∫•y c√°i c√≥ weight cao nh·∫•t
            if (candidates.length) {
                candidates.sort((a, b) => b.weight - a.weight);
                return candidates[0].name;
            }

            // 6. Fallback th√¥ng minh: ch·ªçn c·ªôt text (√≠t numeric) ƒë·∫ßu ti√™n, KH√îNG ph·∫£i Period/Time/Date
            const periodSet = new Set();
            meta.forEach(col => {
                if (
                    col.lower.includes("period") ||
                    col.lower.includes("time") ||
                    col.lower.includes("date")
                ) {
                    periodSet.add(col.name);
                }
            });

            for (const colName of columns) {
                if (periodSet.has(colName)) continue;

                let numericCount = 0;
                let total = 0;

                currentData.forEach(row => {
                    const v = row[colName];
                    if (v === null || v === undefined || v === "") return;
                    total++;
                    if (!isNaN(parseFloat(v))) numericCount++;
                });

                // Ch·ªß y·∫øu l√† text ‚Üí r·∫•t c√≥ th·ªÉ l√† CELL_NAME
                if (total > 0 && numericCount / total < 0.3) {
                    return colName;
                }
            }

            // 7. Fallback cu·ªëi c√πng
            return wsNameColumnName || columns[1] || columns[0];
        }

        function detectColumnsAndNumeric(columns) {
    // 1. X√°c ƒë·ªãnh c·ªôt Period (th·ªùi gian)
    periodColumnName = null;

    columns.forEach((col) => {
        const lower = String(col).toLowerCase();
        if (
            !periodColumnName &&
            (lower.includes("period") ||
                lower.includes("time") ||
                lower.includes("date"))
        ) {
            periodColumnName = col;
        }
    });

    // Fallback n·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c
    if (!periodColumnName) {
        periodColumnName = columns[0];
    }

    // 2. X√°c ƒë·ªãnh CELL_NAME chung (∆∞u ti√™n NRCEL/LNCEL)
    wsNameColumnName = getCellNameColumn();

    // 3. C√°c c·ªôt ki·ªÉu "name" (MRBTS name, NRBTS name, NRCEL name, ‚Ä¶)
    //    => coi l√† c·ªôt dimension, KH√îNG ph·∫£i KPI
    const nameLikeCols = new Set();
    columns.forEach(col => {
        const lower = String(col).toLowerCase();
        if (lower.includes("name")) {
            nameLikeCols.add(col);
        }
    });

    // 4. H√†m check s·ªë "th·∫≠t": b·ªè %, d·∫•u ph·∫©y, kho·∫£ng tr·∫Øng,
    //    v√† y√™u c·∫ßu c·∫£ chu·ªói ch·ªâ l√† s·ªë (kh√¥ng cho ki·ªÉu "5G-..." n·ªØa)
    function isTrulyNumeric(val) {
        if (val === null || val === undefined) return false;
        let s = String(val).trim();
        if (!s) return false;

        // lo·∫°i b·ªè kho·∫£ng tr·∫Øng, d·∫•u ph·∫©y
        s = s.replace(/,/g, "").replace(/\s+/g, "");
        // b·ªè d·∫•u % cu·ªëi n·∫øu c√≥
        s = s.replace(/%$/, "");

        // n·∫øu sau khi x·ª≠ l√Ω m√† v·∫´n c√≥ ch·ªØ => kh√¥ng ph·∫£i s·ªë
        if (!/^[-+]?\d*\.?\d+(e[+-]?\d+)?$/i.test(s)) return false;

        return !isNaN(Number(s));
    }

    // 5. Detect c√°c c·ªôt KPI s·ªë: b·ªè Period, CELL_NAME v√† m·ªçi c·ªôt "*name"
    const numericCols = [];
    columns.forEach((col) => {
        if (col === periodColumnName) return;
        if (col === wsNameColumnName) return;
        if (nameLikeCols.has(col)) return; // MRBTS name, NRBTS name, NRCEL name,...

        const isNumeric = currentData.some((row) => {
            const v = row[col];
            if (v === null || v === undefined || v === "") return false;
            return isTrulyNumeric(v);
        });

        if (isNumeric) numericCols.push(col);
    });

    return numericCols;
}

        // ==== H·∫æT PH·∫¶N S·ª¨A CELL_NAME ====

        function buildKpiFilterOptions() {
            const container = document.getElementById('kpiFilterContainer');
            if (!container) return;
            if (!numericColumns || !numericColumns.length) {
                container.innerHTML = '<div style="font-size:0.85em;color:#6b7280;">Kh√¥ng t√¨m th·∫•y KPI d·∫°ng s·ªë.</div>';
                return;
            }

            const prevInput = container.querySelector('#kpiSearchInput');
            const prevKeyword = prevInput ? prevInput.value : '';

            if (!(selectedKpiColumns instanceof Set)) {
                selectedKpiColumns = new Set(numericColumns);
            }

            container.innerHTML = `
                <div class="ws-filter-toolbar">
                    <input type="text" id="kpiSearchInput" class="ws-filter-search"
                        placeholder="T√¨m KPI (vd: THR;Drop)">
                    <button type="button" data-action="kpi-select-all">Ch·ªçn t·∫•t c·∫£</button>
                    <button type="button" data-action="kpi-clear-all">B·ªè h·∫øt</button>
                </div>
                <div class="kpi-filter-list"></div>
            `;

            const listEl = container.querySelector('.kpi-filter-list');
            const searchInput = container.querySelector('#kpiSearchInput');
            if (searchInput) searchInput.value = prevKeyword || '';

            function renderList() {
                listEl.innerHTML = '';
                const searchVal = (searchInput?.value || '').trim().toLowerCase();
                const terms = searchVal
                    ? searchVal.split(';').map(t => t.trim()).filter(Boolean)
                    : [];

                numericColumns.forEach(col => {
                    const colLower = String(col).toLowerCase();
                    if (terms.length && !terms.some(term => colLower.includes(term))) {
                        return;
                    }
                    const checked = selectedKpiColumns.has(col) ? 'checked' : '';
                    listEl.innerHTML += `
                        <label class="ws-chip">
                            <input type="checkbox" class="kpi-filter-checkbox" value="${col}" ${checked}>
                            ${col}
                        </label>
                    `;
                });
            }

            renderList();

            container.onchange = (e) => {
                if (!e.target.classList.contains('kpi-filter-checkbox')) return;
                const value = e.target.value;
                if (e.target.checked) {
                    selectedKpiColumns.add(value);
                } else {
                    selectedKpiColumns.delete(value);
                }

                renderCharts();
                renderExcelStyleTable();
                renderLatestKpiTable();
                renderWorstCellTable();   // üîÅ c·∫≠p nh·∫≠t lu√¥n Worst Cell / Non-Traffic
                buildThresholdCustomUi(); // ‚¨ÖÔ∏è update l·∫°i list KPI cho ph·∫ßn T√πy ch·ªânh ng∆∞·ª°ng
            };

            container.onclick = (e) => {
                const btn = e.target.closest('button[data-action]');
                if (!btn) return;

                const action = btn.dataset.action;
                const checkboxes = listEl.querySelectorAll('.kpi-filter-checkbox');

                if (action === 'kpi-select-all') {
                    checkboxes.forEach(cb => selectedKpiColumns.add(cb.value));
                } else if (action === 'kpi-clear-all') {
                    checkboxes.forEach(cb => selectedKpiColumns.delete(cb.value));
                }

                renderList();
                renderCharts();
                renderExcelStyleTable();
                renderLatestKpiTable();
                renderWorstCellTable();   // üîÅ c·∫≠p nh·∫≠t lu√¥n Worst Cell / Non-Traffic
                buildThresholdCustomUi(); // ‚¨ÖÔ∏è ƒë·ªìng b·ªô ph·∫ßn T√πy ch·ªânh ng∆∞·ª°ng
            };

            if (searchInput) {
                searchInput.addEventListener('input', () => {
                    renderList();
                });
            }
        }
// X√¢y UI "T√πy ch·ªânh ng∆∞·ª°ng" cho c√°c KPI ƒëang ƒë∆∞·ª£c ch·ªçn
        function buildThresholdCustomUi() {
    const panel      = document.getElementById("kpiThresholdPanel");
    const kpiSelect  = document.getElementById("thresholdKpiSelect");
    const opSelect   = document.getElementById("thresholdOpSelect");
    const valueInput = document.getElementById("thresholdValueInput");
    const applyBtn   = document.getElementById("thresholdApplyBtn");
    const globalToggle = document.getElementById("thresholdGlobalToggle");

    if (!panel || !kpiSelect || !opSelect || !valueInput || !applyBtn) return;

    if (!numericColumns || !numericColumns.length || !currentData) {
        panel.style.display = "none";
        return;
    }

    // Ch·ªâ show KPI ƒëang ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ v·∫Ω / b·∫£ng (selectedKpiColumns)
    const activeKpiCols = numericColumns.filter(col => selectedKpiColumns.has(col));

    if (!activeKpiCols.length) {
        panel.style.display = "none";
        return;
    }

    panel.style.display = "block";

    // Kh·ªüi t·∫°o tr·∫°ng th√°i checkbox t·ªïng + ƒë·ªìng b·ªô state Target l·∫ßn ƒë·∫ßu
    if (globalToggle) {
        try {
            const saved = localStorage.getItem("globalThresholdEnabled");
            if (saved !== null) {
                globalThresholdEnabled = saved === "1";
            }
        } catch (e) {
            console.warn("Cannot load globalThresholdEnabled", e);
        }
        globalToggle.checked = globalThresholdEnabled;
    }

    // ƒê·ªìng b·ªô tr·∫°ng th√°i checkbox Target tr√™n t·ª´ng chart theo globalThresholdEnabled
    // (√°p d·ª•ng khi m·ªü file, d·ª±a tr√™n c√°c KPI ƒëang active)
    chartTargetVisible = {};
    if (globalThresholdEnabled) {
        activeKpiCols.forEach((col) => {
            chartTargetVisible[col] = true;
        });
    }


    // ƒê·ªï danh s√°ch KPI
    kpiSelect.innerHTML = "";
    activeKpiCols.forEach((col) => {
        const meta      = findKpiMetaForColumn(col) || {};
        const unitLabel = getDisplayUnit(meta);
        const kpiName   = meta.name || col;

        let text = kpiName;
        if (unitLabel) {
            // v√≠ d·ª•: "NSA call access ([%])"
            text += ` (${unitLabel})`;
        }

        const opt = document.createElement("option");
        opt.value = col;
        opt.textContent = text;
        kpiSelect.appendChild(opt);
    });



    // ƒê·ªìng b·ªô √¥ Operator & Threshold theo map hi·ªán t·∫°i (default t·ª´ file + custom + t·∫Øt ng∆∞·ª°ng)
    async function syncInputsFromThreshold() {
        const col = kpiSelect.value;
        if (!col) return;

        // N·∫øu ƒë√£ c√≥ override trong customThresholdMap (k·ªÉ c·∫£ disabled)
        if (Object.prototype.hasOwnProperty.call(customThresholdMap, col)) {
            const entry = customThresholdMap[col];

            // entry null/disabled => coi nh∆∞ ƒëang ch·ªçn "--" v√† Threshold r·ªóng
            if (!entry || entry.disabled) {
                opSelect.value = "";
                valueInput.value = "";
            } else {
                opSelect.value = entry.op || "";
                valueInput.value = entry.value ?? "";
            }
            return;
        }

        // Ch∆∞a c√≥ t√πy ch·ªânh ‚Üí d√πng default trong file KPI Threshhold (ch·ªâ load 1 l·∫ßn)
        if (kpiThresholdMap === null) {
            await ensureKpiThresholdsLoaded();
        }

        const thr = getThresholdForKpiColumn(col);
        opSelect.value = thr?.op || "";
        valueInput.value = thr?.value ?? "";
    }



    kpiSelect.onchange = () => {
        syncInputsFromThreshold();
    };
    // Khi ƒë·ªïi Operator sang "--" (value = ""), t·ª± xo√° √¥ Threshold
    opSelect.onchange = () => {
        if (!opSelect.value) {
            // value r·ªóng = ƒëang ch·ªçn option "--"
            valueInput.value = "";
        }
    };
    applyBtn.onclick = async () => {
        const col    = kpiSelect.value;
        const op     = (opSelect.value || "").trim();
        const valStr = valueInput.value;

        // N·∫øu ch∆∞a ch·ªçn KPI th√¨ b√°o l·ªói nh·∫π
        if (!col) {
            alert("Vui l√≤ng ch·ªçn KPI.");
            return;
        }


    // N·∫øu ch·ªçn "--" th√¨ T·∫ÆT HO√ÄN TO√ÄN NG∆Ø·ª†NG cho KPI n√†y (kh√¥ng d√πng default trong file n·ªØa)
    if (op === "") {
        // Ghi override "disabled" v√†o customThresholdMap
        customThresholdMap[col] = { disabled: true };
        try {
            localStorage.setItem(
                "customThresholdMap",
                JSON.stringify(customThresholdMap)
            );
        } catch (e) {
            console.warn("Cannot save customThresholdMap", e);
        }

        // C·∫≠p nh·∫≠t l·∫°i b·∫£ng & chart
        renderExcelStyleTable();
        if (typeof renderLatestKpiTable === "function") {
            renderLatestKpiTable();
        }
        renderCharts();
        return;
    }


        // C√°c tr∆∞·ªùng h·ª£p c√≤n l·∫°i ‚Üí y√™u c·∫ßu ph·∫£i c√≥ s·ªë
        if (!valStr) {
            alert("Vui l√≤ng nh·∫≠p Threshold.");
            return;
        }

        const num = parseFloat(valStr);
        if (isNaN(num)) {
            alert("Threshold ph·∫£i l√† s·ªë.");
            return;
        }

        if (kpiThresholdMap === null) {
            await ensureKpiThresholdsLoaded();
        }

        // Ghi ƒë√® ng∆∞·ª°ng trong map (t·∫°o/custom)
        setCustomThresholdForKpiColumn(col, op, num);

        // C·∫≠p nh·∫≠t l·∫°i b·∫£ng theo ng∆∞·ª°ng m·ªõi
        renderExcelStyleTable();
        if (typeof renderLatestKpiTable === "function") {
            renderLatestKpiTable();
        }
        renderCharts();
    };
    // ===== Checkbox t·ªïng: K√≠ch ho·∫°t t√πy ch·ªânh =====
    if (globalToggle) {
        globalToggle.onchange = () => {
            // 1) C·∫≠p nh·∫≠t bi·∫øn tr·∫°ng th√°i
            globalThresholdEnabled = globalToggle.checked;

            // 2) L∆∞u l·∫°i ƒë·ªÉ l·∫ßn sau m·ªü file v·∫´n gi·ªØ tr·∫°ng th√°i
            try {
                localStorage.setItem(
                    "globalThresholdEnabled",
                    globalThresholdEnabled ? "1" : "0"
                );
            } catch (e) {
                console.warn("Cannot save globalThresholdEnabled", e);
            }

            // 3) ƒê·ªìng b·ªô state Target cho T·∫§T C·∫¢ KPI ƒëang active
            //    - n·∫øu b·∫≠t: t·∫•t c·∫£ chart ƒë·ªÅu Target = ON
            //    - n·∫øu t·∫Øt: t·∫•t c·∫£ chart ƒë·ªÅu Target = OFF
            chartTargetVisible = {};
            if (globalThresholdEnabled) {
                activeKpiCols.forEach((col) => {
                    chartTargetVisible[col] = true;
                });
            }

            // 4) V·∫Ω l·∫°i b·∫£ng + chart cho kh·ªõp
            renderExcelStyleTable();
            if (typeof renderLatestKpiTable === "function") {
                renderLatestKpiTable();
            }
            renderCharts();
        };
    }
    // Kh·ªüi t·∫°o l·∫ßn ƒë·∫ßu theo KPI ƒë·∫ßu ti√™n
    syncInputsFromThreshold();
}

        function buildWsFilterOptions(data) {
            const wsNameCol = getCellNameColumn();   // üëâ d√πng CELL_NAME ∆∞u ti√™n LNCEL/NRCEL
            const container = document.getElementById("wsFilterContainer");
            if (!container) return;

            const set = new Set();
            data.forEach((row) => {
                const v = row[wsNameCol];
                if (v !== undefined && v !== null && v !== "") {
                    set.add(String(v));
                }
            });
            currentWsValues = Array.from(set).sort();

            if (!(wsFilterValues instanceof Set)) {
                wsFilterValues = new Set(currentWsValues);
            }

            container.innerHTML = `
                <div class="ws-filter-toolbar">
                    <input type="text" id="wsSearchInput1" class="ws-filter-search"
                        placeholder="Filter 1 (vd: PO1;PO2)">
                    <input type="text" id="wsSearchInput2" class="ws-filter-search"
                        placeholder="Filter 2 (l·ªçc ti·∫øp k·∫øt qu·∫£ 1)">
                    <input type="text" id="wsSearchInput3" class="ws-filter-search"
                        placeholder="Filter 3 (l·ªçc ti·∫øp k·∫øt qu·∫£ 2)">
                    <button type="button" data-action="select-all">Ch·ªçn t·∫•t c·∫£</button>
                    <button type="button" data-action="clear-all">B·ªè h·∫øt</button>
                </div>
                <div class="ws-filter-list"></div>
            `;

            const searchInput1 = container.querySelector("#wsSearchInput1");
            const searchInput2 = container.querySelector("#wsSearchInput2");
            const searchInput3 = container.querySelector("#wsSearchInput3");
            const listEl       = container.querySelector(".ws-filter-list");

            const renderWsList = () => {
                updateWsSearchKeywordsFromInputs();
                listEl.innerHTML = "";

                currentWsValues.forEach((v) => {
                    const wsLower = v.toLowerCase();
                    if (!wsPassesTextFilters(wsLower)) return;

                    const checked = wsFilterValues.has(v) ? "checked" : "";
                    listEl.innerHTML += `
                        <label class="ws-chip">
                            <input type="checkbox" class="ws-filter-checkbox" value="${v}" ${checked}>
                            ${v}
                        </label>
                    `;
                });
            };

            renderWsList();

            container.onchange = (e) => {
                if (!e.target.classList.contains("ws-filter-checkbox")) return;
                const value = e.target.value;

                if (e.target.checked) {
                    wsFilterValues.add(value);
                } else {
                    wsFilterValues.delete(value);
                }

                renderCharts();
                renderExcelStyleTable();
                renderLatestKpiTable();
            };

            container.onclick = (e) => {
                const btn = e.target.closest("button[data-action]");
                if (!btn) return;

                const action = btn.dataset.action;
                const checkboxes = listEl.querySelectorAll(".ws-filter-checkbox");

                if (action === "select-all") {
                    checkboxes.forEach((cb) => wsFilterValues.add(cb.value));
                } else if (action === "clear-all") {
                    checkboxes.forEach((cb) => wsFilterValues.delete(cb.value));
                }

                renderWsList();
                renderCharts();
                renderExcelStyleTable();
                renderLatestKpiTable();
            };

            [searchInput1, searchInput2, searchInput3].forEach((inp) => {
                if (!inp) return;
                inp.addEventListener("input", () => {
                    renderWsList();
                    renderCharts();
                    renderExcelStyleTable();
                    renderLatestKpiTable();
                });
            });
        }

        // ===== X·ª≠ l√Ω Period Time (day / hour) + Filter kho·∫£ng th·ªùi gian =====

        // Bi·∫øn global nh·ªõ kho·∫£ng th·ªùi gian ƒëang ch·ªçn
        let selectedPeriodFrom = null; // label Period b·∫Øt ƒë·∫ßu
        let selectedPeriodTo   = null; // label Period k·∫øt th√∫c

        function parsePeriodDateTime(value) {
            let dateObj = null;
            let hasTime = false;

            if (value instanceof Date) {
                dateObj = value;
            } else if (typeof value === "number") {
                // Excel date code (c√≥ th·ªÉ k√®m gi·ªù)
                try {
                    const d = XLSX.SSF.parse_date_code(value);
                    if (d) {
                        dateObj = new Date(
                            d.y,
                            d.m - 1,
                            d.d,
                            d.H || 0,
                            d.M || 0,
                            d.S || 0
                        );
                        hasTime = !!(d.H || d.M || d.S);
                    }
                } catch (e) {}
            } else if (value != null && value !== "") {
                const parsed = new Date(value);
                if (!isNaN(parsed.getTime())) {
                    dateObj = parsed;
                }
            }

            if (dateObj) {
                if (
                    dateObj.getHours() !== 0 ||
                    dateObj.getMinutes() !== 0 ||
                    dateObj.getSeconds() !== 0
                ) {
                    hasTime = true;
                }
            }

            return { dateObj, hasTime };
        }

        // Chu·∫©n h√≥a Period ƒë·ªÉ d√πng chung trong group/tr·ª•c X
        function normalizePeriod(value) {
            const { dateObj, hasTime } = parsePeriodDateTime(value);

            if (dateObj) {
                const yyyy = dateObj.getFullYear();
                const mm = String(dateObj.getMonth() + 1).padStart(2, "0");
                const dd = String(dateObj.getDate()).padStart(2, "0");

                let label = `${yyyy}-${mm}-${dd}`;
                if (hasTime) {
                    const hh = String(dateObj.getHours()).padStart(2, "0");
                    const mi = String(dateObj.getMinutes()).padStart(2, "0");
                    label = `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
                }

                return {
                    label,
                    sortValue: dateObj.getTime(),
                };
            }

            return {
                label: String(value),
                sortValue: 0,
            };
        }

        // Ph√¢n bi·ªát Period l√† m·ª©c day hay hour
        function isPeriodHourly() {
            if (!currentData || !currentData.length || !periodColumnName) return false;

            const periodCol = periodColumnName;
            for (let i = 0; i < currentData.length; i++) {
                const raw = currentData[i][periodCol];
                if (raw === undefined || raw === null || raw === "") continue;

                const { hasTime } = parsePeriodDateTime(raw);
                if (hasTime) return true;
            }
            return false;
        }

        // Text tr·ª•c X cho chart
        function getXAxisLabel(chartType) {
            if (chartType === "funnel") {
                // Funnel: tr·ª•c X l√† CELL_NAME
                return getCellNameColumn();
            }
            // C√°c chart c√≤n l·∫°i: Period Time / Period Hour
            return isPeriodHourly() ? "Period Hour" : "Period Time";
        }
                
        
        // L·∫•y ng√†y (Date) m·ªõi nh·∫•t t·ª´ currentData theo c·ªôt periodColumnName
        function getLatestDateFromCurrentData() {
            if (!currentData || !currentData.length || !periodColumnName) return null;

            const periodCol = periodColumnName;
            let latestTs = -Infinity;

            currentData.forEach((row) => {
                const raw = row[periodCol];
                if (raw === undefined || raw === null) return;

                let dateObj = null;

                if (raw instanceof Date) {
                    dateObj = raw;
                } else if (typeof raw === "number") {
                    try {
                        const d = XLSX.SSF.parse_date_code(raw);
                        if (d) {
                            dateObj = new Date(d.y, d.m - 1, d.d);
                        }
                    } catch (e) {}
                } else {
                    const parsed = new Date(raw);
                    if (!isNaN(parsed.getTime())) {
                        dateObj = parsed;
                    }
                }

                if (dateObj) {
                    const ts = dateObj.getTime();
                    if (ts > latestTs) {
                        latestTs = ts;
                    }
                }
            });

            if (latestTs === -Infinity) return null;
            return new Date(latestTs);
        }

        // ƒê∆∞a Date v·ªÅ d·∫°ng dd/mm/yyyy
        function formatDateDDMMYYYY(date) {
            if (!date) return "__/__/____";
            const dd = String(date.getDate()).padStart(2, "0");
            const mm = String(date.getMonth() + 1).padStart(2, "0");
            const yyyy = date.getFullYear();
            return `${dd}/${mm}/${yyyy}`;
        }

        function getLatestPeriodLabel(data) {
            const periodCol = periodColumnName;
            let latestLabel = null;
            let latestSort = -Infinity;

            data.forEach((row) => {
                const rawPeriod = row[periodCol];
                if (rawPeriod === undefined || rawPeriod === null) return;

                const { label, sortValue } = normalizePeriod(rawPeriod);
                if (sortValue > latestSort) {
                    latestSort = sortValue;
                    latestLabel = label;
                }
                if (latestLabel === null && label != null) {
                    latestLabel = label;
                }
            });

            return latestLabel;
        }

        function buildChartDataForColumn(data, valueCol) {
            const periodCol = periodColumnName;
            const wsNameCol = getCellNameColumn();

            const groupedData = {};
            const periodMap   = new Map();

            data.forEach(row => {
                const wsName    = row[wsNameCol];
                const rawPeriod = row[periodCol];
                const rawVal = row[valueCol];
                const scale  = getKpiScaleForColumn(valueCol);
                const numeric = parseFloat(rawVal);

                if (!wsName || rawPeriod === undefined || isNaN(numeric)) return;

                const value = numeric * scale;

                const wsStr   = String(wsName);
                const wsLower = wsStr.toLowerCase();

                if (!wsPassesTextFilters(wsLower)) return;
                if (wsFilterValues && !wsFilterValues.has(wsStr)) return;

                const { label, sortValue } = normalizePeriod(rawPeriod);
                if (!periodMap.has(label) || sortValue < periodMap.get(label)) {
                    periodMap.set(label, sortValue);
                }

                if (!groupedData[wsStr]) groupedData[wsStr] = {};
                groupedData[wsStr][label] = value;
            });

        // S·∫Øp x·∫øp to√†n b·ªô period theo th·ªùi gian
        const periodEntries = Array.from(periodMap.entries())
            .sort((a, b) => a[1] - b[1]); // [label, sortValue]

        function getDayKeyFromSortValue(sortValue) {
            // sortValue c√≥ th·ªÉ l√† ms ho·∫∑c string; Date ƒë·ªÅu nh·∫≠n ƒë∆∞·ª£c
            const d = sortValue instanceof Date ? sortValue : new Date(sortValue);
            if (Number.isNaN(d.getTime())) return null;

            const yyyy = d.getFullYear();
            const mm   = String(d.getMonth() + 1).padStart(2, "0");
            const dd   = String(d.getDate()).padStart(2, "0");
            return `${yyyy}-${mm}-${dd}`;   // key theo ng√†y
        }

        let labels;

        if (chartDaysWindow && chartDaysWindow > 0) {
            // 1Ô∏è‚É£ L·∫•y N ng√†y g·∫ßn nh·∫•t theo d·ªØ li·ªáu hi·ªán c√≥
            const uniqueDays = [];
            const daySet = new Set();

            for (let i = periodEntries.length - 1; i >= 0; i--) {
                const [, sortValue] = periodEntries[i];
                const dayKey = getDayKeyFromSortValue(sortValue);
                if (!dayKey) continue;

                if (!daySet.has(dayKey)) {
                    daySet.add(dayKey);
                    uniqueDays.push(dayKey);
                    if (uniqueDays.length >= chartDaysWindow) break; // ƒë·ªß N ng√†y
                }
            }

            if (!uniqueDays.length) {
                // fallback: l·ªói parse ng√†y ‚Üí d√πng to√†n b·ªô
                labels = periodEntries.map(([lbl]) => lbl);
            } else {
                const allowedDays = new Set(uniqueDays);

                // 2Ô∏è‚É£ Gi·ªØ l·∫°i m·ªçi label thu·ªôc c√°c ng√†y ƒë√≥
                //    - Period ch·ªâ c√≥ ng√†y ‚Üí m·ªói ng√†y 1 label
                //    - Period c√≥ gi·ªù   ‚Üí l·∫•y t·∫•t c·∫£ gi·ªù trong N ng√†y g·∫ßn nh·∫•t
                labels = periodEntries
                    .filter(([, sortValue]) => {
                        const dayKey = getDayKeyFromSortValue(sortValue);
                        return dayKey && allowedDays.has(dayKey);
                    })
                    .map(([lbl]) => lbl);
            }
        } else {
            // "To√†n b·ªô" ‚Üí kh√¥ng gi·ªõi h·∫°n ng√†y
            labels = periodEntries.map(([lbl]) => lbl);
        }


            const datasets = [];
            const colors   = generateDistinctColors(Object.keys(groupedData).length);

            Object.keys(groupedData).forEach((ws, index) => {
                const wsData = groupedData[ws];

                const values = labels.map(label =>
                    wsData[label] !== undefined ? wsData[label] : null
                );

                datasets.push({
                    label: ws,
                    data: values,
                    borderColor: colors[index],
                    backgroundColor: colors[index] + '20',
                    borderWidth: 2,
                    tension: 0.4,
                    fill: false,
                    pointRadius: 1.5,
                    pointHoverRadius: 3
                });
            });

            return { labels, datasets };
        }

        function generateDistinctColors(count) {
            const colors = [
                "#667eea",
                "#764ba2",
                "#f093fb",
                "#4facfe",
                "#43e97b",
                "#fa709a",
                "#fee140",
                "#30cfd0",
                "#a8edea",
                "#fed6e3",
                "#c471ed",
                "#f64f59",
                "#12c2e9",
                "#f5af19",
                "#fbc2eb",
                "#a6c1ee",
            ];
            const result = [];
            for (let i = 0; i < count; i++) {
                result.push(colors[i % colors.length]);
            }
            return result;
        }

        function applyChartsPerRow() {
            const select = document.getElementById("chartsPerRowSelect");
            const container = document.getElementById("chartsContainer");
            if (!select || !container) return;

            const value = parseInt(select.value || "2", 10);
            const perRow = Math.min(Math.max(value, 1), 3);
            container.style.setProperty("--charts-per-row", perRow);
        }

        function handleImportedData(rows) {
            originalRows = rows;
            // copy m·∫£ng rows sang currentData
            currentData = [...rows];
            refreshKpiAndDateOptions(rows);
            renderCharts();
        }

        // L·∫•y to√†n b·ªô Period label ƒëang c√≥ trong currentData (ƒë√£ normalize)
        function getAllPeriodLabelsForCurrentData() {
            if (!currentData || !periodColumnName) return [];

            const periodCol = periodColumnName;
            const seen = new Set();
            const labels = [];

            currentData.forEach((row) => {
                const raw = row[periodCol];
                if (raw === undefined || raw === null) return;

                const norm = normalizePeriod(raw);
                if (!norm || !norm.label) return;

                if (!seen.has(norm.label)) {
                    seen.add(norm.label);
                    labels.push(norm.label);
                }
            });

            // sort tƒÉng d·∫ßn theo label (th∆∞·ªùng l√† yyyy-MM-dd HH:mm)
            labels.sort();
            return labels;
        }

        // Tr·∫£ v·ªÅ danh s√°ch Period sau khi √°p filter From / To
        function getEffectivePeriodLabels(allLabels) {
            if (!allLabels || !allLabels.length) return [];
            if (!selectedPeriodFrom && !selectedPeriodTo) return allLabels.slice();

            let startIdx = selectedPeriodFrom
                ? allLabels.indexOf(selectedPeriodFrom)
                : 0;
            let endIdx = selectedPeriodTo
                ? allLabels.indexOf(selectedPeriodTo)
                : allLabels.length - 1;

            if (startIdx < 0) startIdx = 0;
            if (endIdx < 0) endIdx = allLabels.length - 1;
            if (startIdx > endIdx) {
                const tmp = startIdx;
                startIdx = endIdx;
                endIdx = tmp;
            }

            return allLabels.slice(startIdx, endIdx + 1);
        }

        // Kh·ªüi t·∫°o combobox "T·ª´ Period" / "ƒê·∫øn Period"
        function initChartTimeFilterControls(allPeriodLabels) {
            const fromSel  = document.getElementById("chartTimeFrom");
            const toSel    = document.getElementById("chartTimeTo");
            const clearBtn = document.getElementById("chartTimeClearBtn");
            if (!fromSel || !toSel) return;

            const curFrom = selectedPeriodFrom;
            const curTo   = selectedPeriodTo;

            fromSel.innerHTML = '<option value="">T·ª´ (t·∫•t c·∫£)</option>';
            toSel.innerHTML   = '<option value="">ƒê·∫øn (t·∫•t c·∫£)</option>';

            allPeriodLabels.forEach((lb) => {
                const opt1 = document.createElement("option");
                opt1.value = lb;
                opt1.textContent = lb;
                if (lb === curFrom) opt1.selected = true;
                fromSel.appendChild(opt1);

                const opt2 = document.createElement("option");
                opt2.value = lb;
                opt2.textContent = lb;
                if (lb === curTo) opt2.selected = true;
                toSel.appendChild(opt2);
            });

            if (!fromSel._bound) {
                fromSel.addEventListener("change", () => {
                    selectedPeriodFrom = fromSel.value || null;
                    renderCharts();
                });
                fromSel._bound = true;
            }

            if (!toSel._bound) {
                toSel.addEventListener("change", () => {
                    selectedPeriodTo = toSel.value || null;
                    renderCharts();
                });
                toSel._bound = true;
            }

            if (clearBtn && !clearBtn._bound) {
                clearBtn.addEventListener("click", () => {
                    selectedPeriodFrom = null;
                    selectedPeriodTo   = null;
                    fromSel.value = "";
                    toSel.value   = "";
                    renderCharts();
                });
                clearBtn._bound = true;
            }
        }
        function populateVerticalTimeSelect(periodLabels) {
            const select = document.getElementById("chartVerticalTime");
            if (!select) return;

            const current = select.value;

            select.innerHTML = '<option value="">-- Kh√¥ng v·∫Ω --</option>';

            periodLabels.forEach(p => {
                const opt = document.createElement("option");
                opt.value = p;
                opt.textContent = p;
                select.appendChild(opt);
            });

            // gi·ªØ l·∫°i gi√° tr·ªã ƒëang ch·ªçn n·∫øu c√≤n t·ªìn t·∫°i
            if (current && periodLabels.includes(current)) {
                select.value = current;
            }
        }

        function renderCharts() {
            if (!currentData || numericColumns.length === 0) return;

            const activeKpiCols = numericColumns.filter(col => selectedKpiColumns.has(col));

            if (!activeKpiCols.length) {
                const container = document.getElementById('chartsContainer');
                if (container) {
                    container.innerHTML =
                        '<p style="padding:8px; font-size:0.9em; color:#6b7280;">Kh√¥ng c√≥ KPI n√†o ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ v·∫Ω bi·ªÉu ƒë·ªì.</p>';
                }

                Object.values(chartInstances).forEach(ch => ch.destroy());
                chartInstances = {};

                // üîÅ Kh√¥ng c√≥ KPI n√†o -> reset lu√¥n c√°c b·∫£ng li√™n quan
                if (typeof renderExcelStyleTable === "function") {
                    renderExcelStyleTable();
                }
                if (typeof renderLatestKpiTable === "function") {
                    renderLatestKpiTable();
                }
                if (typeof renderWorstCellTable === "function") {
                    renderWorstCellTable();
                }

                return;
            }

            const container = document.getElementById("chartsContainer");
            applyChartsPerRow();

            // üîπ To√†n b·ªô Period trong d·ªØ li·ªáu
            const allPeriodLabels = getAllPeriodLabelsForCurrentData();

            // üîπ Kh·ªüi t·∫°o combobox "T·ª´ / ƒê·∫øn" (t·ª± bind onchange -> g·ªçi l·∫°i renderCharts)
            initChartTimeFilterControls(allPeriodLabels);

            // üîπ Danh s√°ch Period sau khi √°p filter th·ªùi gian
            let  effectivePeriodLabels = getEffectivePeriodLabels(allPeriodLabels);
            // ‚úÖ N·∫øu ch·ªçn "N ng√†y g·∫ßn nh·∫•t" th√¨ scale tr·ª•c X theo ƒë√∫ng N ng√†y (c·∫Øt effectivePeriodLabels)
            if (chartDaysWindow && chartDaysWindow > 0 && effectivePeriodLabels && effectivePeriodLabels.length) {

                // L·∫•y danh s√°ch NG√ÄY (yyyy-MM-dd) g·∫ßn nh·∫•t d·ª±a tr√™n label
                const lastDays = [];
                const seen = new Set();

                for (let i = effectivePeriodLabels.length - 1; i >= 0; i--) {
                    const lb = String(effectivePeriodLabels[i]);
                    const dayKey = lb.split(" ")[0];     // n·∫øu label c√≥ gi·ªù th√¨ l·∫•y ph·∫ßn ng√†y
                    if (!seen.has(dayKey)) {
                        seen.add(dayKey);
                        lastDays.push(dayKey);
                        if (lastDays.length >= chartDaysWindow) break;
                    }
                }

                const allowed = new Set(lastDays);
                effectivePeriodLabels = effectivePeriodLabels.filter(lb => {
                    const dayKey = String(lb).split(" ")[0];
                    return allowed.has(dayKey);
                });
            }

            // ‚úÖ Populate combobox ch·ªçn m·ªëc v·∫Ω line d·ªçc
            populateVerticalTimeSelect(effectivePeriodLabels && effectivePeriodLabels.length
                ? effectivePeriodLabels
                : allPeriodLabels
            );

            // üîπ Period m·ªõi nh·∫•t s·∫Ω d√πng cho Pie / Doughnut / Funnel
            let latestLabelForCharts = null;
            if (effectivePeriodLabels.length) {
                latestLabelForCharts = effectivePeriodLabels[effectivePeriodLabels.length - 1];
            } else {
                // N·∫øu ch∆∞a ch·ªçn / filter ra r·ªóng th√¨ fallback nh∆∞ c≈©
                latestLabelForCharts = getLatestPeriodLabel(currentData);
            }

            // L∆∞u l·∫°i ki·ªÉu chart ƒë√£ ch·ªçn tr∆∞·ªõc ƒë√≥
            const prevTypes = {};
            document
                .querySelectorAll(".chart-type-select")
                .forEach((sel) => {
                    prevTypes[sel.dataset.column] = sel.value;
                });

            Object.values(chartInstances).forEach((ch) => ch.destroy());
            chartInstances = {};
            container.innerHTML = "";

            // V·∫Ω khung chart + combobox ch·ªçn ki·ªÉu
            activeKpiCols.forEach((valueCol, index) => {
                const chartId = `chart_${index}`;

                // ‚úÖ Default: line, ri√™ng 2 KPI MAC SDU ‚Üí stackedArea
                let prevType = prevTypes[valueCol];
                if (!prevType) {
                    prevType = isMacSduKpi(valueCol) ? "stackedArea" : "line";
                }

                const titleText = getKpiTitleWithUnit(valueCol);

                // Ki·ªÉm tra xem KPI n√†y c√≥ ng∆∞·ª°ng kh√¥ng
                const thr = getThresholdForKpiColumn(valueCol);
                const hasThreshold =
                    thr && typeof thr.value === "number" && !isNaN(thr.value);

                const isTargetOn = !!chartTargetVisible[valueCol];

                const yRange = chartYAxisRange[valueCol] || {};
                const yMinVal = (yRange.min != null && !isNaN(yRange.min)) ? yRange.min : "";
                const yMaxVal = (yRange.max != null && !isNaN(yRange.max)) ? yRange.max : "";

                container.innerHTML += `
                    <div class="chart-card">
                        <h3>${titleText}</h3>
                        <div class="chart-header-row"
                            style="display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px;">

                            <!-- B√äN TR√ÅI: Y min/max + nh√£n period -->
                                <div style="display:flex; align-items:center; gap:10px;">
                                    <div class="chart-y-controls"
                                        style="display:flex; align-items:center; gap:4px; font-size:0.8em; color:#374151;">
                                        <span>Y:</span>
                                        <input type="number" step="any"
                                            class="chart-ymin-input"
                                            data-column="${valueCol}"
                                            placeholder="min"
                                            value="${yMinVal}"
                                            style="width:70px; padding:2px 4px; border-radius:6px; border:1px solid #d1d5db;">
                                        <span>‚Üí</span>
                                        <input type="number" step="any"
                                            class="chart-ymax-input"
                                            data-column="${valueCol}"
                                            placeholder="max"
                                            value="${yMaxVal}"
                                            style="width:70px; padding:2px 4px; border-radius:6px; border:1px solid #d1d5db;">
                                    </div>
                                    <span id="period-label-${chartId}"
                                        style="font-size:0.8em; color:#6b7280;"></span>
                                </div>

                            <!-- B√äN PH·∫¢I: Ki·ªÉu chart + Target -->
                            <div style="display:flex; align-items:center; gap:12px; flex-wrap:wrap; justify-content:flex-end;">
                                <div style="display:flex; align-items:center; gap:6px;">
                                    <span style="font-size:0.85em; color:#555;">Ki·ªÉu chart:</span>
                                    <select class="chart-type-select"
                                            data-chart-id="${chartId}"
                                            data-column="${valueCol}">
                                        <option value="line" ${prevType === "line" ? "selected" : ""}>Line</option>
                                        <option value="bar" ${prevType === "bar" ? "selected" : ""}>Bar</option>
                                        <option value="stackedArea" ${prevType === "stackedArea" ? "selected" : ""}>Stacked Area</option>
                                        <option value="pie" ${prevType === "pie" ? "selected" : ""}>Pie</option>
                                        <option value="doughnut" ${prevType === "doughnut" ? "selected" : ""}>Doughnut</option>
                                        <option value="funnel" ${prevType === "funnel" ? "selected" : ""}>Funnel</option>
                                    </select>
                                    ${
                                        hasThreshold
                                            ? `
                                    <label style="display:flex; align-items:center; gap:4px; font-size:0.8em; color:#374151;">
                                        <input type="checkbox"
                                            class="chart-target-toggle"
                                            data-chart-id="${chartId}"
                                            data-column="${valueCol}"
                                            ${isTargetOn ? "checked" : ""}/>
                                        Target
                                    </label>
                                    `
                                            : ""
                                    }
                                </div>
                            </div>
                        </div>

                        <div class="chart-wrapper">
                            <canvas id="${chartId}"></canvas>
                        </div>
                    </div>
                `;
            });

            // Build d·ªØ li·ªáu & v·∫Ω chart
            activeKpiCols.forEach((valueCol, index) => {
                const chartId = `chart_${index}`;
                const titleText = getKpiTitleWithUnit(valueCol);
                let { labels, datasets } = buildChartDataForColumn(
                    currentData,
                    valueCol
                );
                const canvas = document.getElementById(chartId);
                if (!canvas) return;
                const ctx = canvas.getContext("2d");
                const typeSelect = document.querySelector(
                    `.chart-type-select[data-chart-id="${chartId}"]`
                );
                let chartType = typeSelect ? typeSelect.value : "line";

                // üîπ V·ªõi chart d·∫°ng time-series (line / bar / stackedArea):
                // lu√¥n d√πng danh s√°ch Period ƒë√£ l·ªçc (effectivePeriodLabels)
                if (
                    effectivePeriodLabels &&
                    effectivePeriodLabels.length > 0 &&
                    (chartType === "line" ||
                    chartType === "bar" ||
                    chartType === "stackedArea")
                ) {
                    const indexMap = new Map();
                    (labels || []).forEach((lb, idx) => {
                        indexMap.set(lb, idx);
                    });

                    const remappedDatasets = (datasets || []).map(ds => {
                        const srcData = ds.data || [];
                        const newData = effectivePeriodLabels.map(lb => {
                            const idx = indexMap.get(lb);
                            if (idx == null) return null;   // period n√†y kh√¥ng c√≥ d·ªØ li·ªáu
                            return srcData[idx] !== undefined ? srcData[idx] : null;
                        });
                        return { ...ds, data: newData };
                    });

                    labels = effectivePeriodLabels.slice();
                    datasets = remappedDatasets;
                }

                // ‚úÖ N·∫øu ch·ªâ c√≥ 1 period sau khi l·ªçc ‚Üí t·ª± ƒë·ªông hi·ªÉn th·ªã d·∫°ng Funnel (bar d·ªçc)
                if (
                    labels &&
                    labels.length === 1 &&
                    (chartType === "line" ||
                    chartType === "bar"  ||
                    chartType === "stackedArea")
                ) {
                    chartType = "funnel";
                    if (typeSelect) {
                        typeSelect.value = "funnel";
                    }
                }

                const periodLabelEl = document.getElementById(
                    `period-label-${chartId}`
                );
                if (periodLabelEl) periodLabelEl.textContent = "";

                // ================= PIE / DOUGHNUT =================
                if (chartType === "pie" || chartType === "doughnut") {
                    const latestLabel = latestLabelForCharts;   // üîÑ d√πng period m·ªõi nh·∫•t sau filter
                    const periodCol = periodColumnName;
                    const wsNameCol = getCellNameColumn();

                    const totalByWS = {};

                    currentData.forEach((row) => {
                        const wsName = row[wsNameCol];
                        const rawPeriod = row[periodCol];
                        const rawVal = row[valueCol];
                        const scale  = getKpiScaleForColumn(valueCol);
                        const numeric = parseFloat(rawVal);

                        if (
                            !wsName ||
                            rawPeriod === undefined ||
                            rawPeriod === null ||
                            isNaN(numeric)
                        )
                            return;
                        const value = numeric * scale;
                        const norm = normalizePeriod(rawPeriod);
                        if (!norm || norm.label !== latestLabel) return;

                        const wsStr = String(wsName);
                        const wsLower = wsStr.toLowerCase();
                        if (!wsPassesTextFilters(wsLower)) return;
                        if (
                            wsFilterValues &&
                            wsFilterValues.size > 0 &&
                            !wsFilterValues.has(wsStr)
                        )
                            return;

                        totalByWS[wsStr] =
                            (totalByWS[wsStr] || 0) + value;
                    });

                    labels = Object.keys(totalByWS);
                    datasets = [
                        {
                            data: Object.values(totalByWS),
                            backgroundColor: generateDistinctColors(
                                labels.length
                            ),
                            borderWidth: 1,
                        },
                    ];

                    if (periodLabelEl && latestLabel) {
                        periodLabelEl.textContent = `Ng√†y: ${latestLabel}`;
                    }
                }

                // ================= FUNNEL =================
                if (chartType === "funnel") {
                    const latestLabel = latestLabelForCharts;   // üîÑ d√πng period m·ªõi nh·∫•t sau filter
                    const periodCol = periodColumnName;
                    const wsNameCol = getCellNameColumn();

                    const totalByWS = {};

                    // T√≠nh gi√° tr·ªã KPI cho t·ª´ng WS t·∫°i th·ªùi ƒëi·ªÉm m·ªõi nh·∫•t
                    currentData.forEach((row) => {
                        const wsName    = row[wsNameCol];
                        const rawPeriod = row[periodCol];
                        const rawVal    = row[valueCol];
                        const scale     = getKpiScaleForColumn(valueCol);
                        const numeric   = parseFloat(rawVal);

                        if (!wsName || rawPeriod == null || isNaN(numeric)) return;

                        const value = numeric * scale;
                        const norm  = normalizePeriod(rawPeriod);
                        if (!norm || norm.label !== latestLabel) return;

                        const wsStr   = String(wsName);
                        const wsLower = wsStr.toLowerCase();

                        if (!wsPassesTextFilters(wsLower)) return;
                        if (wsFilterValues && wsFilterValues.size > 0 && !wsFilterValues.has(wsStr)) return;

                        totalByWS[wsStr] = value;
                    });

                    const entries = Object.entries(totalByWS);

                    let filteredEntries;

                    if (entries.length <= 30) {
                        // √çt h∆°n ho·∫∑c b·∫±ng 30 cell -> gi·ªØ nguy√™n
                        filteredEntries = entries.slice();
                    } else {
                        // Nhi·ªÅu h∆°n 30 cell:
                        //   - L·∫•y 20 gi√° tr·ªã cao nh·∫•t
                        //   - L·∫•y 10 gi√° tr·ªã th·∫•p nh·∫•t
                        const descSorted = [...entries].sort((a, b) => b[1] - a[1]);
                        const top20 = descSorted.slice(0, 20);
                        const bottom10 = descSorted.slice(-10);

                        const seen = new Set();
                        filteredEntries = [];

                        [...top20, ...bottom10].forEach(([name, val]) => {
                            const key = String(name);
                            if (!seen.has(key)) {
                                seen.add(key);
                                filteredEntries.push([name, val]);
                            }
                        });
                    }

                    // √Åp th·ª© t·ª± hi·ªÉn th·ªã theo combobox Funnel Sort
                    if (funnelSortOrder === "asc") {
                        filteredEntries.sort((a, b) => a[1] - b[1]);   // nh·ªè -> l·ªõn
                    } else {
                        filteredEntries.sort((a, b) => b[1] - a[1]);   // l·ªõn -> nh·ªè
                    }

                    labels = filteredEntries.map(([ws]) => ws);
                    datasets = [
                        {
                            data: filteredEntries.map(([, v]) => v),
                            backgroundColor: generateDistinctColors(filteredEntries.length),
                            borderWidth: 1,
                        }
                    ];

                    if (periodLabelEl && latestLabel) {
                        periodLabelEl.textContent = `Ng√†y: ${latestLabel}`;
                    }
                }

                // ============ TARGET LINE & CONFIG CHART ============

                // X√°c ƒë·ªãnh lo·∫°i chart th·ª±c t·∫ø
                const thrForChart = getThresholdForKpiColumn(valueCol);

                let internalType = chartType;
                if (chartType === "stackedArea") {
                    internalType = "line";
                }

                if (chartType === "funnel") {
                    internalType = "bar";
                }

                let chartDatasets = datasets;
                if (chartType === "stackedArea") {
                    chartDatasets = datasets.map((ds, idx) => {
                        let solidColor = ds.borderColor || "#667eea";

                        return {
                            ...ds,
                            fill: true,
                            backgroundColor: solidColor,
                            borderWidth: 1,
                            stack: "stack_" + valueCol,
                            borderColor: solidColor,
                            
                            pointRadius: 2,
                            pointHoverRadius: 6,
                            pointBorderWidth: 1,
                            pointHitRadius: 6,

                            
                            //pointRadius: 1,
                            tension: 0.3,
                            clip: false,
                        };
                    });
                }

                // √Åp c·∫•u h√¨nh marker & clip cho t·∫•t c·∫£ dataset d·∫°ng line
                if (chartType === "line" || chartType === "stackedArea") {
                    chartDatasets = chartDatasets.map(ds => ({
                        ...ds,
                        pointRadius: 2,
                        pointHoverRadius: 6,
                        pointBorderWidth: 1,
                        pointHitRadius: 6,
                        // radius: 3,
                        // hoverRadius: 6,
                        //pointRadius: 1,
                        clip: false,   // üëâ cho ph√©p v·∫Ω ch·∫•m tr√≤n tr√†n m√©p tr√™n, kh√¥ng b·ªã c·∫Øt
                    }));
                }

                const hasThrForChart =
                    thrForChart &&
                    typeof thrForChart.value === "number" &&
                    !isNaN(thrForChart.value);

                // Ch·ªâ v·∫Ω target line khi:
                // - C√≥ ng∆∞·ª°ng
                // - Checkbox t·ªïng ƒëang b·∫≠t
                // - Checkbox Target ri√™ng cho KPI n√†y ƒëang b·∫≠t
                // - Lo·∫°i chart ph√π h·ª£p
                const showTargetLine =
                    hasThrForChart &&
                    globalThresholdEnabled &&
                    chartTargetVisible[valueCol] &&
                    (chartType === "line" ||
                        chartType === "bar" ||
                        chartType === "stackedArea" ||
                        chartType === "funnel");

                if (showTargetLine) {
                    const targetVal = thrForChart.value;
                    const targetData = (labels || []).map(() => targetVal);

                    chartDatasets = [
                        ...chartDatasets,
                        {
                            label: "Target",
                            data: targetData,
                            type: "line",
                            borderWidth: 5,        // ƒê·ªô d√†y target line
                            borderColor: "#ff0000",
                            borderDash: [8, 5],
                            
                            pointRadius: 2,
                            pointHoverRadius: 6,
                            pointBorderWidth: 1,
                            pointHitRadius: 6,
                            // radius: 3,
                            // hoverRadius: 6,
                            
                            clip: false,
                            //pointRadius: 1,
                            tension: 0,
                            fill: false,
                            yAxisID: "y",
                        },
                    ];
                }

                const yOverride = chartYAxisRange[valueCol];
                const yMinOverride = yOverride && yOverride.min != null ? yOverride.min : undefined;
                const yMaxOverride = yOverride && yOverride.max != null ? yOverride.max : undefined;

                chartInstances[chartId] = new Chart(ctx, {
                    type: internalType,
                    data: {
                        labels,
                        datasets: chartDatasets,
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        // ‚úÖ d√πng nearest + intersect
                        interaction: {
                            mode: "nearest",   // ho·∫∑c "point"
                            intersect: true,
                        },
                        plugins: {
                            legend: {
                                display: chartType !== "funnel",   // funnel th√¨ t·∫Øt legend
                                position: "bottom",
                                labels: {
                                    usePointStyle: true,
                                    padding: 12,
                                    font: {
                                        size: 11,
                                    },
                                },
                            },
                            tooltip: {
                                backgroundColor:
                                    "rgba(0, 0, 0, 0.85)",
                                padding: 10,
                                titleFont: {
                                    size: 13,
                                },
                                bodyFont: {
                                    size: 12,
                                },
                                callbacks: {
                                    label: function (ctx) {
                                        const chartTypeInternal =
                                            ctx.chart.config.type;
                                        const raw =
                                            typeof ctx.parsed.y ===
                                            "number"
                                                ? ctx.parsed.y
                                                : ctx.raw;
                                        const value =
                                            typeof raw === "number"
                                                ? Math.round(
                                                    raw * 1000
                                                ) / 1000
                                                : raw;

                                        if (
                                            chartTypeInternal === "pie" ||
                                            chartTypeInternal === "doughnut"
                                        ) {
                                            const dataArr =
                                                ctx.dataset.data || [];
                                            const total =
                                                dataArr.reduce(
                                                    (s, v) =>
                                                        s +
                                                        (typeof v ===
                                                        "number"
                                                            ? v
                                                            : 0),
                                                    0
                                                );
                                            const pct = total
                                                ? Math.round(
                                                    (value / total) *
                                                        100000
                                                ) / 1000
                                                : 0;
                                            return `${ctx.label}: ${value} (${pct}%)`;
                                        }

                                        const label = ctx.dataset
                                            .label
                                            ? ctx.dataset.label + ": "
                                            : "";
                                        return label + value;
                                    },
                                },
                            },
                            datalabels: {
                                display: function (ctx) {
                                    const type =
                                        ctx.chart.config.type;
                                    return (
                                        type === "pie" ||
                                        type === "doughnut"
                                    );
                                },
                                formatter: function (value, ctx) {
                                    if (
                                        typeof value !== "number" ||
                                        isNaN(value)
                                    )
                                        return "";
                                    const dataArr =
                                        ctx.chart.data.datasets[
                                            ctx.datasetIndex
                                        ].data || [];
                                    const total = dataArr.reduce(
                                        (s, v) =>
                                            s +
                                            (typeof v === "number"
                                                ? v
                                                : 0),
                                        0
                                    );
                                    if (!total) return "";
                                    const pct =
                                        Math.round(
                                            (value / total) * 100000
                                        ) / 1000;
                                    return pct + "%";
                                },
                                color: "#ffffff",
                                font: {
                                    size: 10,
                                    weight: "bold",
                                },
                                textStrokeColor: "#000",
                                textStrokeWidth: 2,
                                padding: 3,
                                clamp: true,
                                anchor: "center",
                                align: "center",
                            },
                        },
                        scales: {
                            x: {
                                // Hi·ªán tr·ª•c X cho line / bar / stackedArea / funnel
                                display:
                                    chartType === "line" ||
                                    chartType === "bar" ||
                                    chartType === "stackedArea" ||
                                    chartType === "funnel",
                                title: {
                                    display:
                                        chartType === "line" ||
                                        chartType === "bar" ||
                                        chartType === "stackedArea" ||
                                        chartType === "funnel",
                                    // ‚úÖ Funnel: tr·ª•c X l√† CELL_NAME, c√°c chart kh√°c: Period Time / Period Hour
                                    text: getXAxisLabel(chartType),
                                    font: {
                                        size: 13,
                                        weight: "bold",
                                    },
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45,
                                },
                            },
                            y: {
                                display:
                                    chartType === "line" ||
                                    chartType === "bar" ||
                                    chartType === "stackedArea" ||
                                    chartType === "funnel",
                                title: {
                                    display:
                                        chartType === "line" ||
                                        chartType === "bar" ||
                                        chartType === "stackedArea" ||
                                        chartType === "funnel",
                                    text: titleText,
                                    font: {
                                        size: 13,
                                        weight: "bold",
                                    },
                                },
                                // N·∫øu c√≥ min override th√¨ kh√¥ng √©p beginAtZero n·ªØa
                                beginAtZero: (yMinOverride === undefined)
                                    ? (chartType === "funnel")
                                    : false,
                                grace: "10%",
                                stacked: chartType === "stackedArea",
                                min: yMinOverride,
                                max: yMaxOverride,

                            },
                        },
                    },
                });
            
            });

            document
                .querySelectorAll(".chart-type-select")
                .forEach((sel) => {
                    sel.onchange = () => {
                        renderCharts();
                    };
                });

            // NEW: checkbox b·∫≠t/t·∫Øt line target
            document
                .querySelectorAll(".chart-target-toggle")
                .forEach((cb) => {
                    cb.onchange = () => {
                        const col = cb.dataset.column;
                        chartTargetVisible[col] = cb.checked;
                        renderCharts();
                    };
                });

            // NEW: thay ƒë·ªïi min/max tr·ª•c Y cho t·ª´ng KPI
            document
                .querySelectorAll(".chart-ymin-input, .chart-ymax-input")
                .forEach((inp) => {
                    if (inp._bound) return;
                    inp.addEventListener("change", () => {
                        const col = inp.dataset.column;
                        const minInput = document.querySelector(`.chart-ymin-input[data-column="${col}"]`);
                        const maxInput = document.querySelector(`.chart-ymax-input[data-column="${col}"]`);

                        const minValRaw = minInput && minInput.value !== "" ? Number(minInput.value) : null;
                        const maxValRaw = maxInput && maxInput.value !== "" ? Number(maxInput.value) : null;

                        const minVal = (minValRaw != null && !isNaN(minValRaw)) ? minValRaw : null;
                        const maxVal = (maxValRaw != null && !isNaN(maxValRaw)) ? maxValRaw : null;

                        chartYAxisRange[col] = { min: minVal, max: maxVal };

                        renderCharts();
                    });
                    inp._bound = true;
                });

            renderLatestKpiTable();
            renderExcelStyleTable();
        }
                
        function buildExcelDateOptions() {
            if (!currentData || !periodColumnName) return;

            const input = document.getElementById("excelDateInput");
            if (!input) return;

            const periodCol = periodColumnName;
            const labelMap = new Map();

            currentData.forEach((row) => {
                const rawPeriod = row[periodCol];
                if (rawPeriod === undefined || rawPeriod === null) return;
                const norm = normalizePeriod(rawPeriod);
                if (!norm || !norm.label) return;

                if (
                    !labelMap.has(norm.label) ||
                    norm.sortValue > labelMap.get(norm.label)
                ) {
                    labelMap.set(norm.label, norm.sortValue);
                }
            });

            const labels = Array.from(labelMap.entries())
                .sort((a, b) => a[1] - b[1])
                .map(([label]) => label);

            if (!labels.length) {
                input.value = "";
                excelSelectedDate = null;
                return;
            }

            const latestLabel = labels[labels.length - 1];

            excelSelectedDate = latestLabel;
            input.value = latestLabel;

            const latestBtn = document.getElementById("excelLatestBtn");
            if (latestBtn) {
                latestBtn.onclick = function () {
                    excelSelectedDate = latestLabel;
                    input.value = latestLabel;
                    renderExcelStyleTable();
                };
            }

            input.onchange = function () {
                excelSelectedDate = this.value || null;
                renderExcelStyleTable();
            };
        }

        function renderExcelStyleTable() {
            if (!currentData || numericColumns.length === 0) return;

            const tableCard = document.getElementById("excelTableCard");
            const tableDiv  = document.getElementById("excelTable");
            const titleEl   = document.getElementById("excelTableTitle");
            if (!tableCard || !tableDiv || !titleEl) return;
    
            // N·∫øu ch∆∞a load KPI Threshhold th√¨ trigger load & render l·∫°i sau khi xong
            if (kpiThresholdMap === null) {
                ensureKpiThresholdsLoaded().then(() => {
                    if (tableCard && tableCard.style.display !== "none") {
                        renderExcelStyleTable();
                    }
                });
            }

            let targetLabel = excelSelectedDate || getLatestPeriodLabel(currentData);
            if (!targetLabel) {
                tableCard.style.display = "none";
                return;
            }

            const activeKpiCols = numericColumns.filter(col => selectedKpiColumns.has(col));

            if (!activeKpiCols.length) {
                titleEl.textContent = `KPI Overview (Ng√†y: ${targetLabel}) ‚Äì kh√¥ng c√≥ KPI n√†o ƒë∆∞·ª£c ch·ªçn`;
                tableDiv.innerHTML  = "";
                tableCard.style.display = "block";
                return;
            }

            const periodCol = periodColumnName;
            const wsNameCol = getCellNameColumn();   // üëâ KPI Overview l·∫•y ƒë√∫ng CELL_NAME
            const sheetName =
                document.getElementById("sheetSelect")?.value || "";

            const wsSet = new Set();

            currentData.forEach((row) => {
                const wsName    = row[wsNameCol];
                const rawPeriod = row[periodCol];
                if (!wsName || rawPeriod === undefined || rawPeriod === null)
                    return;

                const norm = normalizePeriod(rawPeriod);
                if (!norm || norm.label !== targetLabel) return;

                const wsStr   = String(wsName);
                const wsLower = wsStr.toLowerCase();

                if (!wsPassesTextFilters(wsLower)) return;
                if (wsFilterValues && wsFilterValues.size > 0 && !wsFilterValues.has(wsStr))
                    return;

                wsSet.add(wsStr);
            });

            const wsList = Array.from(wsSet).sort();

            if (wsList.length === 0) {
                titleEl.textContent = `KPI Overview (Ng√†y: ${targetLabel}) ‚Äì kh√¥ng c√≥ d·ªØ li·ªáu kh·ªõp b·ªô l·ªçc`;
                tableDiv.innerHTML  = "";
                tableCard.style.display = "block";
                return;
            }

            const wsSetForLookup = new Set(wsList);
            const valueByKpiWs = {};

            currentData.forEach((row) => {
                const wsName    = row[wsNameCol];
                const rawPeriod = row[periodCol];
                if (!wsName || rawPeriod === undefined || rawPeriod === null)
                    return;

                const norm = normalizePeriod(rawPeriod);
                if (!norm || norm.label !== targetLabel) return;

                const wsStr = String(wsName);
                if (!wsSetForLookup.has(wsStr)) return;

                activeKpiCols.forEach((kpiCol) => {
                    const rawVal = row[kpiCol];
                    const num    = parseFloat(rawVal);
                    if (isNaN(num)) return;

                    const scale  = getKpiScaleForColumn(kpiCol);
                    const scaled = num * scale;

                    if (!valueByKpiWs[kpiCol]) valueByKpiWs[kpiCol] = {};
                    valueByKpiWs[kpiCol][wsStr] = scaled;
                });
            });

            titleEl.textContent = `KPI Overview (Ng√†y: ${targetLabel})`;
            const colSpan = 4 + wsList.length;
            let html = `<table>
                <thead>
                    <tr>
                        <th colspan="${colSpan}" style="background:#1f2937; color:#fff; padding:6px 8px; text-align:center; font-weight:700;">
                            ${sheetName || "KPI Daily Report"}
                        </th>
                    </tr>
                    <tr>
                        <th colspan="${colSpan}" style="background:#fde68a; color:#111827; padding:4px 8px; text-align:right; font-weight:600;">
                            Ng√†y: ${targetLabel}
                        </th>
                    </tr>
                    <tr>
                        <th style="background:#203864; color:#fff; padding:6px 8px; border:1px solid #cbd5e1; white-space:nowrap;">KPI Name</th>
                        <th style="background:#203864; color:#fff; padding:6px 8px; border:1px solid #cbd5e1;">KPI ID</th>
                        <th style="background:#203864; color:#fff; padding:6px 8px; border:1px solid #cbd5e1;">Unit</th>
                        <th style="background:#203864; color:#fff; padding:6px 8px; border:1px solid #cbd5e1;">Target</th>`;

            wsList.forEach((ws) => {
                html += `<th style="background:#9bbb59; color:#111827; padding:6px 8px; border:1px solid #cbd5e1; text-align:center;">${ws}</th>`;
            });

            html += `</tr></thead><tbody>`;

            activeKpiCols.forEach((kpiCol) => {
                const rowValues = valueByKpiWs[kpiCol] || {};
                const meta      = findKpiMetaForColumn(kpiCol) || {};
                const kpiId     = meta.id   || "";
                const unitLabel = getDisplayUnit(meta);
                const kpiName   = meta.name || kpiCol;

                // L·∫•y ng∆∞·ª°ng v√† ƒë·∫£o chi·ªÅu ƒë·ªÉ hi·ªÉn th·ªã Target
                const thr = getThresholdForKpiColumn(kpiCol);
                let targetDisplay = "";

                if (thr && thr.op && typeof thr.value === "number") {
                    const reversedOp =
                        thr.op === "<"  ? ">="  :
                        thr.op === "<=" ? ">" :
                        thr.op === ">"  ? "<="  :
                        thr.op === ">=" ? "<" :
                        thr.op === "!=" ? "=" :
                        (thr.op === "=" || thr.op === "==") ? "!=" : "";

                    targetDisplay = reversedOp ? `${reversedOp} ${thr.value}` : "";
                }

                html += `<tr>
                    <td style="padding:6px 16px; border:1px solid #e5e7eb; background:#d9e1f2; font-weight:600; white-space:nowrap;">${kpiName}</td>
                    <td style="padding:6px 8px; border:1px solid #e5e7eb; background:#d9e1f2; text-align:center;">${kpiId}</td>
                    <td style="padding:6px 8px; border:1px solid #e5e7eb; background:#d9e1f2; text-align:center;">${unitLabel}</td>
                    <td style="padding:6px 8px; border:1px solid #e5e7eb; background:#d9e1f2; text-align:center; font-weight:600;">${targetDisplay}</td>`;

                wsList.forEach((ws) => {
    const v = rowValues[ws];
    let display = "";
    if (typeof v === "number" && !isNaN(v)) {
        display = Math.round(v * 1000) / 1000;
    }

    // === Highlight theo ng∆∞·ª°ng ch·ªâ khi checkbox t·ªïng ƒëang b·∫≠t ===
    let condStyle = "";
    if (
        globalThresholdEnabled &&             // üî¥ g·∫Øn v·ªõi checkbox t·ªïng
        typeof v === "number" &&
        !isNaN(v) &&
        kpiThresholdMap
    ) {
        const thr = getThresholdForKpiColumn(kpiCol);
        if (thr) {
            const num = v;
            const t   = thr.value;
            const op  = thr.op;
            let isBad = false;

            if (op === "<") {
                isBad = num < t;
            } else if (op === ">") {
                isBad = num > t;
            } else if (op === "<=") {
                isBad = num <= t;
            } else if (op === ">=") {
                isBad = num >= t;
            } else if (op === "=" || op === "==") {
                isBad = num === t;
            }

            if (isBad) {
                condStyle =
                    "background:#fee2e2; color:#b91c1c; font-weight:700;";
            }
        }
    }

    html += `<td style="padding:6px 8px; border:1px solid #e5e7eb; text-align:center; ${condStyle}">${display}</td>`;
});


                html += `</tr>`;
            });

            html += `</tbody></table>`;

            tableDiv.innerHTML = `<div style="min-width:100%; overflow-x:auto;">${html}</div>`;
            tableCard.style.display = "block";

            applyStickyKpiColumns();
            applyKpiOverviewTargetVisibility();


        }

        function applyStickyKpiColumns() {
            const wrapper = document.getElementById('excelTable');
            if (!wrapper) return;

            const table = wrapper.querySelector('table');
            if (!table || !table.tHead) return;

            requestAnimationFrame(() => {
                const headerRows = Array.from(table.tHead.rows);
                if (!headerRows.length) return;

                const headerRow = headerRows[headerRows.length - 1];
                const stickyCount = globalThresholdEnabled ? 4 : 3;

                const tableRect = table.getBoundingClientRect();
                const colLeft = [];

                for (let i = 0; i < stickyCount; i++) {
                    const cell = headerRow.cells[i];
                    if (!cell) continue;
                    const rect = cell.getBoundingClientRect();
                    colLeft[i] = rect.left - tableRect.left;
                }

                const oldSticky = table.querySelectorAll('.sticky-col');
                oldSticky.forEach(c => {
                    c.classList.remove('sticky-col');
                    c.style.left = '';
                    c.style.position = '';
                });

                const rows = Array.from(table.rows);
                rows.forEach(row => {
                    for (let i = 0; i < stickyCount; i++) {
                        const cell = row.cells[i];
                        if (!cell) continue;

                        cell.classList.add('sticky-col');
                        cell.style.position = 'sticky';
                        cell.style.left = (colLeft[i] || 0) + 'px';

                        if (!cell.style.backgroundColor) {
                            if (row.parentNode.tagName === 'THEAD') {
                                cell.style.backgroundColor = '#203864';
                                cell.style.color = '#fff';
                            } else {
                                cell.style.backgroundColor = '#d9e1f2';
                            }
                        }
                    }
                });
            });
        }
        
        // C·ªë ƒë·ªãnh N c·ªôt ƒë·∫ßu cho 1 b·∫£ng b·∫•t k·ª≥ (theo id container)
        function applyStickyForTable(wrapperId, stickyCount) {
            const wrapper = document.getElementById(wrapperId);
            if (!wrapper) return;

            const table = wrapper.querySelector("table");
            if (!table || !table.tHead) return;

            requestAnimationFrame(() => {
                const headerRows = Array.from(table.tHead.rows);
                if (!headerRows.length) return;

                const headerRow = headerRows[headerRows.length - 1];

                const tableRect = table.getBoundingClientRect();
                const colLeft = [];

                // T√≠nh left cho t·ª´ng c·ªôt s·∫Ω sticky
                for (let i = 0; i < stickyCount; i++) {
                    const cell = headerRow.cells[i];
                    if (!cell) continue;
                    const rect = cell.getBoundingClientRect();
                    colLeft[i] = rect.left - tableRect.left;
                }

                // X√≥a class sticky c≈© n·∫øu c√≥
                const oldSticky = table.querySelectorAll(".sticky-col");
                oldSticky.forEach((c) => {
                    c.classList.remove("sticky-col");
                    c.style.left = "";
                    c.style.position = "";
                });

                // G√°n l·∫°i sticky cho N c·ªôt ƒë·∫ßu
                const rows = Array.from(table.rows);
                rows.forEach((row) => {
                    for (let i = 0; i < stickyCount; i++) {
                        const cell = row.cells[i];
                        if (!cell) continue;

                        cell.classList.add("sticky-col");
                        cell.style.position = "sticky";
                        cell.style.left = (colLeft[i] || 0) + "px";
                    }
                });
            });
        }

        // √Åp d·ª•ng cho Worst Cell + Cell Non-Traffic (4 c·ªôt ƒë·∫ßu)
        function applyWorstCellStickyColumns() {
    applyStickyForTable("worstCellTable", 4);
    applyStickyForTable("nonTrafficTable", 4);
}

        function applyKpiOverviewTargetVisibility() {
            const wrapper = document.getElementById("excelTable");
            if (!wrapper) return;

            const table = wrapper.querySelector("table");
            if (!table) return;

            const showTarget = globalThresholdEnabled;

            // Header: ch·ªâ h√†ng cu·ªëi c√πng m·ªõi c√≥ c·ªôt Target
            if (table.tHead) {
                const headerRows = Array.from(table.tHead.rows);
                headerRows.forEach((row) => {
                    if (row.cells.length > 3) {
                        const cell = row.cells[3]; // c·ªôt Target
                        if (cell) cell.style.display = showTarget ? "" : "none";
                    }
                });
            }

            // Body: m·ªói row c√≥ c·ªôt [0: KPI Name, 1: KPI ID, 2: Unit, 3: Target, ...]
            Array.from(table.tBodies || []).forEach((tbody) => {
                Array.from(tbody.rows).forEach((row) => {
                    if (row.cells.length > 3) {
                        const cell = row.cells[3];
                        if (cell) cell.style.display = showTarget ? "" : "none";
                    }
                });
            });
        }
        
        // ===== B·ªô l·ªçc gi√° tr·ªã cho b·∫£ng Worst Cell =====
        let worstCellFilterRules   = [];   // [{id, colKey, op, value}, ...]
        let worstCellFilterLogic   = "AND";
        let worstFilterKpiOptions  = [];   // [{colKey, label}]
        let worstFilterUiBound     = false;
        let worstPoFilterValue = "ALL";

        function initWorstFilterEvents() {
            if (worstFilterUiBound) return;

            const logicSelect   = document.getElementById("worstFilterLogic");
            const addBtn        = document.getElementById("worstFilterAddBtn");
            const clearBtn      = document.getElementById("worstFilterClearBtn");
            const provinceInput = document.getElementById("worstProvinceFilter");
            const poSelect      = document.getElementById("worstPoFilter");

            if (!logicSelect || !addBtn || !clearBtn) return;

            // Thay ƒë·ªïi AND / OR
            logicSelect.onchange = (e) => {
                worstCellFilterLogic = e.target.value === "OR" ? "OR" : "AND";
                renderWorstCellTable();
            };

            // Th√™m 1 ƒëi·ªÅu ki·ªán m·ªõi
            addBtn.onclick = () => {
                if (!worstFilterKpiOptions.length) return;

                const firstColKey = worstFilterKpiOptions[0].colKey;
                worstCellFilterRules.push({
                    id: Date.now() + "_" + Math.random().toString(16).slice(2),
                    colKey: firstColKey,
                    op: "<",
                    value: ""
                });
                renderWorstFilterRules();
                renderWorstCellTable();
            };

            // X√≥a to√†n b·ªô ƒëi·ªÅu ki·ªán
            clearBtn.onclick = () => {
                worstCellFilterRules = [];
                renderWorstFilterRules();
                renderWorstCellTable();
            };

            // üîç Province: ƒë·ªïi gi√° tr·ªã ho·∫∑c nh·∫•n Enter s·∫Ω filter Worst Cell
            if (provinceInput) {
                // khi r·ªùi √¥
                provinceInput.addEventListener("change", () => {
                    renderWorstCellTable();
                });

                // nh·∫•n Enter
                provinceInput.addEventListener("keydown", (e) => {
                    if (e.key === "Enter") {
                        e.preventDefault();      // tr√°nh submit form
                        renderWorstCellTable();
                    }
                });
            }

            // üîç PO: ƒë·ªïi gi√° tr·ªã s·∫Ω filter Worst Cell
            if (poSelect) {
                poSelect.addEventListener("change", () => {
                    renderWorstCellTable();
                });
            }

            worstFilterUiBound = true;
        }

        // T·∫°o danh s√°ch KPI cho combobox filter (t·ª´ orderedCols c·ªßa b·∫£ng)
        function initWorstFilterOptionsFromCols(orderedCols) {
            initWorstFilterEvents();

            // KPI: t·ª´ c·ªôt th·ª© 5 tr·ªü ƒëi (b·ªè PO, Province, NRBTS, NRCEL)
            const metricCols = orderedCols.slice(4);

            worstFilterKpiOptions = metricCols.map((colKey) => ({
                colKey,
                label: String(colKey)
            }));

            renderWorstFilterRules();
        }

        // V·∫Ω l·∫°i list ƒëi·ªÅu ki·ªán d∆∞·ªõi thanh filter
        function renderWorstFilterRules() {
            const container = document.getElementById("worstFilterRules");
            if (!container) return;

            container.innerHTML = "";

            if (!worstCellFilterRules.length) {
                const p = document.createElement("div");
                p.style.fontSize = "0.8em";
                p.style.color = "#6b7280";
                p.textContent = "Ch∆∞a c√≥ ƒëi·ªÅu ki·ªán filter.";
                container.appendChild(p);
                return;
            }

            worstCellFilterRules.forEach((rule) => {
                const rowDiv = document.createElement("div");
                rowDiv.style.display = "flex";
                rowDiv.style.gap = "4px";
                rowDiv.style.alignItems = "center";

                // Ch·ªçn KPI
                const kpiSelect = document.createElement("select");
                kpiSelect.style.padding = "4px 6px";
                kpiSelect.style.borderRadius = "6px";
                kpiSelect.style.border = "1px solid #cbd5e1";

                worstFilterKpiOptions.forEach((optInfo) => {
                    const opt = document.createElement("option");
                    opt.value = optInfo.colKey;
                    opt.textContent = optInfo.label;
                    if (optInfo.colKey === rule.colKey) opt.selected = true;
                    kpiSelect.appendChild(opt);
                });
                kpiSelect.onchange = (e) => {
                    rule.colKey = e.target.value;
                    renderWorstCellTable();
                };

                // Ch·ªçn to√°n t·ª≠
                const opSelect = document.createElement("select");
                opSelect.style.padding = "4px 6px";
                opSelect.style.borderRadius = "6px";
                opSelect.style.border = "1px solid #cbd5e1";

                ["<", "<=", ">", ">=", "=", "=="].forEach((op) => {
                    const opt = document.createElement("option");
                    opt.value = op;
                    opt.textContent = op;
                    if (op === rule.op) opt.selected = true;
                    opSelect.appendChild(opt);
                });
                opSelect.onchange = (e) => {
                    rule.op = e.target.value;
                    renderWorstCellTable();
                };

                // Nh·∫≠p gi√° tr·ªã
                // Nh·∫≠p gi√° tr·ªã - ch·ªâ filter khi k·∫øt th√∫c nh·∫≠p (change ho·∫∑c Enter)
                // Nh·∫≠p gi√° tr·ªã - ch·ªâ filter khi k·∫øt th√∫c nh·∫≠p (change ho·∫∑c Enter)
                const valInput = document.createElement("input");
                valInput.type = "number";
                valInput.step = "any";
                valInput.style.padding = "4px 6px";
                valInput.style.width = "90px";
                valInput.style.borderRadius = "6px";
                valInput.style.border = "1px solid #cbd5e1";

                // üëâ G√°n l·∫°i gi√° tr·ªã ƒëang l∆∞u trong rule (n·∫øu c√≥) ƒë·ªÉ hi·ªÉn th·ªã l√™n √¥ input
                valInput.value = rule.value ?? "";

                // Khi ƒëang g√µ th√¨ ch·ªâ l∆∞u value, KH√îNG render l·∫°i b·∫£ng
                valInput.oninput = (e) => {
                    rule.value = e.target.value;
                };

                // Khi ng∆∞·ªùi d√πng r·ªùi kh·ªèi √¥ (blur/change) th√¨ m·ªõi √°p d·ª•ng filter
                valInput.onchange = (e) => {
                    rule.value = e.target.value;
                    renderWorstCellTable();
                };

                // Nh·∫•n Enter c≈©ng √°p d·ª•ng filter ngay
                valInput.onkeydown = (ev) => {
                    if (ev.key === "Enter") {
                        ev.preventDefault();
                        valInput.blur();        // cho trigger onchange
                        renderWorstCellTable();
                    }
                };



                // N√∫t x√≥a ƒëi·ªÅu ki·ªán
                const removeBtn = document.createElement("button");
                removeBtn.type = "button";
                removeBtn.textContent = "‚úï";
                removeBtn.style.padding = "2px 6px";
                removeBtn.style.borderRadius = "6px";
                removeBtn.style.border = "1px solid #ef4444";
                removeBtn.style.background = "#fee2e2";
                removeBtn.style.cursor = "pointer";
                removeBtn.onclick = () => {
                    worstCellFilterRules = worstCellFilterRules.filter((r) => r.id !== rule.id);
                    renderWorstFilterRules();
                    renderWorstCellTable();
                };

                rowDiv.appendChild(kpiSelect);
                rowDiv.appendChild(opSelect);
                rowDiv.appendChild(valInput);
                rowDiv.appendChild(removeBtn);

                container.appendChild(rowDiv);
            });
        }

        // √Åp d·ª•ng filter Province + c√°c ƒëi·ªÅu ki·ªán KPI
        function applyWorstCellValueFilters(rowsArr, orderedCols) {

        // ===== 1. X√ÅC ƒê·ªäNH C·ªòT NRCEL / LNCEL ƒê·ªÇ L·∫§Y PROVINCE =====
            const nrCellColKey =
                orderedCols.find((col) => {
                    const lower = String(col).toLowerCase();
                    return (
                        lower.includes("nrcel")  ||  // 5G: NRCEL / NRCELL
                        lower.includes("nrcell") ||
                        lower.includes("lncel")  ||  // 4G: LNCEL / LNCEL name
                        lower.includes("lncell")
                    );
                }) || null;
        
                // ===== 1b. L·ªåC THEO PO =====
            const poValue =
                (document.getElementById("worstPoFilter")?.value || "ALL").trim();

            let filtered = rowsArr;

            if (poValue && poValue !== "ALL" && typeof getPoProvinceFromRow === "function") {
                filtered = filtered.filter((row) => {
                    const info = getPoProvinceFromRow(row);
                    if (!info || !info.po) return false;
                    return String(info.po).trim() === poValue;
                });
            }

            // ===== 2. L·ªåC PROVINCE =====
            const provinceRaw =
                (document.getElementById("worstProvinceFilter")?.value || "")
                    .trim()
                    .toLowerCase();

             filtered = rowsArr;

            if (provinceRaw && nrCellColKey) {
                const provinceList = provinceRaw
                    .split(";")
                    .map((x) => x.trim().toLowerCase())
                    .filter(Boolean);

                if (provinceList.length) {
                    // Province trong b·∫£ng = 3 k√Ω t·ª± cu·ªëi c·ªßa c·ªôt CELL
                    filtered = filtered.filter((row) => {
                        const cell = String(row[nrCellColKey] || "").trim();
                        const prov = cell.length >= 3
                            ? cell.slice(-3).toLowerCase()
                            : cell.toLowerCase();
                        return provinceList.some((p) => prov.includes(p));
                    });
                }
            }
            // N·∫øu kh√¥ng t√¨m th·∫•y c·ªôt NRCEL/NRCELL th√¨ b·ªè qua filter Province

            // ===== 3. N·∫æU KH√îNG C√ì KPI RULE ‚Üí TR·∫¢ V·ªÄ LU√îN =====
            if (!worstCellFilterRules.length) return filtered;

            // L·ªçc rule h·ª£p l·ªá
            const rules = worstCellFilterRules.filter(
                (r) => r.colKey && r.op && r.value !== ""
            );
            if (!rules.length) return filtered;

            // ===== 4. L·ªåC THEO KPIs =====
            const logic = worstCellFilterLogic === "OR" ? "OR" : "AND";

            function toNum(v) {
                if (v === null || v === undefined || v === "") return null;
                const n = parseFloat(String(v).replace(",", "."));
                return isNaN(n) ? null : n;
            }

            return filtered.filter((row) => {
                let okAny = false;

                for (const r of rules) {
                    const num = toNum(row[r.colKey]);
                    const thr = toNum(r.value);

                    let ok = false;
                    if (num !== null && thr !== null) {
                        if (r.op === "<") ok = num < thr;
                        else if (r.op === "<=") ok = num <= thr;
                        else if (r.op === ">") ok = num > thr;
                        else if (r.op === ">=") ok = num >= thr;
                        else if (r.op === "=" || r.op === "==") ok = num === thr;
                    }

                    if (logic === "AND" && !ok) return false;
                    if (logic === "OR" && ok) okAny = true;
                }

                return logic === "AND" ? true : okAny;
            });
        }

        // === WORST CELL OVERVIEW =======================================
        let worstOverviewData = [];

        // L·∫•y data t·ª´ m·ªôt sheet c√≥ t√™n g·∫ßn gi·ªëng danh s√°ch "hints"
        function getSheetDataByHints(hints) {
            if (!workbook) return [];

            function matchName(name) {
                const lower = String(name || "").toLowerCase();
                return hints.some(h => lower.includes(h));
            }

            let target = null;

            if (mergedDataPerSheet) {
                for (const name of Object.keys(mergedDataPerSheet)) {
                    if (matchName(name)) {
                        target = name;
                        break;
                    }
                }
                if (target) return mergedDataPerSheet[target] || [];
            }

            // fallback: ƒë·ªçc tr·ª±c ti·∫øp t·ª´ workbook
            for (const name of workbook.SheetNames) {
                if (matchName(name)) {
                    target = name;
                    break;
                }
            }
            if (!target) return [];

            const sheet = workbook.Sheets[target];
            if (!sheet) return [];

            return XLSX.utils.sheet_to_json(sheet, { defval: null });
        }

        // L·∫•y PO / T·ªânh t·ª´ 1 d√≤ng (d√πng cho c·∫£ progress / WorstCell / NonTraffic)
        // L·∫•y PO / T·ªânh t·ª´ 1 d√≤ng (d√πng cho c·∫£ Progress / WorstCell / Non-Traffic)
        function getPoProvinceFromRow(row) {
            if (!row) return null;

            // 1) ∆Øu ti√™n c·ªôt PO / T·ªânh c√≥ s·∫µn
            let po =
                row["PO"] || row["Po"] || row["po"] ||
                row["PO "] || row["P0"];

            let province =
                row["T·ªânh"] || row["Tinh"] || row["tinh"] ||
                row["Province"] || row["PROVINCE"] || row["province"];

            // 2) N·∫øu ch∆∞a c√≥ PO -> suy t·ª´ Site Name (NRBTS) d·ª±a v√†o file Ti·∫øn ƒë·ªô
            if (!po && typeof getPoFromProgress === "function") {
                let siteName =
                    row["NRBTS name"] ||
                    row["NRBTS Name"] ||
                    row["NRBTS"] ||
                    row["Site Name"] ||
                    row["SITE NAME"];

                if (!siteName) {
                    for (const key in row) {
                        const lower = String(key).toLowerCase();
                        if (lower.includes("nrbts") || lower.includes("site name")) {
                            siteName = row[key];
                            break;
                        }
                    }
                }

                if (siteName) {
                    const mappedPo = getPoFromProgress(siteName);
                    if (mappedPo) po = mappedPo;
                }
            }

            // 3) N·∫øu ch∆∞a c√≥ T·ªânh -> l·∫•y t·ª´ t√™n cell (NRCEL / LNCEL): 3 k√Ω t·ª± cu·ªëi
            if (!province) {
                let cellName = "";

                for (const key in row) {
                    const lower = String(key).toLowerCase();
                    if (
                        lower.includes("nrcel") ||
                        lower.includes("nrcell") ||
                        lower.includes("lncel") ||
                        lower.includes("lncell")
                    ) {
                        cellName = row[key];
                        if (cellName != null && cellName !== "") break;
                    }
                }

                if (cellName != null) {
                    const s = String(cellName).trim();
                    if (s) {
                        province = s.length >= 3 ? s.slice(-3) : s;
                    }
                }
            }

            if (!po || !province) return null;

            return {
                po: String(po).trim(),
                province: String(province).trim()
            };
        }



        function getStationsFromProgressRow(row) {
            if (!row) return { soTram: 0, onAir: 0 };

            // ∆Øu ti√™n d√πng d·ªØ li·ªáu ƒë√£ g·ªôp: total / onair t·ª´ groupList
            const soTram =
                Number(row.total) ||
                Number(row["T·ªïng tr·∫°m"]) ||
                Number(row["Tong tram"]) ||
                Number(row["S·ªë tr·∫°m"]) ||
                Number(row["So tram"]) ||
                Number(row["Site"]) ||
                0;

            const onAir =
                Number(row.onair) ||
                Number(row["On Air"]) ||
                Number(row["OnAir"]) ||
                Number(row["On_air"]) ||
                Number(row["Tr·∫°m ƒëo ki·ªÉm"]) ||
                0;

            return {
                soTram: isNaN(soTram) ? 0 : soTram,
                onAir: isNaN(onAir) ? 0 : onAir
            };
        }


    // T√≠nh to√°n l·∫°i to√†n b·ªô Worst Cell Overview
    function recomputeWorstCellOverview() {
        const map = new Map(); // key = PO||T·ªânh

        function ensureRow(po, province) {
            const key = po + "||" + province;
            let obj = map.get(key);
            if (!obj) {
                obj = {
                    po,
                    province,
                    soTram: 0,
                    onAir: 0,             // üîπ "S·ªë Cell On-Air" (t√≠nh t·ª´ ti·∫øn ƒë·ªô * 3)
                    worstCssrCount: 0,
                    worstDcrCount: 0,
                    nonTrafficCount: 0
                };
                map.set(key, obj);
            }
            return obj;
        }

        // 1Ô∏è‚É£ Ti·∫øn ƒë·ªô ƒëo ki·ªÉm: l·∫•y S·ªë tr·∫°m + On-Air (s·ªë tr·∫°m) r·ªìi nh√¢n 3 -> S·ªë Cell On-Air
        if (typeof progressFullData !== "undefined" && Array.isArray(progressFullData)) {
            progressFullData.forEach((r) => {
                const info = getPoProvinceFromRow(r);
                if (!info) return;

                const agg = ensureRow(info.po, info.province);
                const s   = getStationsFromProgressRow(r);   // { soTram, onAir, ... }

                const soTram = s.soTram || 0;
                const onAirStation = s.onAir || 0;           // s·ªë TR·∫†M on-air t·ª´ file ti·∫øn ƒë·ªô

                agg.soTram += soTram;
                // ‚úÖ S·ªë Cell On-Air = S·ªë TR·∫†M On-Air √ó 3
                agg.onAir  += onAirStation * 3;
            });
        }

        // Helper: √©p ki·ªÉu s·ªë
        function toNum(v) {
            if (v === null || v === undefined) return NaN;
            const n = parseFloat(String(v).replace(/\s+/g, ""));
            return isNaN(n) ? NaN : n;
        }

        // 2Ô∏è‚É£ Worst Cell: ch·ªâ d√πng ƒë·ªÉ ƒë·∫øm CSSR<95, DCR>3 (KH√îNG c·ªông th√™m On-Air n·ªØa)
        let worstRows = [];
        if (Array.isArray(window._latestWorstTrafficRows) && window._latestWorstTrafficRows.length) {
            // ∆Øu ti√™n d√πng ƒë√∫ng dataset v·ª´a render cho b·∫£ng Worst Cell
            worstRows = window._latestWorstTrafficRows;
        } else {
            // Fallback: ƒë·ªçc tr·ª±c ti·∫øp t·ª´ sheet WorstCell n·∫øu ch∆∞a c√≥
            worstRows = getSheetDataByHints(["worstcell", "worst cell"]);
        }

        worstRows.forEach((r) => {
            const info = getPoProvinceFromRow(r);
            if (!info) return;

            const agg = ensureRow(info.po, info.province);

            // ‚ùå Kh√¥ng c·ªông agg.onAir n·ªØa, v√¨ "S·ªë Cell On-Air" l·∫•y t·ª´ ti·∫øn ƒë·ªô *3

            // --- C√°c KPI d√πng cho ƒëi·ªÅu ki·ªán ---
            const cssr =
                r["NSA call access"] ||
                r["NSA Call access"] ||
                r["NSA CALL ACCESS"];

            const dcr =
                r["NSA Active ERAB drop UserR"] ||
                r["NSA active ERAB drop UserR"] ||
                r["NSA ACTIVE ERAB DROP USERR"];

            // ‚≠ê KPI m·ªõi: E-UTRAN Init E-RAB acc < 95
            const erabInitAcc =
                r["E-UTRAN Init E-RAB acc"] ||
                r["E-utran Init E-RAB acc"] ||
                r["E-UTRAN INIT E-RAB ACC"];

            // ‚≠ê KPI m·ªõi: E-RAB DR RAN > 3
            const erabDrRan =
                r["E-RAB DR RAN"] ||
                r["E-rab DR RAN"] ||
                r["E-RAB Dr RAN"];

            const cssrNum      = toNum(cssr);
            const dcrNum       = toNum(dcr);
            const erabInitNum  = toNum(erabInitAcc);
            const erabDrRanNum = toNum(erabDrRan);

            // üîπ ƒêi·ªÅu ki·ªán t·ªïng h·ª£p cho CSSR
            const cssrFail =
                (!isNaN(cssrNum)     && cssrNum     < 95) ||
                (!isNaN(erabInitNum) && erabInitNum < 95);

            // üîπ ƒêi·ªÅu ki·ªán t·ªïng h·ª£p cho DCR
            const dcrFail =
                (!isNaN(dcrNum)       && dcrNum       > 3) ||
                (!isNaN(erabDrRanNum) && erabDrRanNum > 3);

            if (cssrFail) agg.worstCssrCount++;
            if (dcrFail)  agg.worstDcrCount++;
        });

        // 3Ô∏è‚É£ Non-Traffic: ch·ªâ ƒë·∫øm Non-Traffic, KH√îNG c·ªông th√™m On-Air n·ªØa
        let nonRows = [];
        if (Array.isArray(window._latestWorstNonTrafficRows) && window._latestWorstNonTrafficRows.length) {
            nonRows = window._latestWorstNonTrafficRows;
        } else {
            nonRows = getSheetDataByHints([
                "cell non traffic",
                "cell_non_traffic",
                "non-traffic"
            ]);
        }

        nonRows.forEach((r) => {
            const info = getPoProvinceFromRow(r);
            if (!info) return;
            const agg = ensureRow(info.po, info.province);

            // ‚ùå Kh√¥ng c·ªông agg.onAir n·ªØa
            agg.nonTrafficCount++;
        });

        // 4Ô∏è‚É£ Chuy·ªÉn map -> array & sort theo PO r·ªìi T·ªânh
        worstOverviewData = Array.from(map.values()).sort((a, b) => {
            if (a.po === b.po) {
                return a.province.localeCompare(b.province, "vi");
            }
            return a.po.localeCompare(b.po, "vi");
        });

        // ==== FILL COMBOBOX PO CHO WORST CELL OVERVIEW ====
        const poFilter = document.getElementById("worstOverviewPoFilter");
        if (poFilter) {
            const prevValue = poFilter.value || "ALL";

            // X√≥a & fill l·∫°i option
            poFilter.innerHTML = '<option value="ALL">T·∫•t c·∫£ PO</option>';

            const uniquePO = [...new Set(
                (worstOverviewData || [])
                    .map(r => (r.po || "").trim())
                    .filter(Boolean)
            )];

            uniquePO.forEach((po) => {
                const opt = document.createElement("option");
                opt.value = po;
                opt.textContent = po;
                poFilter.appendChild(opt);
            });

            // Gi·ªØ l·∫°i l·ª±a ch·ªçn c≈© n·∫øu c√≤n t·ªìn t·∫°i
            if (prevValue !== "ALL" && uniquePO.includes(prevValue)) {
                poFilter.value = prevValue;
            } else {
                poFilter.value = "ALL";
            }

            // G·∫Øn event change 1 l·∫ßn
            if (!poFilter._bound) {
                poFilter.addEventListener("change", () => {
                    renderWorstCellOverviewTable();
                });
                poFilter._bound = true;
            }
        }

        renderWorstCellOverviewTable();
    }

        // V·∫Ω b·∫£ng ra HTML
    function renderWorstCellOverviewTable() {
        const card     = document.getElementById("worstOverviewCard");
        const tableDiv = document.getElementById("worstOverviewTable");
        const poSelect = document.getElementById("worstOverviewPoFilter");

        if (!card || !tableDiv || !Array.isArray(worstOverviewData)) return;

        const selectedPo = poSelect ? poSelect.value || "ALL" : "ALL";

        // ===== Chu·∫©n b·ªã d·ªØ li·ªáu theo PO ƒëang ch·ªçn =====
        let rows = [];

        if (selectedPo === "ALL") {
            // G·ªôp theo T·ªàNH, PO hi·ªÉn th·ªã "T·∫•t c·∫£ PO"
            const map = new Map(); // key = province

            worstOverviewData.forEach((r) => {
                const prov = r.province || "";
                let agg = map.get(prov);
                if (!agg) {
                    agg = {
                        po: "T·∫•t c·∫£",
                        province: prov,
                        soTram: 0,
                        onAir: 0,
                        worstCssrCount: 0,
                        worstDcrCount: 0,
                        nonTrafficCount: 0,
                    };
                    map.set(prov, agg);
                }

                agg.soTram          += r.soTram          || 0;
                agg.onAir           += r.onAir           || 0;
                agg.worstCssrCount  += r.worstCssrCount  || 0;
                agg.worstDcrCount   += r.worstDcrCount   || 0;
                agg.nonTrafficCount += r.nonTrafficCount || 0;
            });

            rows = Array.from(map.values());
        } else {
            // L·ªçc ƒë√∫ng 1 PO, v·∫´n hi·ªÉn th·ªã t·ª´ng t·ªânh ri√™ng
            rows = worstOverviewData.filter((r) => r.po === selectedPo);
        }

        if (!rows.length) {
            card.style.display = "none";
            tableDiv.innerHTML = "";
            return;
        }

        // S·∫Øp x·∫øp theo t·ªânh
        rows.sort((a, b) => {
            const pa = (a.province || "").toString();
            const pb = (b.province || "").toString();
            return pa.localeCompare(pb);
        });

        card.style.display = "block";

        // ===== Helper format % =====
        function pctStr(num, den) {
            if (!den) return "-";
            const v = (num / den) * 100;
            return v.toFixed(2) + "%";
        }

        let totalStations = 0;
        let totalOnAir    = 0;
        let totalCssr     = 0;
        let totalDcr      = 0;
        let totalNon      = 0;

        let html = `
            <table class="progress-table">
                <thead>
                    <tr>
                        <th>PO</th>
                        <th>T·ªânh</th>
                        <th>S·ªë tr·∫°m</th>
                        <th>S·ªë Cell On-Air</th>

                        <th>Worst Cell CSSR</th>
                        <th>% Worst Cell CSSR</th>

                        <th>Worst Cell DCR</th>
                        <th>% Worst Cell DCR</th>

                        <th>Non-Traffic Cell</th>
                        <th>% Non-Traffic</th>
                    </tr>
                </thead>
                <tbody>
        `;

        rows.forEach((r) => {
            totalStations += r.soTram          || 0;
            totalOnAir    += r.onAir           || 0;
            totalCssr     += r.worstCssrCount  || 0;
            totalDcr      += r.worstDcrCount   || 0;
            totalNon      += r.nonTrafficCount || 0;

            const cssrPct = pctStr(r.worstCssrCount,  r.onAir);
            const dcrPct  = pctStr(r.worstDcrCount,   r.onAir);
            const nonPct  = pctStr(r.nonTrafficCount, r.onAir);

            html += `
                <tr>
                    <td>${r.po || ""}</td>
                    <td>${r.province || ""}</td>
                    <td>${r.soTram || 0}</td>
                    <td>${r.onAir || 0}</td>

                    <td>${r.worstCssrCount || 0}</td>
                    <td>${cssrPct}</td>

                    <td>${r.worstDcrCount || 0}</td>
                    <td>${dcrPct}</td>

                    <td>${r.nonTrafficCount || 0}</td>
                    <td>${nonPct}</td>
                </tr>
            `;
        });

        // ===== D√≤ng T·ªîNG =====
        const totalCssrPct = pctStr(totalCssr, totalOnAir);
        const totalDcrPct  = pctStr(totalDcr,  totalOnAir);
        const totalNonPct  = pctStr(totalNon,  totalOnAir);

        html += `
            <tr style="font-weight:600; background:#f3f4ff;">
                <td></td>
                <td>T·ªîNG</td>
                <td>${totalStations}</td>
                <td>${totalOnAir}</td>

                <td>${totalCssr}</td>
                <td>${totalCssrPct}</td>

                <td>${totalDcr}</td>
                <td>${totalDcrPct}</td>

                <td>${totalNon}</td>
                <td>${totalNonPct}</td>
            </tr>
        `;

        html += "</tbody></table>";

        tableDiv.innerHTML = html;
    }

        function fillWorstOverviewPO() {
            const poSelect = document.getElementById("worstOverviewPoFilter");
            if (!poSelect) return;

            // L·∫•y danh s√°ch PO t·ª´ worstCellFullRows (ƒë√£ c√≥ PO c·∫≠p nh·∫≠t t·ª´ ti·∫øn ƒë·ªô)
            const uniquePO = [...new Set(worstCellFullRows.map(r => r.__PO).filter(Boolean))];

            poSelect.innerHTML = `<option value="ALL">T·∫•t c·∫£ PO</option>`;
            uniquePO.forEach(po => {
                const opt = document.createElement("option");
                opt.value = po;
                opt.textContent = po;
                poSelect.appendChild(opt);
            });
        }

    function renderWorstCellTable() {
        const worstCard    = document.getElementById("worstCellCard");
        const worstTableEl = document.getElementById("worstCellTable");
        const worstTitleEl = document.getElementById("worstCellTitle");

        const nonCard      = document.getElementById("nonTrafficCard");
        const nonTableEl   = document.getElementById("nonTrafficTable");
        const nonTitleEl   = document.getElementById("nonTrafficTitle");

        // Load ng∆∞·ª°ng WorstCell threshold (sheet "WorstCell Threshold") n·∫øu ch∆∞a load
        if (worstCellThresholdMap === null) {
            ensureWorstCellThresholdsLoaded().then(() => {
                if (worstCard) {
                    // G·ªçi render l·∫°i sau khi ƒë√£ c√≥ ng∆∞·ª°ng
                    renderWorstCellTable();
                }
            });
        }

        if (!worstCard || !worstTableEl || !worstTitleEl) return;
        if (isHeavyKpiFile && (!selectedKpiColumns || selectedKpiColumns.size === 0)) {
            worstCard.style.display = "none";
            worstTableEl.innerHTML = "";
            if (nonCard && nonTableEl) {
                nonCard.style.display = "none";
                nonTableEl.innerHTML = "";
            }
            return;
        }

        let rows = [];

        // ∆Øu ti√™n d·ªØ li·ªáu ƒë√£ merge s·∫µn
        if (typeof mergedDataPerSheet !== "undefined" && mergedDataPerSheet) {
            const worstRows = mergedDataPerSheet["WorstCell"] || [];
            const cellRows  = mergedDataPerSheet["Cell"]      || [];

            rows = []
                .concat(worstRows)
                .concat(cellRows);
        }
        // N·∫øu ch∆∞a c√≥ mergedDataPerSheet ‚Üí ƒë·ªçc tr·ª±c ti·∫øp t·ª´ workbook
        else if (workbook) {
            const worstSheet = workbook.Sheets["WorstCell"];
            const cellSheet  = workbook.Sheets["Cell"];

            if (worstSheet) {
                const r1 = XLSX.utils.sheet_to_json(worstSheet, { defval: null });
                rows = rows.concat(r1);
            }

            if (cellSheet) {
                const r2 = XLSX.utils.sheet_to_json(cellSheet, { defval: null });
                rows = rows.concat(r2);
            }
        }

        if (!rows || !rows.length) {
            worstCard.style.display = "none";
            if (nonCard) nonCard.style.display = "none";
            return;
        }

        const columns = Object.keys(rows[0]);

        // Lo·∫°i b·ªè c√°c c·ªôt r√°c Excel t·ª± sinh (_EMPTY, __EMPTY, __EMPTY_1, ...)
        const ignorePatterns = ["_empty", "__empty"];
        const cleanColumns = columns.filter(col => {
            const lower = String(col).toLowerCase();
            return !ignorePatterns.some(p => lower.includes(p));
        });

        let periodCol = null;
        for (const col of columns) {
            const lower = String(col).toLowerCase();
            if (
                lower.includes("period") ||
                lower.includes("time") ||
                lower.includes("date")
            ) {
                periodCol = col;
                break;
            }
        }

        let nrbtsCol      = null;
        let nrCellCol     = null;
        let availCol      = null;
        let macDlCol      = null; // MAC SDU data vol trans DL DTCH
        let macUlCol      = null; // MAC SDU data vol rcvd UL DTCH
        let traffic5gCol  = null; // 5G Total Traffic Volume

        cleanColumns.forEach(col => {
            const lower = String(col).toLowerCase();

            // NRBTS / LNBTS
            if (!nrbtsCol && (lower.includes("nrbts") || lower.includes("lnbts"))) {
                nrbtsCol = col;
            }

            // NRCEL / NRCELL / LNCEL / LNCELL
            if (
                !nrCellCol &&
                (
                    lower.includes("nrcel")  ||
                    lower.includes("nrcell") ||
                    lower.includes("lncel")  ||
                    lower.includes("lncell")
                )
            ) {
                nrCellCol = col;
            }

            if (!availCol && lower.includes("cell avail")) availCol = col;

            if (!macDlCol && lower.startsWith("mac sdu data vol trans dl dtch")) {
                macDlCol = col;
            }
            if (!macUlCol && lower.startsWith("mac sdu data vol rcvd ul dtch")) {
                macUlCol = col;
            }

            if (!traffic5gCol && lower.includes("5g total traffic volume")) {
                traffic5gCol = col;
            }
        });

        const highlightedKeys = new Set();

        // ƒê√°nh d·∫•u c√°c d√≤ng ƒë∆∞·ª£c t√¥ m√†u trong sheet WorstCell g·ªëc (Excel)
        if (workbook && workbook.Sheets && workbook.Sheets["WorstCell"]) {
            const sheet = workbook.Sheets["WorstCell"];
            const ref = sheet["!ref"];
            if (ref) {
                const range = XLSX.utils.decode_range(ref);
                const headerRow = range.s.r;

                let nrbtsIdx = null;
                let nrCellIdx = null;

                for (let C = range.s.c; C <= range.e.c; C++) {
                    const addr = XLSX.utils.encode_cell({ r: headerRow, c: C });
                    const cell = sheet[addr];
                    if (!cell || cell.v == null) continue;
                    const headerText = String(cell.v).trim();
                    if (headerText === nrbtsCol)  nrbtsIdx = C;
                    if (headerText === nrCellCol) nrCellIdx = C;
                }

                for (let R = headerRow + 1; R <= range.e.r; R++) {
                    let hasColor = false;

                    for (let C = range.s.c; C <= range.e.c; C++) {
                        const addr = XLSX.utils.encode_cell({ r: R, c: C });
                        const cell = sheet[addr];
                        if (!cell || !cell.s || !cell.s.fill) continue;

                        const fill = cell.s.fill;
                        const fg = fill.fgColor || {};
                        const bg = fill.bgColor || {};

                        const hasFg =
                            (fg.rgb && fg.rgb !== "00000000" && fg.rgb !== "FFFFFFFF") ||
                            fg.theme != null ||
                            fg.indexed != null;
                        const hasBg =
                            (bg.rgb && bg.rgb !== "00000000" && bg.rgb !== "FFFFFFFF") ||
                            bg.theme != null ||
                            bg.indexed != null;

                        if (hasFg || hasBg) {
                            hasColor = true;
                            break;
                        }
                    }

                    if (!hasColor) continue;

                    const nrbtsVal = (nrbtsIdx != null
                        ? (sheet[XLSX.utils.encode_cell({ r: R, c: nrbtsIdx })] || {}).v
                        : "") || "";
                    const nrcelVal = (nrCellIdx != null
                        ? (sheet[XLSX.utils.encode_cell({ r: R, c: nrCellIdx })] || {}).v
                        : "") || "";

                    const key = `${String(nrbtsVal).trim()}||${String(nrcelVal).trim()}`;
                    highlightedKeys.add(key);
                }
            }
        }

        function makeRowKey(row) {
            const nrbtsVal = nrbtsCol ? (row[nrbtsCol] || "") : "";
            const nrcelVal = nrCellCol ? (row[nrCellCol] || "") : "";
            return `${String(nrbtsVal).trim()}||${String(nrcelVal).trim()}`;
        }

        function isNumericLike(v) {
            if (v === null || v === undefined) return false;
            const s = String(v).trim().replace(/\s+/g, "");
            return /^-?\d+(\.\d+)?$/.test(s);
        }

        function formatNumberSmart(v) {
            const num = parseFloat(String(v).trim().replace(/\s+/g, ""));
            if (isNaN(num)) return v ?? "";
            const rounded = Math.round(num * 1000) / 1000;
            return Number.isInteger(rounded)
                ? String(rounded)
                : rounded.toFixed(3);
        }

        // X√°c ƒë·ªãnh k·ª≥ g·∫ßn nh·∫•t
        let latestLabel = null;
        let latestSort  = -Infinity;

        if (periodCol) {
            rows.forEach(r => {
                const raw = r[periodCol];
                if (!raw) return;
                const norm = normalizePeriod(raw);
                if (!norm) return;
                if (norm.sortValue > latestSort) {
                    latestSort  = norm.sortValue;
                    latestLabel = norm.label;
                }
            });
        }

        let latestRows = rows;
        if (periodCol && latestLabel) {
            latestRows = rows.filter(r => {
                const raw = r[periodCol];
                if (!raw) return false;
                const norm = normalizePeriod(raw);
                return norm && norm.label === latestLabel;
            });
        }

        if (!latestRows.length) {
            worstCard.style.display = "none";
            if (nonCard) nonCard.style.display = "none";
            return;
        }

        // ===== Ph√¢n lo·∫°i Traffic / Non-Traffic =====
        const trafficRows    = [];
        const nonTrafficRows = [];

        // check MAC SDU = 0
        function isZeroMac(val) {
            if (val === null || val === undefined || val === "") return false;
            const num = parseFloat(String(val).replace(/\s+/g, "").replace(",", "."));
            return !Number.isNaN(num) && num === 0;
        }

        // T√¨m c·ªôt PDCP SDU Volume, DL / UL
        const pdcpDlCol = cleanColumns.find(col => {
            const lower = String(col || "").toLowerCase();
            return lower.includes("pdcp") &&
                lower.includes("sdu") &&
                lower.includes("volume") &&
                lower.includes("dl");
        }) || null;

        const pdcpUlCol = cleanColumns.find(col => {
            const lower = String(col || "").toLowerCase();
            return lower.includes("pdcp") &&
                lower.includes("sdu") &&
                lower.includes("volume") &&
                lower.includes("ul");
        }) || null;


        latestRows.forEach(row => {
            const availRaw = availCol ? row[availCol] : null;
            const availNum = availCol ? toNumber(availRaw) : null;

            // 1Ô∏è‚É£ Cell Avail < 10 -> Non-Traffic
            if (availCol && availNum !== null && availNum < 10) {
                nonTrafficRows.push(row);
                return;
            }

            // 2Ô∏è‚É£ PDCP SDU Volume, DL < 100 ho·∫∑c UL < 100 -> Non-Traffic
            if (pdcpDlCol || pdcpUlCol) {
                let pdcpDlNum = null;
                let pdcpUlNum = null;

                if (pdcpDlCol) {
                    pdcpDlNum = toNumber(row[pdcpDlCol]);
                }
                if (pdcpUlCol) {
                    pdcpUlNum = toNumber(row[pdcpUlCol]);
                }

                const dlLow = pdcpDlNum !== null && pdcpDlNum < 100;
                const ulLow = pdcpUlNum !== null && pdcpUlNum < 100;

                if (dlLow || ulLow) {
                    nonTrafficRows.push(row);
                    return;
                }
            }

            // 3Ô∏è‚É£ 2 KPI MAC SDU DL/UL = 0 -> Non-Traffic (gi·ªØ nguy√™n logic c≈©)
            let moveByMac = false;
            if (macDlCol || macUlCol) {
                const dlVal = macDlCol ? row[macDlCol] : null;
                const ulVal = macUlCol ? row[macUlCol] : null;

                if (macDlCol && macUlCol) {
                    // c·∫£ DL & UL = 0
                    if (isZeroMac(dlVal) && isZeroMac(ulVal)) moveByMac = true;
                } else if (macDlCol) {
                    if (isZeroMac(dlVal)) moveByMac = true;
                } else if (macUlCol) {
                    if (isZeroMac(ulVal)) moveByMac = true;
                }
            }

            if (moveByMac) {
                nonTrafficRows.push(row);
                return;
            }

            // 4Ô∏è‚É£ 5G Total Traffic Volume < 100 -> Non-Traffic (n·∫øu anh v·∫´n mu·ªën gi·ªØ)
            if (traffic5gCol) {
                const trafficVal = toNumber(row[traffic5gCol]);
                if (trafficVal !== null && trafficVal < 100) {
                    nonTrafficRows.push(row);
                    return;
                }
            }

            const hasData = cleanColumns.some(col => {
                if (col === periodCol || col === nrbtsCol || col === nrCellCol || col === availCol) return false;
                const v = row[col];
                return v !== null && v !== "" && !Number.isNaN(parseFloat(v));
            });

            if (!hasData) nonTrafficRows.push(row);
            else trafficRows.push(row);
        });

        // Remove duplicate theo NRBTS + NRCEL
        function deduplicateRows(rowsArr) {
            const seen = new Set();
            const result = [];
            rowsArr.forEach(row => {
                const key = makeRowKey(row); // ƒë√£ ƒë·ªãnh nghƒ©a ·ªü tr√™n
                if (!key) {
                    result.push(row);
                    return;
                }
                if (seen.has(key)) return;
                seen.add(key);
                result.push(row);
            });
            return result;
        }

        // B·∫£n ƒë·∫ßy ƒë·ªß (d√πng cho Overview)
        const trafficRowsDedupAll    = deduplicateRows(trafficRows);
        const nonTrafficRowsDedupAll = deduplicateRows(nonTrafficRows);

        // ===== C·∫≠p nh·∫≠t combobox PO t·ª´ to√†n b·ªô d·ªØ li·ªáu =====
        (function updateWorstPoFilterOptions() {
            const poSelect = document.getElementById("worstPoFilter");
            if (!poSelect || !nrbtsCol) return;

            const poSet = new Set();
            const allRows = trafficRowsDedupAll.concat(nonTrafficRowsDedupAll);

            allRows.forEach((row) => {
                const siteName = row[nrbtsCol] || "";
                const po = typeof getPoFromProgress === "function"
                    ? getPoFromProgress(siteName)
                    : "";
                if (po) poSet.add(String(po));
            });

            const prevValue = poSelect.value || "ALL";

            poSelect.innerHTML = '<option value="ALL">T·∫•t c·∫£ PO</option>';
            Array.from(poSet).sort().forEach((po) => {
                const opt = document.createElement("option");
                opt.value = po;
                opt.textContent = po;
                poSelect.appendChild(opt);
            });

            if (prevValue !== "ALL" && poSet.has(prevValue)) {
                poSelect.value = prevValue;
            } else {
                poSelect.value = "ALL";
            }

            // g·∫Øn event change m·ªôt l·∫ßn
            if (!poSelect._worstBound) {
                poSelect.addEventListener("change", () => {
                    renderWorstCellTable();
                });
                poSelect._worstBound = true;
            }
        })();

        // ===== √Åp d·ª•ng filter theo PO (ch·ªâ ·∫£nh h∆∞·ªüng b·∫£ng hi·ªÉn th·ªã) =====
        function applyPoFilter(rowsArr) {
            const poSelect = document.getElementById("worstPoFilter");
            if (!poSelect || !nrbtsCol) return rowsArr;

            const selectedPo = poSelect.value || "ALL";
            if (!selectedPo || selectedPo === "ALL") return rowsArr;

            return rowsArr.filter((row) => {
                const siteName = row[nrbtsCol] || "";
                const po = typeof getPoFromProgress === "function"
                    ? getPoFromProgress(siteName)
                    : "";
                return po === selectedPo;
            });
        }

        let trafficRowsDedup    = applyPoFilter(trafficRowsDedupAll);
        let nonTrafficRowsDedup = applyPoFilter(nonTrafficRowsDedupAll);

        function toNumber(val) {
            if (val === null || val === undefined) return null;
            const num = parseFloat(String(val).replace(/\s+/g, ""));
            return isNaN(num) ? null : num;
        }

        function buildTable(rowsArr, titleEl, tableEl, baseTitle) {
            if (!rowsArr.length) {
                titleEl.textContent = baseTitle + " (kh√¥ng c√≥ d·ªØ li·ªáu)";
                tableEl.innerHTML = "";
                return;
            }

            const otherCols = cleanColumns.filter(col => {
                const lower = String(col).toLowerCase();
                if (col === periodCol) return false;
                if (col === nrbtsCol) return false;
                if (col === nrCellCol) return false;
                if (col === availCol)  return false;
                if (lower.includes("mrbts")) return false;
                return true;
            });

            const orderedCols = ["__PO", "__province"];
            if (nrbtsCol)  orderedCols.push(nrbtsCol);
            if (nrCellCol) orderedCols.push(nrCellCol);
            if (availCol)  orderedCols.push(availCol);
            orderedCols.push(...otherCols);

            // üî• NEW: n·∫øu l√† b·∫£ng Worst Cell th√¨ apply filter gi√° tr·ªã (KPI + Province)
            let effectiveRows = rowsArr;
            if (baseTitle.startsWith("Worst Cell")) {
                initWorstFilterOptionsFromCols(orderedCols);
                effectiveRows = applyWorstCellValueFilters(rowsArr, orderedCols);

                if (!effectiveRows.length) {
                    titleEl.textContent = baseTitle + " ‚Äì kh√¥ng c√≥ d√≤ng n√†o kh·ªõp filter";
                    tableEl.innerHTML = "";
                    return;
                }
            }

            const kpiAccessName    = "NSA call access";
            const kpiDropName      = "NSA Active ERAB drop UserR";
            const kpiAvailName     = "Cell avail R";
            const kpiSnChangeName  = "SN Init Change Intra-freq SR src gNB";

            function findColKeyByName(displayName) {
                const target = displayName.toLowerCase();
                return orderedCols.find(colKey =>
                    colKey !== "__province" &&
                    String(colKey).toLowerCase() === target
                );
            }

            const kpiAccessColKey   = findColKeyByName(kpiAccessName);
            const kpiDropColKey     = findColKeyByName(kpiDropName);
            const kpiAvailColKey    = findColKeyByName(kpiAvailName);
            const kpiSnChangeColKey = findColKeyByName(kpiSnChangeName);

            const sortedRows = [...effectiveRows].sort((a, b) => {
                const aCell = nrCellCol ? String(a[nrCellCol] ?? "") : "";
                const bCell = nrCellCol ? String(b[nrCellCol] ?? "") : "";
                const provA = aCell.slice(-3);
                const provB = bCell.slice(-3);
                return provA.localeCompare(provB);
            });

            let html = "<table><thead><tr>";
            orderedCols.forEach((colKey, idx) => {
                const isFirst4 = idx < 4;

                let title = colKey;
                if (colKey === "__PO")       title = "PO";
                if (colKey === "__province") title = "Province";

                const thStyle =
                    "background:#203864; color:#fff; padding:6px 8px; " +
                    "border:1px solid #cbd5e1; text-align:center;" +
                    (isFirst4 ? "white-space:nowrap;" : "");
                html += `<th style="${thStyle}">${title}</th>`;
            });
            html += "</tr></thead><tbody>";

            sortedRows.forEach(row => {
                const rowKey = makeRowKey(row);
                const isHighlighted = highlightedKeys.has(rowKey);
                const trStyle = isHighlighted ? ' style="background:#fef3c7;"' : "";

                html += `<tr${trStyle}>`;

                orderedCols.forEach((colKey, idx) => {
                    const isFirst4 = idx < 4;
                    let value;

                    if (colKey === "__province") {
                        const cellVal = nrCellCol ? row[nrCellCol] : "";
                        const str = cellVal == null ? "" : String(cellVal).trim();
                        value = str.length >= 3 ? str.slice(-3) : str;
                    } else if (colKey === "__PO") {
                        const siteName = nrbtsCol ? row[nrbtsCol] : "";
                        value = typeof getPoFromProgress === "function"
                            ? getPoFromProgress(siteName)
                            : "";
                    } else {
                        value = row[colKey];
                    }

                    let display = value == null ? "" : value;
                    if (idx >= 4 && isNumericLike(display)) {
                        display = formatNumberSmart(display);
                    }

                    let condStyle = "";

                    // ∆Øu ti√™n d√πng file c·∫•u h√¨nh sheet "WorstCell Threshold" n·∫øu c√≥
                    if (worstCellThresholdMap && Object.keys(worstCellThresholdMap).length) {
                        let kpiDisplayName = colKey;
                        if (colKey === "__PO")            kpiDisplayName = "PO";
                        else if (colKey === "__province") kpiDisplayName = "Province";

                        const thr = getWorstCellThresholdByName(kpiDisplayName);

                        if (thr && isNumericLike(value)) {
                            const num = toNumber(value);
                            const t   = thr.value;
                            const op  = thr.op;
                            let isBad = false;

                            if (num !== null) {
                                if      (op === "<")  isBad = num <  t;
                                else if (op === ">")  isBad = num >  t;
                                else if (op === "<=") isBad = num <= t;
                                else if (op === ">=") isBad = num >= t;
                                else if (op === "=" || op === "==") isBad = num === t;
                            }

                            if (isBad) {
                                condStyle =
                                    "background:#fee2e2; color:#b91c1c; font-weight:700;";
                            }
                        }
                    }

                    const baseCell =
                        "padding:6px 8px; border:1px solid #e5e7eb; text-align:center;";
                    const extraCell = isFirst4
                        ? " background:#d9e1f2; font-weight:600; white-space:nowrap; text-align:left;"
                        : "";

                    const finalStyle = baseCell + extraCell + condStyle;

                    html += `<td style="${finalStyle}">${display}</td>`;
                });

                html += "</tr>";
            });

            html += "</tbody></table>";
            tableEl.innerHTML = `
                <div style="min-width:100%; max-height:700px; overflow:auto;">
                    ${html}
                </div>
            `;
            titleEl.textContent = baseTitle;

            // Sau khi v·∫Ω xong ‚Üí c·ªë ƒë·ªãnh 4 c·ªôt ƒë·∫ßu cho Worst Cell & Cell Non-Traffic
            if (
                (baseTitle.startsWith("Worst Cell") ||
                baseTitle.startsWith("Cell Non-Traffic")) &&
                typeof applyWorstCellStickyColumns === "function"
            ) {
                setTimeout(applyWorstCellStickyColumns, 0);
            }
        }

        // ===== Render 2 b·∫£ng: Worst Cell & Non-Traffic =====
        const worstTitleText = latestLabel ? `Worst Cell (${latestLabel})` : "Worst Cell";
        worstCard.style.display = "block";
        buildTable(trafficRowsDedup, worstTitleEl, worstTableEl, worstTitleText);

        if (nonCard && nonTableEl && nonTitleEl) {
            if (nonTrafficRowsDedup.length) {
                nonCard.style.display = "block";
                const nonTitleText = "Cell Non-Traffic";
                buildTable(nonTrafficRowsDedup, nonTitleEl, nonTableEl, nonTitleText);
            } else {
                nonCard.style.display = "none";
            }
        }

        // üîÅ Sau khi Worst Cell / Non-Traffic ƒë√£ c·∫≠p nh·∫≠t ƒë·∫ßy ƒë·ªß PO ‚Äì T·ªânh (FULL, kh√¥ng filter PO)
        // -> l∆∞u l·∫°i & c·∫≠p nh·∫≠t b·∫£ng Worst Cell Overview
        window._latestWorstTrafficRows    = trafficRowsDedupAll;
        window._latestWorstNonTrafficRows = nonTrafficRowsDedupAll;
        if (typeof recomputeWorstCellOverview === "function") {
            recomputeWorstCellOverview();
        }
    }


    function loadProvinceAreaFromThresholdWorkbook(wb) {
        provinceAreaMap = {};   // reset map

        const paSheet = wb.Sheets["Province Area"];
        if (!paSheet) {
            console.warn("Kh√¥ng t√¨m th·∫•y sheet 'Province Area' trong KPI Threshhold.xlsx");
            return;
        }

        const paRows = XLSX.utils.sheet_to_json(paSheet, { defval: "" });

        paRows.forEach((r) => {
            const prov   = String(r["Province"] || r["PROVINCE"] || r["Province Code"] || "").trim();
            const area   = String(r["Area"]     || r["AREA"]     || "").trim();
            const target = String(r["Target"]   || r["TARGET"]   || "").trim();   // <= th√™m

            if (!prov) return;

            const key = prov.toUpperCase();
            // L∆∞u c·∫£ Area + Target
            provinceAreaMap[key] = { area, target };
        });

        console.log("Loaded Province Area count =", Object.keys(provinceAreaMap).length);
    }

    // L·∫•y "On Air" c·ªßa file ti·∫øn ƒë·ªô ƒëo ki·ªÉm theo PO + T·ªânh
    function getOnAirFromProgress(poFilter, province) {
        if (!Array.isArray(progressFullData) || !province) return 0;

        let onAirSites = 0;

        progressFullData.forEach((row) => {
            const info = getPoProvinceFromRow(row);
            if (!info) return;

            // L·ªçc theo PO n·∫øu c√≥ ch·ªçn
            if (poFilter && poFilter !== "ALL") {
                if (String(info.po).trim() !== String(poFilter).trim()) return;
            }

            if (String(info.province).trim() !== String(province).trim()) return;

            const s = getStationsFromProgressRow(row);
            onAirSites += s.onAir || 0;
        });

        return onAirSites;
    }   
     
    function getProvinceFromProgress(po) {
        if (!Array.isArray(progressFullData)) return "";

        const key = String(po || "").trim().toUpperCase();
        if (!key) return "";

        for (const row of progressFullData) {
            const p = row.po || row.PO || row["Po"] || "";
            if (String(p).trim().toUpperCase() === key) {
                // tr·∫£ v·ªÅ province g·ªëc t·ª´ ti·∫øn ƒë·ªô
                return (
                    row.province ||
                    row.Province ||
                    row["T·ªânh"] ||
                    row["Tinh"] ||
                    ""
                );
            }
        }
        return "";
    }

    function buildCqiSummaryFromDom() {
        const summaryEl = document.getElementById("cqiSummaryTable");
        const container = document.getElementById("cqiTable");
        if (!summaryEl || !container) return;

        const table = container.querySelector("table");
        if (!table) {
            summaryEl.innerHTML = "";
            return;
        }

        // L·∫•y value filter PO hi·ªán t·∫°i
        const poFilterSelect = document.getElementById("cqiPoFilter");
        const selectedPo = poFilterSelect ? poFilterSelect.value : "ALL";

        // ===== Helper ƒë·ªçc t·ª´ file ti·∫øn ƒë·ªô =====
        function safeGetPoProvince(row) {
            if (typeof getPoProvinceFromRow === "function") {
                return getPoProvinceFromRow(row) || {};
            }
            return {
                po:
                    row.po || row.PO || row["Po"] || "",
                province:
                    row.province ||
                    row.Province ||
                    row["T·ªânh"] ||
                    row["Tinh"] ||
                    row["PROVINCE"] ||
                    ""
            };
        }

        function safeGetStations(row) {
            if (typeof getStationsFromProgressRow === "function") {
                return getStationsFromProgressRow(row) || { soTram: 0, onAir: 0 };
            }
            const v =
                Number(row.onair) ||
                Number(row.OnAir) ||
                Number(row["On Air"]) ||
                Number(row["On_air"]) ||
                Number(row["Tr·∫°m ƒëo ki·ªÉm"]) ||
                0;
            return { soTram: 0, onAir: isNaN(v) ? 0 : v };
        }

        if (
            typeof progressFullData === "undefined" ||
            !Array.isArray(progressFullData) ||
            !progressFullData.length
        ) {
            summaryEl.innerHTML = "";
            return;
        }

        // ===== 1. Gom theo (PO, Province) t·ª´ file ti·∫øn ƒë·ªô =====
        const progressAgg = {}; // key = PO||Province

        progressFullData.forEach((row) => {
            const info = safeGetPoProvince(row);
            let po = (info.po || "").toString().trim();
            let province = (info.province || "").toString().trim();
            if (!po || !province) return;

            // Filter PO khi dropdown ch·ªçn c·ª• th·ªÉ
            if (selectedPo !== "ALL" && po !== selectedPo) return;

            const key = po + "||" + province;
            let agg = progressAgg[key];
            if (!agg) {
                agg = progressAgg[key] = {
                    po,
                    province,
                    onAir: 0,
                    badCount: 0
                };
            }

            const s = safeGetStations(row);
            agg.onAir += s.onAir || 0;
        });

        const keys = Object.keys(progressAgg);
        if (!keys.length) {
            summaryEl.innerHTML = "";
            return;
        }

        // Map PO -> list key (PO,Province)
        const poToKeys = {};
        keys.forEach((k) => {
            const agg = progressAgg[k];
            if (!poToKeys[agg.po]) poToKeys[agg.po] = [];
            poToKeys[agg.po].push(k);
        });

        // ===== 2. ƒê·ªçc b·∫£ng CQI ƒë·ªÉ c·ªông Bad Cell =====
        const headerCells = table.querySelectorAll("thead tr:last-child th");
        if (!headerCells.length) {
            summaryEl.innerHTML = "";
            return;
        }

        const idx = {};
        headerCells.forEach((th, i) => {
            const name = th.textContent.trim();
            idx[name] = i;
        });

        const poIdx      = idx["PO"];
        const provIdxCqi = idx["Province"];   // ch·ªâ ƒë·ªÉ map, kh√¥ng hi·ªÉn th·ªã
        const evalIdx    = idx["Evaluate"];

        if (poIdx == null || evalIdx == null) {
            summaryEl.innerHTML = "";
            return;
        }

        const bodyRows = table.querySelectorAll("tbody tr");
        bodyRows.forEach((tr) => {
            const cells = tr.querySelectorAll("td");
            if (cells.length <= evalIdx) return;

            const poText =
                cells[poIdx] ? cells[poIdx].textContent.trim() : "";
            if (!poText) return;

            if (selectedPo !== "ALL" && poText !== selectedPo) return;

            const evalText = cells[evalIdx].textContent.trim();
            if (!/not\s*pass/i.test(evalText)) return; // ch·ªâ cell kh√¥ng ƒë·∫°t

            const cqiProvText =
                provIdxCqi != null && cells.length > provIdxCqi
                    ? cells[provIdxCqi].textContent.trim()
                    : "";

            const poKeys = poToKeys[poText] || [];
            if (!poKeys.length) return;

            // T√¨m key kh·ªõp nh·∫•t v·ªõi Province trong CQI
            let chosenKey = null;
            const cqiProvUpper = cqiProvText.toUpperCase();

            for (const k of poKeys) {
                const agg = progressAgg[k];
                if (!agg || !agg.province) continue;
                if (!cqiProvUpper || agg.province.toUpperCase() === cqiProvUpper) {
                    chosenKey = k;
                    break;
                }
            }

            if (!chosenKey) {
                chosenKey = poKeys[0]; // fallback: l·∫•y t·ªânh ƒë·∫ßu ti√™n c·ªßa PO
            }

            if (chosenKey && progressAgg[chosenKey]) {
                progressAgg[chosenKey].badCount += 1;
            }
        });

        // ===== 3. N·∫øu ch·ªçn T·∫§T C·∫¢: g·ªôp l·∫°i theo Province =====
        let groups;
        if (selectedPo === "ALL") {
            const provinceAgg = {}; // key = Province

            Object.values(progressAgg).forEach((g) => {
                const provKey = g.province || "";
                if (!provKey) return;

                let agg = provinceAgg[provKey];
                if (!agg) {
                    agg = provinceAgg[provKey] = {
                        po: "ALL",
                        province: g.province,
                        onAir: 0,
                        badCount: 0
                    };
                }

                agg.onAir   += g.onAir   || 0;
                agg.badCount += g.badCount || 0;
            });

            groups = Object.values(provinceAgg);
        } else {
            // Ch·ªçn PO c·ª• th·ªÉ -> gi·ªØ theo (PO,Province)
            groups = Object.values(progressAgg);
        }

        if (!groups.length) {
            summaryEl.innerHTML = "";
            return;
        }

        // S·∫Øp x·∫øp theo Province
        groups.sort((a, b) =>
            String(a.province).localeCompare(String(b.province))
        );

        // ===== 4. Render =====
        let html = '<table class="progress-table">';
        html += "<thead><tr>";
        html += "<th>PO</th>";
        html += "<th>Province</th>";
        html += "<th>Area</th>";
        html += "<th>Target</th>";
        html += "<th>Total Cell</th>";
        html += "<th>Bad Cell</th>";
        html += "<th>Poor Cell (%)</th>";
        html += "<th>Evaluate</th>";
        html += "</tr></thead><tbody>";

        groups.forEach((g) => {
            const total = g.onAir * 3;              // Total Cell = OnAir * 3
            const bad   = g.badCount || 0;
            const poorPct = total ? (bad * 100) / total : 0;

            // L·∫•y Area & Target t·ª´ provinceAreaMap theo Province
            let areaText   = "";
            let targetRaw  = "";
            let targetValue = null;

            if (provinceAreaMap && g.province) {
                const keyProv = g.province.toUpperCase().trim();
                const entry = provinceAreaMap[keyProv];
                if (entry) {
                    if (typeof entry === "string") {
                        targetRaw = entry;
                    } else {
                        targetRaw =
                            entry.target || entry.Target || "";
                        areaText =
                            entry.area || entry.Area || "";
                    }
                    const m = targetRaw.match(/(\d+(\.\d+)?)\s*%/);
                    if (m) targetValue = parseFloat(m[1]);
                }
            }

            let evaluate = "Pass";
            if (targetValue !== null && poorPct >= targetValue) {
                evaluate = "Not Pass";
            }

            const evalStyle =
                evaluate === "Not Pass"
                    ? "color:#b91c1c; font-weight:bold;"
                    : "color:#15803d; font-weight:bold;";

            const poDisplay =
                selectedPo === "ALL" ? "T·∫•t c·∫£" : g.po;

            html += "<tr>";
            html += `<td>${poDisplay}</td>`;
            html += `<td>${g.province}</td>`;
            html += `<td>${areaText}</td>`;
            html += `<td>${targetRaw}</td>`;
            html += `<td>${total}</td>`;
            html += `<td>${bad}</td>`;
            html += `<td>${poorPct.toFixed(2)}%</td>`;
            html += `<td style="${evalStyle}">${evaluate}</td>`;
            html += "</tr>";
        });

        html += "</tbody></table>";
        summaryEl.innerHTML = html;
    }


    async function renderCqiTable() {
        const card    = document.getElementById("cqiCard");
        const tableEl = document.getElementById("cqiTable");
        if (!card || !tableEl) return;

        tableEl.innerHTML = "";

        // ===== Checkbox Not Pass: g·∫Øn listener 1 l·∫ßn =====
        const notPassCheckbox = document.getElementById("cqiShowNotPassOnly");
        if (notPassCheckbox && !notPassCheckbox._cqiBound) {
            notPassCheckbox.addEventListener("change", () => {
                renderCqiTable();
            });
            notPassCheckbox._cqiBound = true;
        }
        const filterNotPass = notPassCheckbox ? notPassCheckbox.checked : false;

        // ===== Combobox filter PO =====
        const poFilterEl = document.getElementById("cqiPoFilter");
        if (poFilterEl && !poFilterEl._cqiBound) {
            poFilterEl.addEventListener("change", () => {
                renderCqiTable();
            });
            poFilterEl._cqiBound = true;
        }
        const selectedPo = poFilterEl ? (poFilterEl.value || "ALL") : "ALL";

        // Kh√¥ng c√≥ d·ªØ li·ªáu => ·∫©n section
        if (
            !workbook &&
            !(typeof mergedDataPerSheet !== "undefined" && mergedDataPerSheet)
        ) {
            card.style.display = "none";
            return;
        }

        let rows = [];

        // 1Ô∏è‚É£ N·∫øu c√≥ helper getSheetDataByHints (ƒë√£ d√πng cho WorstCell Overview)
        if (typeof getSheetDataByHints === "function") {
            // ∆Øu ti√™n sheet c√≥ t√™n ch·ª©a "worstcell" ho·∫∑c "worst cell"
            rows = getSheetDataByHints(["worstcell", "worst cell"]);

            // N·∫øu kh√¥ng c√≥ -> th·ª≠ sheet ch·ª©a ch·ªØ "cell"
            if (!rows || !rows.length) {
                rows = getSheetDataByHints(["cell"]);
            }

            // N·∫øu v·∫´n kh√¥ng c√≥ -> fallback nh∆∞ c≈© sang sheet CQI
            if (!rows || !rows.length) {
                if (
                    typeof mergedDataPerSheet !== "undefined" &&
                    mergedDataPerSheet &&
                    mergedDataPerSheet["CQI"]
                ) {
                    rows = mergedDataPerSheet["CQI"];
                } else if (workbook && workbook.Sheets && workbook.Sheets["CQI"]) {
                    const sheet = workbook.Sheets["CQI"];
                    rows = XLSX.utils.sheet_to_json(sheet, { defval: "" });
                }
            }
        } else {
            // 2Ô∏è‚É£ Tr∆∞·ªùng h·ª£p kh√¥ng c√≥ getSheetDataByHints (fallback an to√†n)
            if (
                typeof mergedDataPerSheet !== "undefined" &&
                mergedDataPerSheet &&
                (mergedDataPerSheet["WorstCell"] || mergedDataPerSheet["Cell"])
            ) {
                rows =
                    mergedDataPerSheet["WorstCell"] ||
                    mergedDataPerSheet["Cell"] ||
                    [];
            } else if (workbook && workbook.Sheets) {
                if (workbook.Sheets["WorstCell"]) {
                    rows = XLSX.utils.sheet_to_json(
                        workbook.Sheets["WorstCell"],
                        { defval: "" }
                    );
                } else if (workbook.Sheets["Cell"]) {
                    rows = XLSX.utils.sheet_to_json(
                        workbook.Sheets["Cell"],
                        { defval: "" }
                    );
                } else if (workbook.Sheets["CQI"]) {
                    // fallback cu·ªëi c√πng
                    rows = XLSX.utils.sheet_to_json(
                        workbook.Sheets["CQI"],
                        { defval: "" }
                    );
                }
            }
        }

        if (!rows || !rows.length) {
            card.style.display = "none";
            return;
        }

        // ===== T√≠nh ng√†y g·∫ßn nh·∫•t t·ª´ d·ªØ li·ªáu CQI =====
        // ===== Ng√†y d·ªØ li·ªáu CQI g·∫ßn nh·∫•t t·ª´ SHEET "CQI" (file KPI) =====
        let latestDateStr = "";
        let latestDateObj = null;

        // T√¨m t√™n c·ªôt ng√†y (∆∞u ti√™n c√≥ ch·ªØ 'period')
        const firstRow = rows[0] || {};
        let dateColName = null;
        Object.keys(firstRow).forEach((k) => {
            const lower = String(k).toLowerCase();
            if (!dateColName && lower.includes("period")) {
                dateColName = k;
            }
        });
        // fallback n·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c
        if (!dateColName) {
            dateColName = "Period start time";
        }

        rows.forEach((r) => {
            const raw = r[dateColName];
            if (raw === undefined || raw === null || raw === "") return;

            let d = null;

            if (raw instanceof Date) {
                d = raw;
            } else if (typeof raw === "number") {
                // Excel serial date -> JS Date
                try {
                    const parsed = XLSX.SSF.parse_date_code(raw);
                    if (parsed) {
                        d = new Date(
                            parsed.y,
                            parsed.m - 1,
                            parsed.d,
                            parsed.H || 0,
                            parsed.M || 0,
                            parsed.S || 0
                        );
                    }
                } catch (e) {
                    // ignore
                }
            } else {
                const parsed = new Date(raw);
                if (!isNaN(parsed.getTime())) {
                    d = parsed;
                }
            }

            if (d) {
                if (!latestDateObj || d.getTime() > latestDateObj.getTime()) {
                    latestDateObj = d;
                }
            }
        });

        if (latestDateObj) {
            const yyyy = latestDateObj.getFullYear();
            const mm   = String(latestDateObj.getMonth() + 1).padStart(2, "0");
            const dd   = String(latestDateObj.getDate()).padStart(2, "0");
            latestDateStr = `${yyyy}-${mm}-${dd}`;
        }
        // üîπ L·ªåC rows ch·ªâ gi·ªØ c√°c d√≤ng c·ªßa ng√†y g·∫ßn nh·∫•t
        if (latestDateObj && dateColName) {
            const latestY = latestDateObj.getFullYear();
            const latestM = latestDateObj.getMonth();
            const latestD = latestDateObj.getDate();

            rows = rows.filter((r) => {
                const raw = r[dateColName];
                if (raw === undefined || raw === null || raw === "") return false;

                let d = null;

                if (raw instanceof Date) {
                    d = raw;
                } else if (typeof raw === "number") {
                    // Excel serial date -> JS Date
                    try {
                        const parsed = XLSX.SSF.parse_date_code(raw);
                        if (parsed) {
                            d = new Date(
                                parsed.y,
                                parsed.m - 1,
                                parsed.d,
                                parsed.H || 0,
                                parsed.M || 0,
                                parsed.S || 0
                            );
                        }
                    } catch (e) {
                        // ignore
                    }
                } else {
                    const parsed = new Date(raw);
                    if (!isNaN(parsed.getTime())) {
                        d = parsed;
                    }
                }

                if (!d) return false;

                return (
                    d.getFullYear() === latestY &&
                    d.getMonth()    === latestM &&
                    d.getDate()     === latestD
                );
            });
        }


        // ===== Build danh s√°ch PO cho combobox =====
        const poSet = new Set();
        rows.forEach((r) => {
            const lnbts = String(
                r["LNBTS Name"] ??
                r["LNBTS name"] ??
                r["Site Name"] ??
                ""
            ).trim();

            if (!lnbts) return;

            let po = "";
            if (typeof getPoFromProgress === "function") {
                po = getPoFromProgress(lnbts) || "";
            }
            if (po) poSet.add(po);
        });

        if (poFilterEl) {
            const currentVal = selectedPo || "ALL";
            poFilterEl.innerHTML = '<option value="ALL">T·∫•t c·∫£</option>';

            Array.from(poSet)
                .sort()
                .forEach((p) => {
                    const opt = document.createElement("option");
                    opt.value = p;
                    opt.textContent = p;
                    poFilterEl.appendChild(opt);
                });

            // Gi·ªØ l·∫°i l·ª±a ch·ªçn tr∆∞·ªõc ƒë√≥ n·∫øu c√≤n t·ªìn t·∫°i
            if (poFilterEl.querySelector(`option[value="${currentVal}"]`)) {
                poFilterEl.value = currentVal;
            } else {
                poFilterEl.value = "ALL";
            }
        }

        // ===== Render b·∫£ng =====
        let html = "";
        html += '<div style="max-height:700px;overflow:auto;">';
        html += '<table class="progress-table">';
        html += "<thead><tr>";
        html += "<th>PO</th>";
        html += "<th>Province</th>";
        html += "<th>Area</th>";
        html += "<th>LNBTS name</th>";
        html += "<th>LNCEL name</th>";
        html += "<th>Config</th>";
        html += "<th>Average CQI</th>";
        html += "<th>Target</th>";
        html += "<th>Evaluate</th>";
        html += "</tr></thead><tbody>";

        rows.forEach((r) => {
            const lnbts = String(
                r["LNBTS Name"] ??
                r["LNBTS name"] ??
                r["Site Name"] ??
                ""
            ).trim();

            const lncel = String(
                r["LNCEL name"] ??
                r["LNCEL Name"] ??
                ""
            ).trim();

            // Average CQI: ch·ªâ l·∫•y d√≤ng c√≥ gi√° tr·ªã s·ªë, v√† l√†m tr√≤n 3 ch·ªØ s·ªë th·∫≠p ph√¢n
            const avgRaw    = r["Average CQI"] ?? r["Average CQI "] ?? "";
            const avgNumRaw = Number(avgRaw);
            if (isNaN(avgNumRaw)) {
                // B·ªè qua c√°c d√≤ng kh√¥ng c√≥ Average CQI h·ª£p l·ªá (h√†ng t·ªïng / ghi ch√∫...)
                return;
            }
            const avgNum = Math.round(avgNumRaw * 1000) / 1000;
            const avgCqi = avgNum.toFixed(3);

            // Province = 3 k√Ω t·ª± cu·ªëi LNCEL (sau khi trim ƒë·ªÉ b·ªè kho·∫£ng tr·∫Øng)
            const lncelTrim = (lncel || "").trim();
            const province =
                lncelTrim && lncelTrim.length >= 3
                    ? lncelTrim.slice(-3).toUpperCase()
                    : "";

            // PO = vlookup theo LNBTS t·ª´ file ti·∫øn ƒë·ªô (CQT-SSV)
            let po = "";
            if (typeof getPoFromProgress === "function" && lnbts) {
                po = getPoFromProgress(lnbts) || "";
            }

            // L·ªçc theo PO n·∫øu combobox ch·ªçn kh√°c "ALL"
            if (selectedPo !== "ALL" && po !== selectedPo) {
                return;
            }


            // Area = vlookup Province -> Area t·ª´ KPI Threshhold (sheet "Province Area")
            let area = "";
            if (province && provinceAreaMap && Object.keys(provinceAreaMap).length) {
                const pKey = province.toUpperCase().trim();

                const direct = provinceAreaMap[pKey];
                if (direct) {
                    area = typeof direct === "string" ? direct : (direct.area || "");
                }

                // fallback: duy·ªát to√†n b·ªô key
                if (!area) {
                    for (const k in provinceAreaMap) {
                        if (!Object.prototype.hasOwnProperty.call(provinceAreaMap, k)) continue;
                        if (k.trim().toUpperCase() === pKey) {
                            const e = provinceAreaMap[k];
                            area = typeof e === "string" ? e : (e.area || "");
                            break;
                        }
                    }
                }
            }

            // debug 1 d√≤ng ƒë·∫ßu ti√™n ƒë·ªÉ ch·∫Øc ƒÉn
            if (!window.__cqiAreaDebugLogged && province) {
                console.log("CQI row province =", province, " => area =", area);
                window.__cqiAreaDebugLogged = true;
            }

            // ID = mid(LNCEL NAME,10,3)  (v·ªã tr√≠ 10-12 => index 9..11)
            let id = "";
            if (lncel && lncel.length >= 12) {
                id = lncel.substring(9, 12).toUpperCase();
            }

            let config        = "";
            let targetNum     = null;
            let targetDisplay = "";

            if (id && cqiConfigMap && cqiConfigMap[id]) {
                config = cqiConfigMap[id].config || "";

                const rawTarget = cqiConfigMap[id].target;
                const tNumRaw   = Number(rawTarget);
                if (!isNaN(tNumRaw)) {
                    targetNum     = Math.round(tNumRaw * 10) / 10;
                    targetDisplay = targetNum.toFixed(1);
                }
            }

            // ƒê√°nh gi√°: Average CQI >= Target => Pass, ng∆∞·ª£c l·∫°i Not Pass
            let evaluate = "";
            let evalStyle = "";

            if (targetNum !== null) {
                const isPass = avgNum >= targetNum;
                evaluate = isPass ? "Pass" : "Not Pass";

                if (!isPass) {
                    evalStyle = "background:#fee2e2; color:#b91c1c; font-weight:700;";
                }
            }

            // N·∫øu checkbox b·∫≠t ‚Üí ch·ªâ gi·ªØ Not Pass
            if (filterNotPass && evaluate !== "Not Pass") {
                return;
            }

            html += "<tr>";
            html += "<td>" + (po || "") + "</td>";
            html += "<td>" + (province || "") + "</td>";
            html += "<td>" + (area || "") + "</td>";
            html += "<td>" + (lnbts || "") + "</td>";
            html += "<td>" + (lncel || "") + "</td>";
            html += "<td>" + (config || "") + "</td>";
            html += "<td>" + avgCqi + "</td>";
            html += "<td>" + (targetDisplay || "") + "</td>";
            html += `<td style="${evalStyle}">${evaluate}</td>`;
            html += "</tr>";
        });

        html += "</tbody></table></div>";


        // Render b·∫£ng CQI
        tableEl.innerHTML  = html;
        card.style.display = "block";
        
        // C·∫≠p nh·∫≠t ti√™u ƒë·ªÅ section CQI
        const titleEl = document.getElementById("cqiTitle");
        if (titleEl) {
            titleEl.textContent = latestDateStr
                ? `CQI (${latestDateStr})`
                : "CQI";
        }

        // ============================================
        // SAU KHI render xong b·∫£ng CQI m·ªõi load Province Area
        // ============================================
        const needProvinceArea =
            !provinceAreaMap || !Object.keys(provinceAreaMap).length;

        if (needProvinceArea && typeof ensureKpiThresholdsLoaded === "function") {
            ensureKpiThresholdsLoaded()
                .then(() => {
                    if (
                        card &&
                        card.style.display !== "none" &&
                        provinceAreaMap &&
                        Object.keys(provinceAreaMap).length
                    ) {
                        renderCqiTable();
                    }
                })
                .catch((e) => {
                    console.warn(
                        "Kh√¥ng load ƒë∆∞·ª£c KPI Threshhold sau khi render CQI:",
                        e
                    );
                });
        }
        if (provinceAreaMap && Object.keys(provinceAreaMap).length) {
            buildCqiSummaryFromDom();
        }

    }
        
    function renderLatestKpiTable() {
        const tableCard = document.getElementById("latestTableCard");
        const tableDiv = document.getElementById("latestTable");
        const titleEl = document.getElementById("latestTableTitle");


        if (!tableCard || !tableDiv || !titleEl) return;
        if (!currentData || !currentData.length || !periodColumnName) {
            tableCard.style.display = "none";
            return;
        }

        // N·∫øu ch∆∞a load KPI Threshhold th√¨ trigger load & render l·∫°i sau khi xong
        if (kpiThresholdMap === null) {
            ensureKpiThresholdsLoaded().then(() => {
                if (tableCard && tableCard.style.display !== "none") {
                    renderLatestKpiTable();
                }
            });
        }

        const latestLabel = getLatestPeriodLabel(currentData);
        if (!latestLabel) {
            tableCard.style.display = "none";
            return;
        }

        const activeKpiCols = numericColumns.filter((col) =>
            selectedKpiColumns.has(col)
        );

        if (!activeKpiCols.length) {
            titleEl.textContent = `B·∫£ng KPI th·ªùi ƒëi·ªÉm g·∫ßn nh·∫•t (${latestLabel}) ‚Äì kh√¥ng c√≥ KPI n√†o ƒë∆∞·ª£c ch·ªçn`;
            tableDiv.innerHTML = "";
            tableCard.style.display = "block";
            return;
        }

        const periodCol = periodColumnName;
        const wsNameCol = getCellNameColumn(); // üëâ B·∫£ng ‚ÄúKPI th·ªùi ƒëi·ªÉm g·∫ßn nh·∫•t‚Äù c≈©ng theo CELL_NAME

        const byWs = {};

        currentData.forEach((row) => {
            const wsName = row[wsNameCol];
            const rawPeriod = row[periodCol];
            if (!wsName || rawPeriod === undefined || rawPeriod === null) return;

            const norm = normalizePeriod(rawPeriod);
            if (!norm || norm.label !== latestLabel) return;

            const wsStr = String(wsName);
            const wsLower = wsStr.toLowerCase();

            if (!wsPassesTextFilters(wsLower)) return;
            if (wsFilterValues && wsFilterValues.size > 0 && !wsFilterValues.has(wsStr))
                return;

            if (!byWs[wsStr]) byWs[wsStr] = {};

            activeKpiCols.forEach((col) => {
                const v = row[col];
                const num = parseFloat(v);
                if (!isNaN(num)) {
                    const scale = getKpiScaleForColumn(col);
                    byWs[wsStr][col] = num * scale;
                }
            });
        });

        const wsList = Object.keys(byWs).sort();
        if (wsList.length === 0) {
            titleEl.textContent = `B·∫£ng KPI th·ªùi ƒëi·ªÉm g·∫ßn nh·∫•t (${latestLabel}) ‚Äì kh√¥ng c√≥ d·ªØ li·ªáu kh·ªõp b·ªô l·ªçc`;
            tableDiv.innerHTML = "";
            tableCard.style.display = "block";
            return;
        }

        titleEl.textContent = `B·∫£ng KPI th·ªùi ƒëi·ªÉm g·∫ßn nh·∫•t (${latestLabel})`;

        // T·∫°o b·∫£ng v√† b·ªçc trong wrapper ƒë·ªÉ c√≥ scroll d·ªçc + c·ªë ƒë·ªãnh header/c·ªôt 1
        let html = '<table id="latestKpiTable"><thead><tr>';
        html +=
            '<th style="background:#1f2937; color:#fff; padding:6px 8px; border:1px solid #e5e7eb;">Name</th>';
        activeKpiCols.forEach((col) => {
            html += `<th style="background:#4b5563; color:#fff; padding:6px 8px; border:1px solid #e5e7eb;">${col}</th>`;
        });
        html += "</tr></thead><tbody>";

        wsList.forEach((ws) => {
            html += `<tr><td style="padding:6px 8px; border:1px solid #e5e7eb; background:#f9fafb; font-weight:600; white-space:nowrap;">${ws}</td>`;
            activeKpiCols.forEach((col) => {
                const v = byWs[ws][col];
                let display = "";
                if (typeof v === "number" && !isNaN(v)) {
                    display = Math.round(v * 1000) / 1000;
                }

                // ==== √Åp d·ª•ng ng∆∞·ª°ng t·ª´ KPI Threshhold ====
                let condStyle = "";
                if (typeof v === "number" && !isNaN(v) && kpiThresholdMap) {
                    const thr = getThresholdForKpiColumn(col);
                    if (thr) {
                        const num = v;
                        const t = thr.value;
                        const op = thr.op;
                        let isBad = false;

                        if (op === "<") {
                            isBad = num < t;
                        } else if (op === ">") {
                            isBad = num > t;
                        } else if (op === "<=") {
                            isBad = num <= t;
                        } else if (op === ">=") {
                            isBad = num >= t;
                        } else if (op === "=" || op === "==") {
                            isBad = num === t;
                        }

                        // N·∫øu vi ph·∫°m ƒëi·ªÅu ki·ªán ‚áí t√¥ ƒë·ªè
                        if (isBad) {
                            condStyle =
                                "background:#fee2e2; color:#b91c1c; font-weight:700;";
                        }
                    }
                }

                const baseStyle =
                    "padding:6px 8px; border:1px solid #e5e7eb; text-align:center;";
                html += `<td style="${baseStyle}${condStyle}">${display}</td>`;
            });
            html += "</tr>";
        });

        html += "</tbody></table>";
        tableDiv.innerHTML = `<div id="latestTableWrapper">${html}</div>`;
        tableCard.style.display = "block";
    }

        async function handleEmailSubmit(e) {
            e.preventDefault();

            const to = document.getElementById("emailTo").value.trim();
            const subject = document
                .getElementById("emailSubject")
                .value.trim();
            const message = document
                .getElementById("emailMessage")
                .value.trim();
            const statusEl = document.getElementById("emailStatus");
            const submitBtn = e.target.querySelector(
                'button[type="submit"]'
            );

            statusEl.textContent = "‚è≥ ƒêang g·ª≠i email...";
            statusEl.className = "email-status";
            submitBtn.disabled = true;

            try {
                const res = await fetch("/api/send-mail", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ to, subject, message }),
                });

                const data = await res.json();
                if (!res.ok) {
                    throw new Error(data.error || "G·ª≠i mail th·∫•t b·∫°i");
                }

                statusEl.textContent = "‚úÖ G·ª≠i email th√†nh c√¥ng!";
                statusEl.className = "email-status success";
            } catch (err) {
                statusEl.textContent = "‚ùå L·ªói: " + err.message;
                statusEl.className = "email-status error";
            } finally {
                submitBtn.disabled = false;
            }
        }

        const emailForm = document.getElementById("emailForm");
        if (emailForm) {
            emailForm.addEventListener("submit", handleEmailSubmit);
        }
        const exportEmlChartsBtn = document.getElementById("exportEmlChartsBtn");
        
        if (exportEmlChartsBtn) {
            exportEmlChartsBtn.addEventListener(
                "click",
                handleExportEmlWithCharts
            );
        }

                // ====== DEFAULT SUBJECT & EMAIL LIST ======
        const DEFAULT_EMAIL_SUBJECT =
            "[NET_ ____] B√°o c√°o KPI D/a NSN ___ khu v·ª±c Mi·ªÅn Nam";

        const DEFAULT_EMAIL_TO = "huylt@vnpt-technology.vn";

        // G√°n default cho Danh s√°ch email n·∫øu ƒëang tr·ªëng
        const emailToEl = document.getElementById("emailTo");
        if (emailToEl && !emailToEl.value.trim()) {
            emailToEl.value = DEFAULT_EMAIL_TO;
        }

        // G√°n default cho Ti√™u ƒë·ªÅ email n·∫øu ƒëang tr·ªëng
        const emailSubjectEl = document.getElementById("emailSubject");
        if (emailSubjectEl && !emailSubjectEl.value.trim()) {
            emailSubjectEl.value = DEFAULT_EMAIL_SUBJECT;
        }

        // ƒê√°nh d·∫•u khi user t·ª± ch·ªânh s·ª≠a n·ªôi dung m·ªü ƒë·∫ßu email
        const emailMessageEl = document.getElementById("emailMessage");
        if (emailMessageEl) {
            emailMessageEl.addEventListener("input", () => {
                emailIntroTouched = true;
            });
        }


        // T·ª± ƒë·ªông fill n·ªôi dung email: ch·ªâ load template (c√≥ placeholder), KH√îNG thay b·∫±ng s·ªë li·ªáu
        function fillDefaultEmailText() {
    const textarea = document.getElementById("emailMessage");
    if (!textarea) return;

    // N·∫øu user ƒë√£ g√µ s·ª≠a trong phi√™n n√†y th√¨ kh√¥ng ƒë√® n·ªØa
    if (emailIntroTouched) return;

    // 1. L·∫•y template t·ª´ localStorage (n·∫øu c√≥)
    let template = "";
    try {
        const saved = localStorage.getItem("emailConfig");
        if (saved) {
            const cfg = JSON.parse(saved);
            template = (cfg && cfg.message) || "";
        }
    } catch (e) {
        template = "";
    }

    // 2. N·∫øu ch∆∞a c√≥ g√¨ l∆∞u th√¨ d√πng template m·∫∑c ƒë·ªãnh C√ì placeholder
    if (!template.trim()) {
        template = [
            "K√≠nh g·ª≠i c√°c Anh/Ch·ªã,",
            "",
            "- Nokia/VNPT Technology b√°o c√°o KPI cho c√°c tr·∫°m d·ª± √°n 5G Phase 02 (POx) khu v·ª±c Mi·ªÅn Nam (c·∫≠p nh·∫≠t ƒë·∫øn h·∫øt ng√†y (ng√†y g·∫ßn nh·∫•t)).",
            "- (POx) ƒë√£ ho√†n th√†nh ph√°t s√≥ng ƒë∆∞·ª£c (S·ªë tr·∫°m onair)/(T·ªïng s·ªë tr·∫°m POx) tr·∫°m.",
            "- K·∫ø ho·∫°ch ti·∫øp theo: X·ª≠ l√Ω KPI k√©m, duy tr√¨ ·ªïn ƒë·ªãnh v√† c·∫£i thi·ªán KPI."
        ].join("\n");
    }

    // 3. Ch·ªâ set template v√†o textbox, gi·ªØ nguy√™n placeholder
    textarea.value = template;
}

        // ==== √ÅP C·∫§U H√åNH BI·ªÇU ƒê·ªí T·ª™ L·∫¶N TR∆Ø·ªöC ====

        // ƒê·ªçc config (n·∫øu c√≥) m·ªôt l·∫ßn
        let savedChartConfig = null;
        try {
            const rawCfg = localStorage.getItem("chartConfig");
            savedChartConfig = rawCfg ? JSON.parse(rawCfg) : null;
        } catch (e) {
            savedChartConfig = null;
        }

        const chartsPerRowSelect = document.getElementById("chartsPerRowSelect");
        if (chartsPerRowSelect) {
            // set theo config c≈© n·∫øu c√≥
            if (savedChartConfig && savedChartConfig.chartsPerRow) {
                chartsPerRowSelect.value = savedChartConfig.chartsPerRow;
            }

            chartsPerRowSelect.addEventListener("change", () => {
                applyChartsPerRow();
                saveChartConfig();
            });

            // √°p layout ngay
            applyChartsPerRow();
        }

        const daysWindowSelect = document.getElementById("daysWindowSelect");
        if (daysWindowSelect) {
            function applyDaysWindowFromSelect() {
                const raw = daysWindowSelect.value;

                if (raw === "ALL") {
                    // To√†n b·ªô: kh√¥ng c·∫Øt b·ªõt labels theo s·ªë ng√†y
                    chartDaysWindow = null;
                } else {
                    const v = parseInt(raw, 10);
                    chartDaysWindow = isNaN(v) ? 14 : v; // fallback 14 ng√†y n·∫øu l·ªói
                }

                renderCharts();
                saveChartConfig();
            }

            // set theo config c≈© n·∫øu c√≥
            if (savedChartConfig && savedChartConfig.daysWindow) {
                daysWindowSelect.value = savedChartConfig.daysWindow;
            }

            // √°p l·∫ßn ƒë·∫ßu
            applyDaysWindowFromSelect();

            // c·∫≠p nh·∫≠t khi user ƒë·ªïi combobox
            daysWindowSelect.addEventListener("change", applyDaysWindowFromSelect);
        }

        window.addEventListener("resize", () => {
            applyStickyKpiColumns();
            if (typeof applyWorstCellStickyColumns === "function") {
                applyWorstCellStickyColumns();
            }
        });

        const funnelSortSelect = document.getElementById("funnelSortSelect");
        if (funnelSortSelect) {
            // set theo config c≈© n·∫øu c√≥
            if (savedChartConfig && savedChartConfig.funnelSort) {
                funnelSortSelect.value = savedChartConfig.funnelSort;
                funnelSortOrder = savedChartConfig.funnelSort || "desc";
            }

            funnelSortSelect.addEventListener("change", function () {
                funnelSortOrder = this.value || "desc";   // "asc" ho·∫∑c "desc"
                renderCharts();                           // v·∫Ω l·∫°i t·∫•t c·∫£ chart
                saveChartConfig();
            });
        }

        // ====== T·∫†O FILE OUTLOOK (.MSG) T·ª™ C√ÅC SECTION ƒêANG CH·ªåN ======

        function escapeHtml(str) {
            return String(str || "").replace(/[&<>"']/g, function (ch) {
                switch (ch) {
                    case "&":
                        return "&amp;";
                    case "<":
                        return "&lt;";
                    case ">":
                        return "&gt;";
                    case '"':
                        return "&quot;";
                    case "'":
                        return "&#39;";
                    default:
                        return ch;
                }
            });
        }
        
        function getSelectedEmailSectionsHtml() {
            const checkboxes = document.querySelectorAll(".email-section-checkbox:checked");
            if (!checkboxes.length) return "";

            const parts = [];

            checkboxes.forEach((cb) => {
                const key = cb.value;
                let el = null;

                if (key === "excel") {
                    el = document.getElementById("excelTableCard");
                } else if (key === "worstOverview") {
                    el = document.getElementById("worstOverviewCard");                    
                } else if (key === "charts") {
                    el = document.getElementById("chartsContainer");
                } else if (key === "cqiSummary") {
                    el = document.getElementById("cqiCard");
                } else if (key === "worst") {
                    el = document.getElementById("worstCellCard");
                } else if (key === "nonTraffic") {
                    el = document.getElementById("nonTrafficCard");
                } else if (key === "latest") {
                    el = document.getElementById("latestTableCard");
                }

                if (el) {
                    const style = window.getComputedStyle(el);
                    if (style.display !== "none") {
                        parts.push(el.outerHTML);
                    }
                }
            });

            if (!parts.length) return "";

            return parts.join(
                '\n<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />\n'
            );
        }

        function exportOutlookMsg() {
            const statusEl = document.getElementById("emailStatus");
            if (statusEl) {
                statusEl.textContent = "";
                statusEl.className = "email-status";
            }

            const toInput = document.getElementById("emailTo");
            const subjectInput = document.getElementById("emailSubject");
            const messageInput = document.getElementById("emailMessage");

            const to = (toInput?.value || "").replace(/\r?\n/g, " ").trim();
            let subject = (subjectInput?.value || "").replace(/\r?\n/g, " ").trim();
            if (!subject) subject = "KPI Report";

            const messageText = messageInput?.value || "";
            const messageHtml = escapeHtml(messageText).replace(/\r?\n/g, "<br>");

            const sectionsHtml = getSelectedEmailSectionsHtml();

            const bodyHtml =
                "<!DOCTYPE html>" +
                '<html><head><meta charset="UTF-8"></head><body ' +
                'style="font-family:-apple-system,BlinkMacSystemFont,\'Segoe UI\',Roboto,sans-serif;font-size:13px;color:#111827;">' +
                "<p>" +
                messageHtml +
                "</p>" +
                (sectionsHtml
                    ? '\n<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />\n' +
                      sectionsHtml
                    : "") +
                "</body></html>";

            // EML/MSG ƒë∆°n gi·∫£n theo chu·∫©n RFC822 ‚Äì Outlook v·∫´n m·ªü ƒë∆∞·ª£c
            const headerLines = [];
            if (to) {
                headerLines.push("To: " + to);
            }
            headerLines.push("Subject: " + subject);
            headerLines.push("MIME-Version: 1.0");
            headerLines.push('Content-Type: text/html; charset="UTF-8"');

            const emlContent = headerLines.join("\r\n") + "\r\n\r\n" + bodyHtml;

            const blob = new Blob([emlContent], { type: "message/rfc822" });

            const safeFileName =
                (subject || "kpi_report").replace(/[^a-zA-Z0-9-_]+/g, "_").slice(0, 80) ||
                "kpi_report";

            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = safeFileName + ".eml"; // d√πng ƒëu√¥i .msg ƒë·ªÉ m·ªü th·∫≥ng b·∫±ng Outlook
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            setTimeout(() => URL.revokeObjectURL(url), 5000);

            if (statusEl) {
                statusEl.textContent =
                    "‚úÖ ƒê√£ t·∫°o file Outlook (.msg). H√£y m·ªü file n√†y b·∫±ng Outlook ƒë·ªÉ g·ª≠i.";
                statusEl.classList.add("success");
            }
        }

        // G·∫Øn event cho n√∫t xu·∫•t .msg sau khi DOM s·∫µn s√†ng
        window.addEventListener("DOMContentLoaded", () => {
            const exportBtn = document.getElementById("exportMsgBtn");
            if (exportBtn) {
                exportBtn.addEventListener("click", exportOutlookMsg);
            }
        });

        function base64ToUint8Array(base64) {
            const raw = atob(base64);
            const arr = new Uint8Array(raw.length);
            for (let i = 0; i < raw.length; i++) arr[i] = raw.charCodeAt(i);
            return arr;
        }

        // ==== L·∫§Y TO√ÄN B·ªò CHART (CANVAS) ‚Üí PNG (BASE64) + TI√äU ƒê·ªÄ ====

        function buildEmlWithCharts(subject, messageHtml, charts) {
            const boundary = "BOUNDARY_" + Date.now();

            let eml = "";
            eml += "Subject: " + subject + "\r\n";
            eml += "MIME-Version: 1.0\r\n";
            eml += `Content-Type: multipart/related; boundary="${boundary}"\r\n\r\n`;

            // PH·∫¶N 1 ‚Äì HTML
            eml += `--${boundary}\r\n`;
            eml += "Content-Type: text/html; charset=UTF-8\r\n\r\n";

            // HTML body c√≥ nh√∫ng chart
            let html = "<html><body>";
            html += messageHtml + "<br><br>";

            charts.forEach((c) => {
                html += `<div><img src="cid:${c.id}" style="max-width:100%;"></div><br>`;
            });

            html += "</body></html>";

            eml += html + "\r\n\r\n";

            // PH·∫¶N 2 ‚Äì Embedded images
            charts.forEach((c) => {
                const imgBytes = base64ToUint8Array(c.base64);

                eml += `--${boundary}\r\n`;
                eml += "Content-Type: image/png\r\n";
                eml += `Content-Transfer-Encoding: base64\r\n`;
                eml += `Content-ID: <${c.id}>\r\n\r\n`;
                eml += c.base64 + "\r\n\r\n";
            });

            eml += `--${boundary}--`;

            return eml;
        }

        function exportEmailWithCharts() {
            const subject = document.getElementById("emailSubject").value || "KPI Report";
            const messageHtml = document.getElementById("emailMessage").value.replace(/\n/g, "<br>");

            const charts = getAllChartPNGs();
            console.log("Charts exported:", charts);

            const emlContent = buildEmlWithCharts(subject, messageHtml, charts);

            const blob = new Blob([emlContent], { type: "message/rfc822" });
            const url = URL.createObjectURL(blob);

            const a = document.createElement("a");
            a.href = url;
            a.download = subject.replace(/[^a-zA-Z0-9_-]/g, "_") + ".eml";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            setTimeout(() => URL.revokeObjectURL(url), 2000);
        }

        // ==== H·ªñ TR·ª¢ ESCAPE HTML ƒê∆†N GI·∫¢N ====
        function escapeHtml(str) {
            return String(str || "").replace(/[&<>"']/g, function (ch) {
                switch (ch) {
                    case "&": return "&amp;";
                    case "<": return "&lt;";
                    case ">": return "&gt;";
                    case '"': return "&quot;";
                    case "'": return "&#39;";
                    default: return ch;
                }
            });
        }

        // ==== SNAPSHOT CHART NGUY√äN CARD (HTML ‚Üí PNG, C√ì S·∫¥N BORDER TRONG ·∫¢NH) ====
        // ==== SNAPSHOT CHART NGUY√äN CARD (HTML ‚Üí PNG, C√ì S·∫¥N BORDER TRONG ·∫¢NH) ====
        async function getAllChartPNGs() {
            const cards = document.querySelectorAll("#chartsContainer .chart-card");
            const results = [];
            let idx = 0;

            for (const card of cards) {
                const canvas = card.querySelector("canvas");
                if (!canvas) continue;

                // 1) L·∫•y c√°c ph·∫ßn s·∫Ω t·∫°m ·∫©n / t·∫°m ƒë·ªïi style
                const headerRow = card.querySelector(".chart-header-row");
                const typeWrapper = card.querySelector(".chart-type-select")
                    ? card.querySelector(".chart-type-select").closest("div")
                    : null;
                // üîπ NEW: c·ª•m Y min/max b√™n tr√°i
                const yControls = card.querySelector(".chart-y-controls");

                const prevHeaderVis = headerRow ? headerRow.style.visibility : "";
                const prevTypeVis   = typeWrapper ? typeWrapper.style.visibility : "";
                const prevYVis      = yControls ? yControls.style.visibility : "";
                const prevShadow    = card.style.boxShadow;
                const prevOverflow  = card.style.overflow;
                const prevBg        = card.style.backgroundColor;
                const prevBorder    = card.style.border;
                const prevRadius    = card.style.borderRadius;

                // 2) ·∫®n ‚ÄúKi·ªÉu chart‚Äù (dropdown) + c·ª•m Y min/max
                if (typeWrapper) typeWrapper.style.visibility = "hidden";
                if (yControls)   yControls.style.visibility   = "hidden";
                // n·∫øu mu·ªën ·∫©n lu√¥n c·∫£ h√†ng header th√¨ m·ªü d√≤ng b√™n d∆∞·ªõi:
                // if (headerRow) headerRow.style.visibility = "hidden";

                // 3) T·∫Øt b√≥ng, n·ªÅn x√°m; set n·ªÅn tr·∫Øng + TH√äM BORDER 2PX ƒêEN
                card.style.boxShadow = "none";
                card.style.overflow = "visible";
                card.style.backgroundColor = "#ffffff";
                card.style.border = "2px solid #000000";
                card.style.borderRadius = "12px";

                // 4) Ch·ª•p card
                const snap = await html2canvas(card, {
                    scale: 1,
                    backgroundColor: "#ffffff"
                });

                const dataUrl = snap.toDataURL("image/png");
                const base64  = dataUrl.split(",")[1];

                // 5) Kh√¥i ph·ª•c l·∫°i style
                if (typeWrapper) typeWrapper.style.visibility = prevTypeVis;
                if (yControls)   yControls.style.visibility   = prevYVis;
                if (headerRow)   headerRow.style.visibility   = prevHeaderVis;
                card.style.boxShadow       = prevShadow;
                card.style.overflow        = prevOverflow;
                card.style.backgroundColor = prevBg;
                card.style.border          = prevBorder;
                card.style.borderRadius    = prevRadius;

                const h3 = card.querySelector("h3");
                const title = h3 ? h3.textContent.trim() : "Chart " + (idx + 1);

                results.push({
                    cid: "chart" + idx,
                    base64,
                    title
                });

                idx++;
            }

            return results;
        }

        // ==== BUILD N·ªòI DUNG EML D·∫†NG multipart/related C√ì INLINE IMAGE ====
        function buildEmlWithCharts(to, subject, bodyHtml, charts) {
            const boundary = "BOUNDARY_" + Date.now();

            let eml = "";
            if (to) {
                eml += "To: " + to + "\r\n";
            }
            eml += "Subject: " + subject + "\r\n";
            eml += "MIME-Version: 1.0\r\n";
            eml += `Content-Type: multipart/related; boundary="${boundary}"\r\n\r\n`;

            // PH·∫¶N 1 ‚Äì HTML ch√≠nh
            eml += `--${boundary}\r\n`;
            eml += 'Content-Type: text/html; charset="UTF-8"\r\n\r\n';
            eml += bodyHtml + "\r\n\r\n";

            // PH·∫¶N 2 ‚Äì C√°c ·∫£nh PNG ƒë∆∞·ª£c encode base64
            charts.forEach((c) => {
                eml += `--${boundary}\r\n`;
                eml += "Content-Type: image/png\r\n";
                eml += "Content-Transfer-Encoding: base64\r\n";
                eml += `Content-ID: <${c.cid}>\r\n\r\n`;
                eml += c.base64 + "\r\n\r\n";
            });

            eml += `--${boundary}--`;

            return eml;
        }

        function getSectionHtmlByKey(key) {
            let el = null;

            if (key === "excel") {
                el = document.getElementById("excelTableCard");
            } else if (key === "worstOverview") {
                el = document.getElementById("worstOverviewCard");
            } else if (key === "charts") {
                el = document.getElementById("chartsContainer");
            } else if (key === "cqiSummary") {
                el = document.getElementById("cqiCard");
            } else if (key === "worst") {
                el = document.getElementById("worstCellCard");
            } else if (key === "nonTraffic") {
                el = document.getElementById("nonTrafficCard");
            } else if (key === "latest") {
                el = document.getElementById("latestTableCard");
            }

            if (el) {
                const style = window.getComputedStyle(el);
                if (style.display !== "none") {
                    return el.outerHTML;
                }
            }
            return "";
        }


        async function captureSectionCardAsPng(key) {
            let target = null;
            let titleText = "";

            if (key === "excel") {
                // ‚úÖ CH·ªà CH·ª§P CH√çNH X√ÅC TH·∫∫ <table> B√äN TRONG KPI OVERVIEW
                const wrapper = document.getElementById("excelTable");
                const tableEl = wrapper ? wrapper.querySelector("table") : null;
                target = tableEl || wrapper;
                const t = document.getElementById("excelTableTitle");
                titleText = t ? t.textContent.trim() : "KPI Overview";
            
            } else if (key === "worstOverview") {
                const wrapper = document.getElementById("worstOverviewTable");
                const tableEl = wrapper ? wrapper.querySelector("table") : null;

                target = tableEl || wrapper;

                const t = document.querySelector("#worstOverviewCard h3");
                titleText = t ? t.textContent.trim() : "Worst Cell Overview";
            
            } else if (key === "progress") {
                // ‚úÖ CH·ªà CH·ª§P TABLE TI·∫æN ƒê·ªò ƒêO KI·ªÇM ‚Üí BORDER √îM S√ÅT B·∫¢NG
                const wrapper = document.getElementById("progressTable");
                const tableEl = wrapper ? wrapper.querySelector("table") : null;
                target = tableEl || wrapper;
                const t = document.querySelector("#progressCard h3");
                titleText = t ? t.textContent.trim() : "Ti·∫øn ƒê·ªô ƒêo Ki·ªÉm";
            
            } else if (key === "worst") {
                target = document.getElementById("worstCellTable");
                const t = document.getElementById("worstCellTitle");
                titleText = t ? t.textContent.trim() : "Worst Cell";

            } else if (key === "nonTraffic") {
                target = document.getElementById("nonTrafficTable");
                const t = document.getElementById("nonTrafficTitle");
                titleText = t ? t.textContent.trim() : "Cell Non-Traffic";

            } else if (key === "latest") {
                target = document.getElementById("latestTable");
                const t = document.getElementById("latestTableTitle");
                titleText = t ? t.textContent.trim() : "KPI th·ªùi ƒëi·ªÉm g·∫ßn nh·∫•t";

            } else if (key === "cqiSummary") {
                // ‚úÖ TH√äM: Ch·ª•p ƒë√∫ng TABLE trong CQI Summary
                const wrapper = document.getElementById("cqiSummaryTable");
                const tableEl = wrapper ? wrapper.querySelector("table") : null;

                // n·∫øu c√≥ table th√¨ ch·ª•p table, kh√¥ng th√¨ fallback v·ªÅ wrapper
                target = tableEl || wrapper;

                const t = document.querySelector("#cqiCard h3");
                titleText = t ? t.textContent.trim() : "CQI Summary";
            }

            if (!target) return null;

            // N·∫øu b·∫£ng ch∆∞a render / kh√¥ng c√≥ k√≠ch th∆∞·ªõc th√¨ b·ªè qua
            if (!target.offsetWidth || !target.offsetHeight) {
                return null;
            }

            // L∆∞u style c≈©
            const prevBorder   = target.style.border;
            const prevBg       = target.style.backgroundColor;
            const prevRadius   = target.style.borderRadius;
            const prevShadow   = target.style.boxShadow;
            const prevOverflow = target.style.overflow;

            // ‚úÖ Border + n·ªÅn tr·∫Øng ngay tr√™n ch√≠nh c√°i TABLE ‚Üí PNG √¥m ƒë√∫ng b·∫£ng
            target.style.border          = "2px solid #000000";
            target.style.backgroundColor = "#ffffff";
            target.style.borderRadius    = "12px";
            target.style.boxShadow       = "none";
            target.style.overflow        = "hidden";

            const canvas = await html2canvas(target, {
                scale: 1,
                backgroundColor: "#ffffff",
            });

            // Kh√¥i ph·ª•c style c≈©
            target.style.border          = prevBorder;
            target.style.backgroundColor = prevBg;
            target.style.borderRadius    = prevRadius;
            target.style.boxShadow       = prevShadow;
            target.style.overflow        = prevOverflow;

            const dataUrl = canvas.toDataURL("image/png");
            const base64  = dataUrl.split(",")[1];
            const cid     = "tbl_" + key;

            return {
                cid,
                base64,
                title: titleText || key,
            };
        }

        function buildEmailIntroBlock(messageHtml) {
            // B√¢y gi·ªù kh√¥ng t·ª± ch√®n m·∫´u n·ªØa,
            // m√† d√πng ƒë√∫ng n·ªôi dung ƒë√£ g√µ trong textbox (ƒë√£ escape + <br>)
            return messageHtml || "";
        }

        // ==== X·ª¨ L√ù KHI B·∫§M N√öT "Xu·∫•t Outlook (.eml) k√®m chart" ====

        // cho c·∫£ TI√äU ƒê·ªÄ v√† N·ªòI DUNG, nh∆∞ng KH√îNG thay trong textbox.
        async function handleExportEmlWithCharts() {
            const statusEl = document.getElementById("emailStatus");
            if (statusEl) {
                statusEl.textContent = "";
                statusEl.className = "email-status";
            }

            const to = (document.getElementById("emailTo")?.value || "").trim();

            // Ti√™u ƒë·ªÅ g·ªëc (c√≥ th·ªÉ ch·ª©a placeholder)
            const subjectRaw =
                (document.getElementById("emailSubject")?.value || "").trim() ||
                "KPI Report";

            // ==== 1. L·∫•y template g·ªëc trong textbox (v·∫´n c√≤n placeholder) ====
            const messageRaw = document.getElementById("emailMessage")?.value || "";

            // ==== 2. T√≠nh gi√° tr·ªã ƒë·ªông cho placeholder ====
            let latestStr = "";
            let latestDateObj = null;
            if (typeof getLatestDateFromCurrentData === "function") {
                latestDateObj = getLatestDateFromCurrentData();
                if (latestDateObj) {
                    latestStr = formatDateDDMMYYYY(latestDateObj);
                }
            }

            const poFilterEl = document.getElementById("progressPOFilter");
            const selectedPo = poFilterEl ? poFilterEl.value : "ALL";

            let label = "";
            let total = 0;
            let onair = 0;

            if (Array.isArray(progressFullData) && progressFullData.length) {
                if (!selectedPo || selectedPo === "ALL") {
                    // T·∫•t c·∫£ PO
                    label = "D·ª± √°n";
                    progressFullData.forEach((g) => {
                        total += g.total || 0;
                        onair += g.onair || 0;
                    });
                } else {
                    // 1 PO c·ª• th·ªÉ
                    const filtered = progressFullData.filter((g) => g.po === selectedPo);
                    if (filtered.length) {
                        label = selectedPo;
                        filtered.forEach((g) => {
                            total += g.total || 0;
                            onair += g.onair || 0;
                        });
                    }
                }
            }

            const finalDate  = latestStr || "(ng√†y g·∫ßn nh·∫•t)";
            const finalLabel = (label || selectedPo || "").trim() || "(POx)";
            const finalOnair = total > 0 ? String(onair) : "(S·ªë tr·∫°m onair)";
            const finalTotal = total > 0 ? String(total) : "(T·ªïng s·ªë tr·∫°m POx)";

            // ==== 3a. Thay placeholder cho TI√äU ƒê·ªÄ (ch·ªâ khi xu·∫•t .eml) ====
            let subjectProcessed = subjectRaw
                .replace(/\(ng√†y g·∫ßn nh·∫•t\)/g, finalDate)
                .replace(/\(POx\)/g, finalLabel)
                .replace(/\(S·ªë tr·∫°m onair\)/g, finalOnair)
                .replace(/\(T·ªïng s·ªë tr·∫°m POx\)/g, finalTotal);

            // ==== 3b. Thay placeholder CHO N·ªòI DUNG S·∫º ƒê∆ØA V√ÄO EML ====
            let messageProcessed = messageRaw || "";
            messageProcessed = messageProcessed
                .replace(/\(ng√†y g·∫ßn nh·∫•t\)/g, finalDate)
                .replace(/\(POx\)/g, finalLabel)
                .replace(/\(S·ªë tr·∫°m onair\)/g, finalOnair)
                .replace(/\(T·ªïng s·ªë tr·∫°m POx\)/g, finalTotal);

            // Convert sang HTML (textbox v·∫´n gi·ªØ template g·ªëc)
            const messageHtml = escapeHtml(messageProcessed).replace(/\r?\n/g, "<br>");

            // ==== 4. X·ª≠ l√Ω ph·∫ßn section/b·∫£ng/chart gi·ªØ nguy√™n nh∆∞ c≈© ====
            const checked = new Set(
                Array.from(
                    document.querySelectorAll(".email-section-checkbox:checked")
                ).map((cb) => cb.value)
            );

            const includeCharts = checked.has("charts");
            const tablesAsImages =
                document.getElementById("emailTablesAsImages")?.checked || false;

            let charts = [];
            if (includeCharts) {
                charts = await getAllChartPNGs();
                if (!charts.length && statusEl) {
                    statusEl.textContent = "‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y chart n√†o ƒë·ªÉ xu·∫•t.";
                    statusEl.classList.add("error");
                }
            }

            let allImages = [...charts];

            let bodyHtml =
                '<!DOCTYPE html><html><head><meta charset="UTF-8"></head>' +
                '<body style="font-family:-apple-system,BlinkMacSystemFont,\'Segoe UI\',Roboto,sans-serif;font-size:13px;color:#111827;">';

            // ph·∫ßn m·ªü ƒë·∫ßu email
            bodyHtml += "<p>" + messageHtml + "</p>";

            // 1. Ti·∫øn ƒë·ªô ƒëo ki·ªÉm
            if (checked.has("progress")) {
                if (tablesAsImages) {
                    const img = await captureSectionCardAsPng("progress");
                    if (img) {
                        allImages.push(img);
                        const titleSafe = escapeHtml(img.title || "Ti·∫øn ƒê·ªô ƒêo Ki·ªÉm");
                        bodyHtml +=
                            '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                            `<h3 style="margin:0 0 8px 0;">${titleSafe}</h3>` +
                            `<div><img src="cid:${img.cid}" style="max-width:100%;height:auto;"></div>`;
                    }
                } else {
                    const htmlProgress = getSectionHtmlByKey("progress");
                    if (htmlProgress) {
                        bodyHtml +=
                            '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                            htmlProgress;
                    }
                }
            }

            // 3. KPI Overview
            if (checked.has("excel")) {
                if (tablesAsImages) {
                    const img = await captureSectionCardAsPng("excel");
                    if (img) {
                        allImages.push(img);
                        const titleSafe = escapeHtml(img.title || "KPI Overview");
                        bodyHtml +=
                            '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                            `<h3 style="margin:0 0 8px 0;">${titleSafe}</h3>` +
                            `<div><img src="cid:${img.cid}" style="max-width:100%;height:auto;"></div>`;
                    }
                } else {
                    const htmlExcel = getSectionHtmlByKey("excel");
                    if (htmlExcel) {
                        bodyHtml +=
                            '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                            htmlExcel;
                    }
                }
            }

            // 2. Worst Cell Overview
            if (checked.has("worstOverview")) {
                if (tablesAsImages) {
                    const img = await captureSectionCardAsPng("worstOverview");
                    if (img) {
                        allImages.push(img);
                        const titleSafe = escapeHtml(img.title || "Worst Cell Overview");
                        bodyHtml +=
                            '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                            `<h3 style="margin:0 0 8px 0;">${titleSafe}</h3>` +
                            `<div><img src="cid:${img.cid}" style="max-width:100%;height:auto;"></div>`;
                    }
                } else {
                    const htmlWO = getSectionHtmlByKey("worstOverview");
                    if (htmlWO) {
                        bodyHtml +=
                            '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                            htmlWO;
                    }
                }
            }
            // 4. Bi·ªÉu ƒë·ªì KPI
            if (includeCharts && charts.length) {
                bodyHtml +=
                    '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                    '<h3 style="margin:0 0 8px 0;">Bi·ªÉu ƒë·ªì KPI</h3>';

                bodyHtml += '<div style="text-align:left;">';

                charts.forEach((c, idx) => {
                    if (idx % 2 === 0) {
                        bodyHtml +=
                            '<div style="white-space:nowrap; margin-bottom:10px;">';
                    }

                    bodyHtml += `
                        <img src="cid:${c.cid}"
                            style="
                                display:inline-block;
                                vertical-align:top;
                                width:520px;
                                height:auto;
                            ">
                    `;

                    if (idx % 2 === 0 && idx + 1 < charts.length) {
                        bodyHtml += "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
                    }

                    if (idx % 2 === 1 || idx === charts.length - 1) {
                        bodyHtml += "</div>";
                    }
                });

                bodyHtml += "</div>";
            }

            // 5. Worst Cell
            if (checked.has("worst")) {
                if (tablesAsImages) {
                    const img = await captureSectionCardAsPng("worst");
                    if (img) {
                        allImages.push(img);
                        const titleSafe = escapeHtml(img.title || "Worst Cell");
                        bodyHtml +=
                            '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                            `<h3 style="margin:0 0 8px 0;">${titleSafe}</h3>` +
                            `<div><img src="cid:${img.cid}" style="max-width:100%;height:auto;"></div>`;
                    }
                } else {
                    const htmlWorst = getSectionHtmlByKey("worst");
                    if (htmlWorst) {
                        bodyHtml +=
                            '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                            htmlWorst;
                    }
                }
            }

            // 6. Cell Non-Traffic
            if (checked.has("nonTraffic")) {
                if (tablesAsImages) {
                    const img = await captureSectionCardAsPng("nonTraffic");
                    if (img) {
                        allImages.push(img);
                        const titleSafe = escapeHtml(img.title || "Cell Non-Traffic");
                        bodyHtml +=
                            '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                            `<h3 style="margin:0 0 8px 0;">${titleSafe}</h3>` +
                            `<div><img src="cid:${img.cid}" style="max-width:100%;height:auto;"></div>`;
                    }
                } else {
                    const htmlNon = getSectionHtmlByKey("nonTraffic");
                    if (htmlNon) {
                        bodyHtml +=
                            '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                            htmlNon;
                    }
                }
            }

            // 7. CQI Summary
            if (checked.has("cqiSummary")) {
                if (tablesAsImages) {
                    const img = await captureSectionCardAsPng("cqiSummary");
                    if (img) {
                        allImages.push(img);
                        const titleSafe = escapeHtml(img.title || "CQI Summary");
                        bodyHtml +=
                            '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                            `<h3 style="margin:0 0 8px 0;">${titleSafe}</h3>` +
                            `<div><img src="cid:${img.cid}" style="max-width:100%;height:auto;"></div>`;
                    }
                } else {
                    const el = document.getElementById("cqiSummaryTable");
                    if (el) {
                        bodyHtml +=
                            '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                            el.outerHTML;
                    }
                }
            }
            bodyHtml += "</body></html>";

            // ==== 5. Build multipart/related EML v·ªõi allImages (chart + b·∫£ng PNG) ====
            const emlContent = buildEmlWithCharts(to, subjectProcessed, bodyHtml, allImages);

            const blob = new Blob([emlContent], { type: "message/rfc822" });

            // ==== 6. T√™n file .eml: "KPI Viewer and Report-yyyy-mm-dd" ====
            let fileDatePart = "";
            const d = latestDateObj || new Date();
            const yyyy = d.getFullYear();
            const mm = String(d.getMonth() + 1).padStart(2, "0");
            const dd = String(d.getDate()).padStart(2, "0");
            fileDatePart = `${yyyy}-${mm}-${dd}`;

            const safeName = `KPI Viewer and Report-${fileDatePart}`;

            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = safeName + ".eml";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(url), 5000);

            if (statusEl) {
                statusEl.textContent = "‚úÖ ƒê√£ t·∫°o file .eml";
                statusEl.classList.add("success");
            }
        }


        let progressFullData = [];
        let progressSitePoMap = {}; // map Site Name (CQT-SSV) -> PO

        function normalizeSiteKey(name) {
            return String(name || "")
                .trim()
                .toUpperCase()
                .replace(/\s+/g, " ");
        }

        // L·∫•y PO t·ª´ file Ti·∫øn ƒë·ªô ƒëo ki·ªÉm d·ª±a v√†o Site Name
        function getPoFromProgress(siteName) {
            if (!siteName) return "";
            const key = normalizeSiteKey(siteName);
            return progressSitePoMap[key] || "";
        }

        function initProgressUpload() {
            const input = document.getElementById("progressFileInput");
            const statusEl = document.getElementById("progressStatus");
            const tableContainer = document.getElementById("progressTable");
            const poFilter = document.getElementById("progressPOFilter");

            if (!input || !statusEl || !tableContainer) return;

            input.addEventListener("change", function (e) {
                const file = e.target.files && e.target.files[0];
                if (!file) return;

                statusEl.textContent = "ƒêang ƒë·ªçc file: " + file.name + "...";

                const reader = new FileReader();
                reader.onload = function (evt) {
                    try {
                        const data = new Uint8Array(evt.target.result);
                        const wb = XLSX.read(data, { type: "array" });

                        // L·∫•y sheet CQT-SSV
                        const sheetName = "CQT-SSV";
                        const ws =
                            wb.Sheets[sheetName] ||
                            wb.Sheets[wb.SheetNames[0]];

                        if (!ws) {
                            statusEl.textContent =
                                'Kh√¥ng t√¨m th·∫•y sheet "CQT-SSV" trong file Excel.';
                            tableContainer.innerHTML = "";
                            return;
                        }

                        const allRows = XLSX.utils.sheet_to_json(ws, {
                            header: 1,
                            defval: "",
                        });

                        if (allRows.length < 4) {
                            statusEl.textContent =
                                "Sheet CQT-SSV kh√¥ng ƒë·ªß d√≤ng d·ªØ li·ªáu.";
                            tableContainer.innerHTML = "";
                            return;
                        }

                        // Row 2: header th·∫≠t
                        const headerRow = allRows[1];
                        // D·ªØ li·ªáu t·ª´ row 4 tr·ªü ƒëi
                        const dataRows = allRows.slice(3);

                        const headers = headerRow.map((h) =>
                            String(h || "").trim()
                        );
                        const headersLower = headers.map((h) =>
                            h.toLowerCase()
                        );

        // ==== X√ÅC ƒê·ªäNH C√ÅC C·ªòT C·∫¶N D√ôNG ====
        const idxPO = headersLower.indexOf("po");
        const idxProvince = headersLower.indexOf("province");
        const idxSiteName = headersLower.indexOf("site name"); // ƒë·ªÉ map v·ªõi NRBTS

        const idxOnair = headersLower.findIndex((h) =>
            h.includes("onair")
        );
        const idxCqtDate = headersLower.findIndex((h) =>
            h.includes("ng√†y ƒëo cqt")
        );
        const idxSsvDate = headersLower.findIndex((h) =>
            h.includes("ng√†y ƒëo ssv/cluster")
        );
        const idxAtpDate = headersLower.findIndex((h) =>
            h.includes("ng√†y g·ª≠i report atp")
        );

        if (idxPO === -1 || idxProvince === -1) {
            statusEl.textContent =
                'Kh√¥ng t√¨m th·∫•y c·ªôt "PO" / "Province" trong sheet CQT-SSV.';
            tableContainer.innerHTML = "";
            return;
        }

        // ==== BUILD MAP Site Name -> PO CHO WORST CELL / NON-TRAFFIC ====
        progressSitePoMap = {};
        if (idxSiteName !== -1) {
            dataRows.forEach((row) => {
                const po = String(row[idxPO] || "").trim();
                const siteName = String(row[idxSiteName] || "").trim();
                if (!po || !siteName) return;

                const key = normalizeSiteKey(siteName);
                if (!progressSitePoMap[key]) {
                    progressSitePoMap[key] = po;
                }
            });
        }



                // ==== GOM NH√ìM THEO PO + PROVINCE ====
                const groups = {};

                dataRows.forEach((row) => {
                    const po = String(row[idxPO] || "").trim();
                    const province = String(row[idxProvince] || "").trim();
                    if (!po && !province) return;

                    const key = po + "||" + province;
                    if (!groups[key]) {
                        groups[key] = {
                            po,
                            province,
                            total: 0,
                            onair: 0,
                            cqtOk: 0,
                            ssvOk: 0,
                            atpReport: 0,
                        };
                    }

                    const g = groups[key];
                    g.total++;

                    // --- On-Air: c√≥ gi√° tr·ªã b·∫•t k·ª≥ ---
                    let hasOnAir = false;
                    if (idxOnair !== -1) {
                        const vOn = String(row[idxOnair] || "").trim();
                        if (vOn !== "") {
                            g.onair++;
                            hasOnAir = true;
                        }
                    }

                    // --- CQT: c√≥ "Ng√†y ƒëo CQT" v√† b·∫Øt bu·ªôc ph·∫£i On-Air ---
                    if (idxCqtDate !== -1 && hasOnAir) {
                        const v = String(row[idxCqtDate] || "").trim();
                        if (v !== "") g.cqtOk++;
                    }

                    // --- SSV: c√≥ "Ng√†y ƒëo SSV/Cluster" v√† b·∫Øt bu·ªôc ph·∫£i On-Air ---
                    if (idxSsvDate !== -1 && hasOnAir) {
                        const v = String(row[idxSsvDate] || "").trim();
                        if (v !== "") g.ssvOk++;
                    }

                    // --- ATP report: c√≥ "Ng√†y g·ª≠i report ATP vung phu song" v√† b·∫Øt bu·ªôc On-Air ---
                    if (idxAtpDate !== -1 && hasOnAir) {
                        const v = String(row[idxAtpDate] || "").trim();
                        if (v !== "") g.atpReport++;
                    }
                    
                });

                const groupList = Object.values(groups).sort((a, b) => {
                    if (a.po === b.po) {
                        return a.province.localeCompare(b.province);
                    }
                    return a.po.localeCompare(b.po);
                });

                // L∆∞u to√†n b·ªô cho combobox filter
                progressFullData = groupList;

                // ==== FILL COMBOBOX PO ====
                if (poFilter) {
                    poFilter.innerHTML =
                        '<option value="ALL">T·∫•t c·∫£ PO</option>';
                    const uniquePO = [...new Set(groupList.map((g) => g.po))];
                    uniquePO.forEach((po) => {
                        const opt = document.createElement("option");
                        opt.value = po;
                        opt.textContent = po;
                        poFilter.appendChild(opt);
                    });
                    poFilter.style.display = "inline-block";
                }

                // Render b·∫£ng l·∫ßn ƒë·∫ßu (t·∫•t c·∫£ PO)
                const initialData = buildProvinceSummary(groupList);
                renderProgressTable(initialData);
                applyProgressColumnToggle();


                // Sau khi ƒë√£ c√≥ progressSitePoMap -> render l·∫°i Worst Cell / Non-Traffic
                if (typeof renderWorstCellTable === "function") {
                    renderWorstCellTable();
                }

                if (typeof renderCqiTable === "function") {
                    renderCqiTable();
                }

                // C·∫≠p nh·∫≠t l·∫°i n·ªôi dung email m·ªü ƒë·∫ßu theo d·ªØ li·ªáu Ti·∫øn ƒë·ªô
                if (typeof fillDefaultEmailText === "function") {
                    fillDefaultEmailText();
                }

                // ‚ûï C·∫≠p nh·∫≠t Worst Cell Overview theo d·ªØ li·ªáu Ti·∫øn ƒë·ªô m·ªõi
                if (typeof recomputeWorstCellOverview === "function") {
                    recomputeWorstCellOverview();
                }



                statusEl.textContent =
                    "File " +
                    file.name +
                    ".";
            } catch (err) {
                console.error(err);
                statusEl.textContent = "L·ªói khi ƒë·ªçc file: " + err.message;
                tableContainer.innerHTML = "";
            }
        };

        reader.onerror = function () {
            statusEl.textContent = "Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c file.";
            tableContainer.innerHTML = "";
        };

        reader.readAsArrayBuffer(file);
    });
}

        // G√°n s·ª± ki·ªán upload cho ph·∫ßn Ti·∫øn ƒê·ªô ƒêo Ki·ªÉm
        initProgressUpload();
        // G·ªôp d·ªØ li·ªáu Ti·∫øn ƒë·ªô theo t·ª´ng T·ªânh (d√πng khi ch·ªçn "T·∫•t c·∫£ PO")
        function buildProvinceSummary(list) {
            const map = {};

            (list || []).forEach((g) => {
                const province = (g.province || "").trim();
                if (!province) return;

                if (!map[province]) {
                    map[province] = {
                        po: "T·∫•t c·∫£",      // ho·∫∑c "" n·∫øu mu·ªën ƒë·ªÉ tr·ªëng c·ªôt PO
                        province,
                        total: 0,
                        onair: 0,
                        cqtOk: 0,
                        ssvOk: 0,
                        atpReport: 0,
                    };
                }

                const agg = map[province];
                agg.total     += g.total     || 0;
                agg.onair     += g.onair     || 0;
                agg.cqtOk     += g.cqtOk     || 0;
                agg.ssvOk     += g.ssvOk     || 0;
                agg.atpReport += g.atpReport || 0;
            });

            // S·∫Øp x·∫øp theo t√™n T·ªânh
            return Object.values(map).sort((a, b) =>
                a.province.localeCompare(b.province)
            );
        }

        function renderProgressTable(data) {
        const tableContainer = document.getElementById("progressTable");
        if (!tableContainer) return;

        let totalStations = 0;
        let totalOnair = 0;
        let totalCqtOk = 0;
        let totalSsvOk = 0;
        let totalAtpOk = 0;

        // helper format %
        function formatPct(val) {
            // ·∫©n c·∫£ 0.00% v√† NaN%
            return (val === "0.00%" || val === "NaN%") ? "-" : val;
        }
        let html = `
            <table class="progress-table">
                <thead>
                    <tr>
                        <th>STT</th>
                        <th>PO</th>
                        <th>T·ªânh</th>
                        <th>S·ªë tr·∫°m</th>

                        <th>On-Air</th>
                        <th>Ti·∫øn ƒë·ªô On-Air (%)</th>
                        <th class="col-cqt">CQT</th>
                        <th class="col-cqt">Ti·∫øn ƒë·ªô CQT (%)</th>

                        <th class="col-ssv">SSV</th>
                        <th class="col-ssv">Ti·∫øn ƒë·ªô SSV (%)</th>

                        <th class="col-atp">ATP report</th>
                        <th class="col-atp">Ti·∫øn ƒë·ªô ATP report</th>

                    </tr>
                </thead>
                <tbody>
            `;

        data.forEach((g, idx) => {
        totalStations += g.total;
        totalOnair += g.onair;
        totalCqtOk += g.cqtOk;
        totalSsvOk += g.ssvOk;
        totalAtpOk += g.atpReport;

        const onairPct =
            g.total > 0
                ? formatPct(((g.onair / g.total) * 100).toFixed(2) + "%")
                : "-";
        const cqtPct =
            g.total > 0
                ? formatPct(((g.cqtOk / g.onair) * 100).toFixed(2) + "%")
                : "-";
        const ssvPct =
            g.total > 0
                ? formatPct(((g.ssvOk / g.onair) * 100).toFixed(2) + "%")
                : "-";
        const atpPct =
            g.total > 0
                ? formatPct(((g.atpReport / g.onair) * 100).toFixed(2) + "%")
                : "-";

        html += `
        <tr>
            <td>${idx + 1}</td>
            <td>${g.po}</td>
            <td>${g.province}</td>
            <td>${g.total}</td>

            <td>${g.onair}</td>
            <td>${onairPct}</td>
            <td class="col-cqt">${g.cqtOk}</td>
            <td class="col-cqt">${cqtPct}</td>

            <td class="col-ssv">${g.ssvOk}</td>
            <td class="col-ssv">${ssvPct}</td>

            <td class="col-atp">${g.atpReport}</td>
            <td class="col-atp">${atpPct}</td>

        </tr>`;
    });

    const totalOnairPct =
        totalStations > 0
            ? formatPct(((totalOnair / totalStations) * 100).toFixed(2) + "%")
            : "-";
    const totalCqtPct =
        totalStations > 0
            ? formatPct(((totalCqtOk / totalOnair) * 100).toFixed(2) + "%")
            
            : "-";
    const totalSsvPct =
        totalStations > 0
            ? formatPct(((totalSsvOk / totalOnair) * 100).toFixed(2) + "%")
            
            : "-";
    const totalAtpPct =
        totalStations > 0
            ? formatPct(((totalAtpOk / totalOnair) * 100).toFixed(2) + "%")
            
            : "-";

    html += `
        <tr class="progress-summary-row">
            <td>T·ªïng c·ªông</td>
            <td></td>
            <td></td>
            <td>${totalStations}</td>

            <td>${totalOnair}</td>
            <td>${totalOnairPct === "0.00%" ? "-" : totalOnairPct}</td>
            <td class="col-cqt">${totalCqtOk}</td>
            <td class="col-cqt">${totalCqtPct === "0.00%" ? "-" : totalCqtPct}</td>

            <td class="col-ssv">${totalSsvOk}</td>
            <td class="col-ssv">${totalSsvPct === "0.00%" ? "-" : totalSsvPct}</td>

            <td class="col-atp">${totalAtpOk}</td>
            <td class="col-atp">${totalAtpPct === "0.00%" ? "-" : totalAtpPct}</td>

        </tr>
    </tbody></table>
    `;

    tableContainer.innerHTML = html;

    // n·∫øu ƒëang d√πng sticky 4 c·ªôt ƒë·∫ßu
    if (typeof applyProgressStickyColumns === "function") {
        applyProgressStickyColumns();
    }
}

    function applyProgressColumnToggle() {
        const showCQT = document.getElementById("toggleCQT").checked;
        const showSSV = document.getElementById("toggleSSV").checked;
        const showATP = document.getElementById("toggleATP").checked;

        document.querySelectorAll(".col-cqt").forEach(td =>
            td.classList.toggle("hide-col", !showCQT)
        );
        document.querySelectorAll(".col-ssv").forEach(td =>
            td.classList.toggle("hide-col", !showSSV)
        );
        document.querySelectorAll(".col-atp").forEach(td =>
            td.classList.toggle("hide-col", !showATP)
        );
    }

    function applyProgressStickyColumns() {
    const table = document.querySelector("#progressTable table");
    if (!table || !table.tHead) return;

    const stickyCount = 4; // STT, PO, T·ªânh, S·ªë tr·∫°m

    const headerRows = Array.from(table.tHead.rows);
    if (!headerRows.length) return;

    const headerRow = headerRows[headerRows.length - 1];

    const tableRect = table.getBoundingClientRect();
    const colLeft = [];

    for (let i = 0; i < stickyCount; i++) {
        const cell = headerRow.cells[i];
        if (!cell) continue;
        const rect = cell.getBoundingClientRect();
        colLeft[i] = rect.left - tableRect.left;
    }

    // reset sticky c≈©
    const oldSticky = table.querySelectorAll(".sticky-col");
    oldSticky.forEach((c) => {
        c.classList.remove("sticky-col");
        c.style.left = "";
        c.style.position = "";
    });

    // g√°n sticky cho 4 c·ªôt ƒë·∫ßu
    const rows = Array.from(table.rows);
    rows.forEach((row) => {
        for (let i = 0; i < stickyCount; i++) {
            const cell = row.cells[i];
            if (!cell) continue;

            cell.classList.add("sticky-col");
            cell.style.position = "sticky";
            cell.style.left = (colLeft[i] || 0) + "px";
        }
    });
}

    // C·ªë ƒë·ªãnh 4 c·ªôt ƒë·∫ßu cho b·∫£ng Worst Cell (PO, Province, NRBTS, NRCEL)
    // C·ªë ƒë·ªãnh 4 c·ªôt ƒë·∫ßu cho b·∫£ng Worst Cell (PO, Province, NRBTS, NRCEL)
    function applyWorstCellStickyColumns() {
    const wrappers = [
        document.getElementById("worstCellTable"),
        document.getElementById("nonTrafficTable"),
    ].filter(Boolean);

    const stickyCount = 4; // 4 c·ªôt ƒë·∫ßu

    wrappers.forEach((wrapper) => {
        const table = wrapper.querySelector("table");
        if (!table || !table.tHead) return;

        const headerRow = table.tHead.rows[table.tHead.rows.length - 1];
        if (!headerRow) return;

        const tableRect = table.getBoundingClientRect();
        const leftOffsets = [];

        // T√≠nh left cho 4 c·ªôt ƒë·∫ßu
        for (let i = 0; i < stickyCount; i++) {
            const cell = headerRow.cells[i];
            if (!cell) continue;
            const rect = cell.getBoundingClientRect();
            leftOffsets[i] = rect.left - tableRect.left;
        }

        // Reset sticky c≈©
        // Reset sticky c≈© ‚Äì KH√îNG ƒë·ª•ng t·ªõi background/color ƒë·ªÉ gi·ªØ m√†u t√¥ ng∆∞·ª°ng
        table.querySelectorAll(".sticky-col-wc").forEach((td) => {
            td.classList.remove("sticky-col-wc");
            td.style.left = "";
            td.style.position = "";
            td.style.zIndex = "";
        });


        const rows = Array.from(table.rows);

        rows.forEach((row) => {
            const isHeader = row.parentNode.tagName === "THEAD";

            for (let i = 0; i < stickyCount; i++) {
                const cell = row.cells[i];
                if (!cell) continue;

                // G·∫Øn sticky theo v·ªã tr√≠ t√≠nh ƒë∆∞·ª£c
                cell.classList.add("sticky-col-wc");
                cell.style.position = "sticky";
                cell.style.left = (leftOffsets[i] || 0) + "px";
                cell.style.zIndex = isHeader ? 6 : 4;

                if (isHeader) {
                    // Ch·ªâ set m√†u cho header
                    cell.style.background = "#203864";
                    cell.style.color = "#ffffff";
                    cell.style.fontWeight = "600";
                } else {
                    // Body: gi·ªØ nguy√™n background/color/condStyle (√¥ ƒë·ªè), ch·ªâ ch·ªëng xu·ªëng d√≤ng
                    cell.style.whiteSpace = "nowrap";
                }
            }
        });

    });
}

        // L·ªçc b·∫£ng Ti·∫øn ƒë·ªô ƒëo ki·ªÉm theo PO ƒë∆∞·ª£c ch·ªçn
        const poFilterEl = document.getElementById("progressPOFilter");
        if (poFilterEl) {
            poFilterEl.addEventListener("change", function () {
                const val = this.value;

                let filtered;
                if (val === "ALL") {
                    // üëâ T·∫•t c·∫£ PO: g·ªôp l·∫°i theo t·ª´ng T·ªânh
                    filtered = buildProvinceSummary(progressFullData);
                } else {
                    // üëâ 1 PO c·ª• th·ªÉ: gi·ªØ nguy√™n theo (PO + T·ªânh)
                    filtered = progressFullData.filter((g) => g.po === val);
                }

                renderProgressTable(filtered);

                // ‚úÖ √Åp l·∫°i tr·∫°ng th√°i checkbox CQT / SSV / ATP
                if (typeof applyProgressColumnToggle === "function") {
                    applyProgressColumnToggle();
                }

                // Sau khi ƒë·ªïi PO, c·∫≠p nh·∫≠t l·∫°i n·ªôi dung email m·ªü ƒë·∫ßu
                if (typeof fillDefaultEmailText === "function") {
                    fillDefaultEmailText();
                }
            });
        }



        /* ==========================================================
            1. SAVE & LOAD CONFIG (Bi·ªÉu ƒë·ªì)
        ========================================================== */

        // --- SAVE ---
        function saveChartConfig() {
            const config = {
                sheet: document.getElementById("sheetSelect").value,
                chartsPerRow: document.getElementById("chartsPerRowSelect").value,
                daysWindow: document.getElementById("daysWindowSelect").value,
                funnelSort: document.getElementById("funnelSortSelect").value
            };
            localStorage.setItem("chartConfig", JSON.stringify(config));
        }

        // --- LOAD ---
        function loadChartConfig() {
            const saved = localStorage.getItem("chartConfig");
            if (!saved) return;

            const cfg = JSON.parse(saved);

            if (cfg.sheet) document.getElementById("sheetSelect").value = cfg.sheet;
            if (cfg.chartsPerRow) document.getElementById("chartsPerRowSelect").value = cfg.chartsPerRow;
            if (cfg.daysWindow) document.getElementById("daysWindowSelect").value = cfg.daysWindow;
            if (cfg.funnelSort) document.getElementById("funnelSortSelect").value = cfg.funnelSort;
        }

        // G·ªçi save khi user thay ƒë·ªïi config
        ["sheetSelect","chartsPerRowSelect","daysWindowSelect","funnelSortSelect"]
        .forEach(id => {
            document.getElementById(id).addEventListener("change", saveChartConfig);
        });


        /* ==========================================================
            2. SAVE & LOAD EMAIL FIELDS
        ========================================================== */

        // --- SAVE ---
        function saveEmailConfig() {
            const cfg = {
                to: document.getElementById("emailTo").value,
                subject: document.getElementById("emailSubject").value,
                message: document.getElementById("emailMessage").value
            };
            localStorage.setItem("emailConfig", JSON.stringify(cfg));
        }

        // --- LOAD ---
        function loadEmailConfig() {
            const saved = localStorage.getItem("emailConfig");
            if (!saved) return;

            const cfg = JSON.parse(saved);

            if (cfg.to) document.getElementById("emailTo").value = cfg.to;
            if (cfg.subject) document.getElementById("emailSubject").value = cfg.subject;
            if (cfg.message) document.getElementById("emailMessage").value = cfg.message;
        }

        // G·ªçi auto-save khi ng∆∞·ªùi d√πng g√µ
        ["emailTo","emailSubject","emailMessage"].forEach(id => {
            document.getElementById(id).addEventListener("input", saveEmailConfig);
        });


        /* ==========================================================
            3. T·ª∞ ƒê·ªòNG CH√àN L·∫†I BI·∫æN ƒê·ªòNG POx / S·ªê TR·∫†M / NG√ÄY
        ========================================================== */

        /* ==========================================================
            3. T·ª∞ ƒê·ªòNG CH√àN L·∫†I BI·∫æN ƒê·ªòNG POx / S·ªê TR·∫†M / NG√ÄY
        ========================================================== */
        function updateDynamicEmailFields(
            latestDate,
            selectedPO,
            onairCount,
            totalCount,
            baseText
        ) {
            const textarea = document.getElementById("emailMessage");
            if (!textarea) return;

            // L·∫•y template g·ªëc: ∆∞u ti√™n baseText, n·∫øu kh√¥ng th√¨ l·∫•y t·ª´ textarea
            let msg =
                typeof baseText === "string" && baseText.length
                    ? baseText
                    : textarea.value || "";

            // Thay c√°c placeholder b·∫±ng gi√° tr·ªã hi·ªán t·∫°i
            msg = msg
                .replace(/\(ng√†y g·∫ßn nh·∫•t\)/g, latestDate || "(ng√†y g·∫ßn nh·∫•t)")
                .replace(/\(POx\)/g, selectedPO || "(POx)")
                .replace(/\(S·ªë tr·∫°m onair\)/g, onairCount || "(S·ªë tr·∫°m onair)")
                .replace(/\(T·ªïng s·ªë tr·∫°m POx\)/g, totalCount || "(T·ªïng s·ªë tr·∫°m POx)");

            // Hi·ªÉn th·ªã l√™n textarea
            textarea.value = msg;
        }


        /* ==========================================================
            4. G·ªçi load config khi trang m·ªü l·∫°i
        ========================================================== */

        window.addEventListener("DOMContentLoaded", () => {
            loadChartConfig();
            loadEmailConfig();
        });
        function updateKpiFolderPath() {
            const newPath = document.getElementById("kpiFolderInput").value.trim();

            if (!newPath) {
                alert("Vui l√≤ng nh·∫≠p ƒë∆∞·ªùng d·∫´n h·ª£p l·ªá (v√≠ d·ª•: /KPI Scheduler)");
                return;
            }

            // c·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n v√†o c·∫•u h√¨nh
            graphKpiConfig.kpiFolderPath = newPath;

            alert("ƒê√£ c·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n OneDrive:\n" + newPath);
        }

        ["toggleCQT", "toggleSSV", "toggleATP"].forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;

            // üîπ Kh√¥i ph·ª•c tr·∫°ng th√°i ƒë√£ l∆∞u
            const saved = localStorage.getItem(id);
            if (saved !== null) {
                el.checked = saved === "true";
            }

            // üîπ Khi ng∆∞·ªùi d√πng thay ƒë·ªïi ‚Üí l∆∞u l·∫°i
            el.addEventListener("change", () => {
                localStorage.setItem(id, el.checked);
                applyProgressColumnToggle();
            });
        });

        // ===== Popup ch·ªçn WS/SITE/CELL_NAME =====
        document.addEventListener("DOMContentLoaded", () => {
        const floatBtn      = document.getElementById("wsFloatingBtn");
        const overlay       = document.getElementById("wsPopupOverlay");
        const popupCloseBtn = document.getElementById("wsPopupClose");
        const popupContent  = document.getElementById("wsPopupContent");
        const wsContainer   = document.getElementById("wsFilterContainer");

        if (!floatBtn || !overlay || !popupContent || !wsContainer) return;

        // L∆∞u v·ªã tr√≠ g·ªëc c·ªßa wsFilterContainer
        const originalParent      = wsContainer.parentNode;
        const originalNextSibling = wsContainer.nextSibling;

        function showFloatingBtnOnScroll() {
            const threshold = 260;
            floatBtn.style.display = (window.scrollY > threshold) ? "flex" : "none";
        }

        showFloatingBtnOnScroll();
        window.addEventListener("scroll", showFloatingBtnOnScroll);

        // ===== DRAG POPUP =====
        const popupEl  = overlay.querySelector(".ws-popup");
        const headerEl = overlay.querySelector(".ws-popup-header");

        let isDragging = false;
        let startX = 0, startY = 0;
        let startLeft = 0, startTop = 0;

        let hasConverted = false;

        function onMouseDown(e) {
        if (!popupEl) return;
        if (e.target.closest("#wsPopupClose")) return;

        // ‚úÖ Convert 1 l·∫ßn duy nh·∫•t ƒë·ªÉ tr√°nh nh·∫£y m·ªói l·∫ßn click header
        if (!hasConverted) {
            const rect = popupEl.getBoundingClientRect();

            // set left/top tr∆∞·ªõc
            popupEl.style.left = rect.left + "px";
            popupEl.style.top  = rect.top  + "px";

            // r·ªìi m·ªõi b·ªè transform
            popupEl.style.transform = "none";
            hasConverted = true;
        }

        isDragging = true;

        const rect2 = popupEl.getBoundingClientRect();
        startLeft = rect2.left;
        startTop  = rect2.top;

        startX = e.clientX;
        startY = e.clientY;

        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
        e.preventDefault();
        }

        function onMouseMove(e) {
        if (!isDragging || !popupEl) return;

        const dx = e.clientX - startX;
        const dy = e.clientY - startY;

        let nextLeft = startLeft + dx;
        let nextTop  = startTop + dy;

        const pad = 8;
        const maxLeft = window.innerWidth  - popupEl.offsetWidth  - pad;
        const maxTop  = window.innerHeight - popupEl.offsetHeight - pad;

        nextLeft = Math.max(pad, Math.min(maxLeft, nextLeft));
        nextTop  = Math.max(pad, Math.min(maxTop,  nextTop));

        popupEl.style.left = nextLeft + "px";
        popupEl.style.top  = nextTop  + "px";
        }

        function onMouseUp() {
        isDragging = false;
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
        }

        if (headerEl) headerEl.addEventListener("mousedown", onMouseDown);
        // ===== END DRAG POPUP =====

        function openWsPopup() {
        popupContent.appendChild(wsContainer);
        overlay.classList.add("show");

        // reset v·ªÅ center m·ªói l·∫ßn m·ªü
        if (popupEl) {
            popupEl.style.left = "50%";
            popupEl.style.top  = "50%";
            popupEl.style.transform = "translate(-50%, -50%)";
        }
        hasConverted = false;
        }



        function closeWsPopup() {
            if (originalNextSibling && originalNextSibling.parentNode === originalParent) {
            originalParent.insertBefore(wsContainer, originalNextSibling);
            } else {
            originalParent.appendChild(wsContainer);
            }
            overlay.classList.remove("show");
        }

        floatBtn.addEventListener("click", openWsPopup);
        popupCloseBtn.addEventListener("click", closeWsPopup);

        overlay.addEventListener("click", (e) => {
            if (e.target === overlay) closeWsPopup();
        });

        document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && overlay.classList.contains("show")) closeWsPopup();
        });
        });

        document.getElementById("chartVerticalTime")?.addEventListener("change", e => {
            chartVerticalTimeValue = e.target.value || null;
            Object.values(chartInstances).forEach(ch => ch.update());
        });

        document.getElementById("chartVerticalClearBtn")?.addEventListener("click", () => {
            chartVerticalTimeValue = null;
            document.getElementById("chartVerticalTime").value = "";
            Object.values(chartInstances).forEach(ch => ch.update());
        });





    </script>

    <!-- N√∫t n·ªïi g·ªçi popup WS/SITE/CELL_NAME -->
    <div id="wsFloatingBtn" class="ws-floating-btn">
        üïµüèª WS/SITE/CELL_NAME
    </div>

    <!-- Popup overlay -->
    <div id="wsPopupOverlay" class="ws-popup-overlay">
        <div class="ws-popup">
            <div class="ws-popup-header">
                <span>üßµ Ch·ªçn WS/SITE/CELL_NAME</span>
                <button type="button" id="wsPopupClose" class="ws-popup-close">&times;</button>
            </div>
            <div class="ws-popup-body">
                <!-- ·ªû ƒë√¢y s·∫Ω DI CHUY·ªÇN #wsFilterContainer v√†o -->
                <div id="wsPopupContent"></div>
            </div>
        </div>
    </div>



</body>
</html>