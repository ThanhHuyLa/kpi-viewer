<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KPI Viewer and Report</title>

    <!-- XLSX & Chart.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- MSAL cho ƒëƒÉng nh·∫≠p OneDrive (Microsoft Graph) -->
    <script src="https://alcdn.msauth.net/browser/2.38.0/js/msal-browser.min.js"></script>




    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
                Ubuntu, Cantarell, sans-serif;
            background: #f3f4f6; /* x√°m tr·∫Øng nh·∫π */
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: #111827;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #3749a5; /* xanh ƒë·∫≠m hi·ªán ƒë·∫°i */
            text-shadow: 0 2px 4px rgba(55, 73, 165, 0.15);
        }

        .upload-section {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.25);
            margin-bottom: 24px;
            text-align: center;
        }

        .upload-area {
            border: 2px dashed #667eea;
            border-radius: 12px;
            padding: 24px 16px;
            background: #f8f9ff;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f2ff;
            transform: scale(1.02);
        }

        .upload-area.dragover {
            border-color: #4caf50;
            background: #e8f5e9;
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 12px;
        }

        .upload-area h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.5em;
        }

        .file-input {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 32px;
            border-radius: 30px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .file-info {
            margin-top: 16px;
            padding: 12px 16px;
            background: #e8f5e9;
            border-radius: 10px;
            display: none;
            text-align: left;
            font-size: 0.9em;
        }

        .file-info.show {
            display: block;
        }

        .charts-section {
            display: none;
        }

        .charts-section.show {
            display: block;
        }

        .chart-controls {
            background: white;
            border-radius: 15px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.18);
        }

        .chart-controls h3 {
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-grid {
            display: flex;
            gap: 16px;
            flex-wrap: nowrap;          /* 3 combobox lu√¥n c√πng 1 h√†ng tr√™n desktop */
            align-items: flex-end;      /* canh ƒë√°y cho ƒë·∫πp */
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1;                    /* m·ªói combobox chi·∫øm ƒë·ªÅu chi·ªÅu ngang */
        }

        .control-group label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        .control-group select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 0.95em;
            cursor: pointer;
            background: white;
            transition: border-color 0.3s;
        }

        .control-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .chart-card {
            background: white;
            border-radius: 20px;
            padding: 24px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.18);
        }

        .chart-card h3 {
            color: #333;
            margin-bottom: 16px;
            font-size: 1.2em;
            text-align: center;
        }

        .chart-wrapper {
            position: relative;
            height: 380px;
        }

        #chartsContainer {
            display: grid;
            gap: 20px;
            --charts-per-row: 2;
            grid-template-columns: repeat(var(--charts-per-row), minmax(0, 1fr));
            margin-bottom: 24px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 10px;
            color: #667eea;
            font-size: 1em;
        }

        .loading.show {
            display: block;
        }

        .data-table {
            background: white;
            border-radius: 20px;
            padding: 24px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.18);
            margin-top: 24px;
            margin-bottom: 24px;
            overflow-x: auto;
        }

        .data-table h3 {
            color: #111827;
            margin-bottom: 10px;
            font-size: 1.15em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        th,
        td {
            padding: 6px 8px;
            border-bottom: 1px solid #e5e7eb;
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

/* === STYLE B·∫¢NG TI·∫æN ƒê·ªò ƒêO KI·ªÇM === */
.progress-table {
    font-size: 14px;
    border-collapse: collapse;
    margin: 8px 0;
    width: auto;                /* kh√¥ng b·∫Øt bu·ªôc 100% */
    table-layout: fixed;        /* ƒë·ªÉ t√≠nh left sticky ·ªïn ƒë·ªãnh */
}

/* header xanh gi·ªëng Worst Cell */
.progress-table th {
    background: #1e3a8a;
    color: #fff;
    font-weight: 600;
    padding: 8px 10px;
    text-align: center;
    white-space: nowrap;
    border: 1px solid #d1d5db;
}

.progress-table td {
    padding: 6px 10px;
    text-align: center;
    white-space: nowrap;
    border: 1px solid #e5e7eb;
}

.progress-table tr:hover {
    background: #f3f4ff;
}

/* chi·ªÅu r·ªông 4 c·ªôt ƒë·∫ßu ‚Äì c√≥ th·ªÉ ch·ªânh th√™m n·∫øu mu·ªën */
.progress-table th:nth-child(1),
.progress-table td:nth-child(1) { min-width: 40px; }  /* STT  */
.progress-table th:nth-child(2),
.progress-table td:nth-child(2) { min-width: 60px; }  /* PO   */
.progress-table th:nth-child(3),
.progress-table td:nth-child(3) { min-width: 80px; }  /* T·ªânh */
.progress-table th:nth-child(4),
.progress-table td:nth-child(4) { min-width: 80px; }  /* S·ªë tr·∫°m */

/* Sticky 4 c·ªôt ƒë·∫ßu: ch·ªâ d√πng class .sticky-col do JS g·∫Øn */
.progress-table .sticky-col {
    z-index: 3;
}

/* Header sticky ƒë√® l√™n body m·ªôt ch√∫t ƒë·ªÉ kh√¥ng b·ªã g√£y */
.progress-table thead .sticky-col {
    z-index: 4;
}


/* H√†ng t·ªïng h·ª£p d∆∞·ªõi c√πng */
.progress-summary-row td {
    background: #fff9c4 !important;
    font-weight: 600 !important;
}

/* === STYLE B·∫¢NG KPI TH·ªúI ƒêI·ªÇM G·∫¶N NH·∫§T === */
#latestTableWrapper {
    max-height: 800px;              /* n·∫øu b·∫£ng cao h∆°n s·∫Ω c√≥ scroll d·ªçc */
    overflow-y: auto;
    overflow-x: auto;
    position: relative;
    border: 1px solid #e5e7eb;
    border-radius: 10px;
    margin-top: 4px;
}

#latestTableWrapper table {
    width: auto;                    /* auto width theo n·ªôi dung */
    table-layout: auto;
    border-collapse: collapse;
}

/* C·ªë ƒë·ªãnh c·ªôt 1 */
#latestTableWrapper table th:first-child,
#latestTableWrapper table td:first-child {
    position: sticky;
    left: 0;
    z-index: 3;
    background: #f9fafb;
    white-space: nowrap;
}

/* Header n·∫±m tr√™n c√πng khi scroll */
#latestTableWrapper table thead th {
    top: 0;
    z-index: 4;
}
#latestTableWrapper table thead th:first-child {
    z-index: 5;
}

#kpiThresholdPanel select,
#kpiThresholdPanel input[type="number"] {
    padding: 6px 10px;
    border: 1px solid #d1d5db;
    border-radius: 8px;   /* BO TR√íN */
    font-size: 0.9em;
    background: #fff;
}

.wc-filter-input {
    padding: 4px 8px !important;
    height: 30px !important;
    min-width: 90px !important;
    background: white;
    border: 1px solid #d1d5db;
    border-radius: 6px;
}

        tr:hover {
            background: #f3f4ff;
        }

        /* WS_NAME filter */
        #wsFilterContainer {
            background: #f8fafc;
            border-radius: 10px;
            padding: 8px;
            border: 1px dashed #cbd5f5;
            max-height: 400px;
            overflow-y: auto;
        }

        #kpiFilterContainer {
            background: #f8fafc;
            border-radius: 10px;
            padding: 8px;
            border: 1px dashed #e5e7eb;
            max-height: 260px;
            overflow-y: auto;
        }

        .kpi-filter-list {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 6px 10px;
        }

        .ws-filter-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 8px;
        }

        .ws-filter-search {
            flex: 1 1 160px;
            min-width: 0;
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid #d1d5db;
            font-size: 0.85em;
        }

        .ws-filter-toolbar button {
            border: none;
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 0.8em;
            cursor: pointer;
            background: #e0e7ff;
            color: #374151;
            white-space: nowrap;
        }

        .ws-filter-toolbar button:hover {
            background: #c7d2fe;
        }

        .ws-filter-list {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 6px 10px;
        }

        .ws-chip {
            background: #eef2ff;
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 0.8em;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;
        }

        .ws-chip input {
            accent-color: #667eea;
        }

        /* KPI Overview header row */
        .excel-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .excel-date-filter {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .excel-date-filter label {
            font-size: 0.9em;
            color: #555;
        }

        .excel-date-filter input[type="date"] {
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            font-size: 0.85em;
        }

        #excelTable table {
            width: auto;
            border-collapse: collapse;
            font-size: 0.9em;
            table-layout: auto;
        }

        #excelTable {
            position: relative;
        }

        #excelTable table th,
        #excelTable table td {
            position: relative;
        }

        #excelTable .sticky-col {
            z-index: 3;
        }

        #excelTable thead .sticky-col {
            z-index: 4;
        }

        #excelTable table th:nth-child(1),
        #excelTable table td:nth-child(1),
        #excelTable table th:nth-child(2),
        #excelTable table td:nth-child(2),
        #excelTable table th:nth-child(3),
        #excelTable table td:nth-child(3),
        #excelTable table th:nth-child(4),
        #excelTable table td:nth-child(4) {
            white-space: nowrap;
        }

        /* C·ªë ƒë·ªãnh & auto-fit 4 c·ªôt ƒë·∫ßu cho Worst Cell + Cell Non-Traffic */
        #worstCellTable,
        #nonTrafficTable {
            position: relative;
        }

        #worstCellTable table th,
        #worstCellTable table td,
        #nonTrafficTable table th,
        #nonTrafficTable table td {
            position: relative;
        }

        /* 4 c·ªôt ƒë·∫ßu kh√¥ng xu·ªëng d√≤ng ‚Üí auto-fit theo n·ªôi dung */
        #worstCellTable table th:nth-child(-n+4),
        #worstCellTable table td:nth-child(-n+4),
        #nonTrafficTable table th:nth-child(-n+4),
        #nonTrafficTable table td:nth-child(-n+4) {
            white-space: nowrap;
        }

        #worstCellTable .sticky-col,
        #nonTrafficTable .sticky-col {
            z-index: 3;
        }

        #worstCellTable thead .sticky-col,
        #nonTrafficTable thead .sticky-col {
            z-index: 4;
        }





        .excel-latest-btn {
            border: none;
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 0.8em;
            cursor: pointer;
            background: #e0e7ff;
            color: #374151;
            white-space: nowrap;
        }

        .excel-latest-btn:hover {
            background: #c7d2fe;
        }

        /* Email form */
        .email-section {
            margin-top: 24px;
        }

        .email-form-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 12px;
            text-align: left;
        }

        .email-form-group label {
            font-weight: 600;
            color: #555;
            margin-bottom: 4px;
            font-size: 0.9em;
        }

        .email-form-group input,
        .email-form-group textarea {
            padding: 8px 10px;
            border-radius: 8px;
            border: 2px solid #ddd;
            font-size: 0.9em;
            transition: border-color 0.3s;
            font-family: inherit;
        }

        .email-form-group textarea {
            min-height: 120px;
            resize: vertical;
        }

        .email-form-group input:focus,
        .email-form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .email-status {
            margin-top: 8px;
            font-size: 0.85em;
            min-height: 18px;
        }

        .email-status.success {
            color: #43a047;
        }

        .email-status.error {
            color: #e53935;
        }

        .email-section-options {
            display: flex;
            flex-wrap: wrap;
            gap: 6px 10px;
            font-size: 0.85em;
        }

        .email-section-options label {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 999px;
            background: #eef2ff;
            cursor: pointer;
            user-select: none;
        }

        .email-section-options input[type="checkbox"] {
            accent-color: #667eea;
        }

        .email-actions-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            margin-top: 8px;
        }

        @media (max-width: 768px) {
            .control-grid {
                flex-direction: column;
                flex-wrap: nowrap;
            }
            #chartsContainer {
                --charts-per-row: 1;
            }
        }
        .upload-sub-actions {
            margin-top: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 14px;
        }

        .upload-sub-btn {
            background: rgba(102, 126, 234, 0.12);
            padding: 8px 16px;
            border-radius: 999px;
            cursor: pointer;
            color: #4f46e5;
            font-weight: 600;
            font-size: 0.9em;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: all 0.25s ease;
        }

        .upload-sub-btn:hover {
            background: rgba(102, 126, 234, 0.22);
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(102, 126, 234, 0.25);
        }

        .upload-sub-separator {
            color: #9ca3af;
            font-size: 0.85em;
        }
    </style>
</head>
<body>
    <!-- Logo gi·ªØ ki·ªÉu c≈©: kh√¥ng √©p CSS, ch·ªâ l√† 1 ·∫£nh -->
    <img src="Logo.png" class="corner-logo" alt="Logo" />

    <div class="container">
        <div class="header">
            <h1>üìä KPI Viewer and Report</h1>
            <div style="font-size: 0.95em; color:#6b7280; margin-top:-6px;">
                Version: v1.4.0.14
            </div>
        </div>

        <!-- Upload -->
<!-- Upload -->
<div class="upload-section">
    <div class="upload-area" id="uploadArea">
        <div class="upload-icon">üìÅ</div>
        <h3>T·∫£i file Excel KPI</h3>

<div class="upload-sub-actions">
    <!-- 1. Ch·ªçn file Excel tr√™n m√°y -->
    <label class="upload-sub-btn">
        üìÑ Ch·ªçn file Excel
        <input
            type="file"
            id="fileInputFiles"
            class="file-input"
            accept=".xlsx,.xls"
            multiple
            onchange="handleFileFromFiles(event)"
        />
    </label>

    <span class="upload-sub-separator">ho·∫∑c</span>

    <!-- 2. Ch·ªçn th∆∞ m·ª•c Excel tr√™n m√°y -->
    <label class="upload-sub-btn">
        üìÇ Ch·ªçn th∆∞ m·ª•c Excel
        <input
            type="file"
            id="fileInputFolder"
            class="file-input"
            webkitdirectory
            directory
            onchange="handleFileFromFolder(event)"
        />
    </label>

    <span class="upload-sub-separator">ho·∫∑c</span>

    <!-- 3. ƒêƒÉng nh·∫≠p OneDrive -->
    <button
        type="button"
        class="upload-sub-btn"
        id="odLoginBtn"
    >
        üîë ƒêƒÉng nh·∫≠p OneDrive
    </button>
</div>

<!-- Textbox nh·∫≠p ƒë∆∞·ªùng d·∫´n th∆∞ m·ª•c KPI tr√™n OneDrive -->
<div style="margin-top:10px;">
    <label>
        üóÇÔ∏è ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c KPI:
        <input 
            type="text" 
            id="kpiFolderInput"
            placeholder="/KPI Scheduler"
            style="width:300px; padding:6px 10px; border-radius:8px; border:1px solid #ccc;"
        />
    </label>

    <!-- D√πng id ƒë·ªÉ JS b·∫Øt s·ª± ki·ªán, KH√îNG d√πng onclick inline n·ªØa -->
    <button 
        type="button"
        id="kpiFolderUpdateBtn"
        style="margin-left:8px; padding:6px 12px; border-radius:8px; background:#4f46e5; color:white; border:none; cursor:pointer;"
    >
        C·∫≠p nh·∫≠t
    </button>
</div>



    </div>
    <!-- ‚úÖ Thanh tr·∫°ng th√°i + combobox nh√≥m file OneDrive -->
<div
    id="odGroupBar"
    style="
        margin-top:8px;
        display:none;   /* CH·ªà hi·ªán sau khi login */
        gap:8px;
        align-items:center;
        flex-wrap:wrap;
        font-size:0.9em;
    "
>

    <!-- ‚≠ê Tr·∫°ng th√°i ƒëƒÉng nh·∫≠p ‚Äî n·∫±m 1 h√†ng ri√™ng -->
    <span
        id="odStatus"
        style="
            color:#4b5563;
            width:100%;
            display:block;
            margin-bottom:4px;
        "
    >
        Ch∆∞a ƒëƒÉng nh·∫≠p
    </span>
    <!-- Th∆∞ m·ª•c OneDrive -->
    <label>
        Th∆∞ m·ª•c:
        <select
            id="odFolderSelect"
            style="margin-left:4px; padding:4px 8px; min-width:180px;"
        ></select>
    </label>

    <!-- Nh√≥m file OneDrive -->
    <label>
        Nh√≥m file:
        <select
            id="odGroupSelect"
            style="margin-left:4px; padding:4px 8px; min-width:220px;"
        ></select>
    </label>

    <!-- N√∫t ƒë·ªçc nh√≥m -->
    <button
        type="button"
        id="odLoadGroupBtn"
        style="
            padding:4px 10px;
            border-radius:6px;
            border:1px solid #2563eb;
            background:#2563eb;
            color:#fff;
            font-size:0.9em;
            cursor:pointer;
        "
    >
        üì• ƒê·ªçc nh√≥m t·ª´ OneDrive
    </button>
</div>
    <div class="file-info" id="fileInfo"></div>

    <!-- ‚úÖ Combobox ch·ªçn folder + nh√≥m file trong folder -->
    <div
        id="folderFileSelectors"
        style="
            margin-top:8px;
            display:none;
            gap:8px;
            align-items:center;
            flex-wrap:wrap;
        "
    >
        <label style="font-size:0.9em;">
            Th∆∞ m·ª•c:
            <select id="folderSelect" style="margin-left:4px; padding:4px 8px;"></select>
        </label>

        <label style="font-size:0.9em;">
            Nh√≥m file:
            <select
                id="fileGroupSelect"
                style="margin-left:4px; padding:4px 8px; min-width:220px;"
            ></select>
        </label>

        <button
            type="button"
            id="loadGroupBtn"
            style="
                padding:4px 10px;
                border-radius:6px;
                border:1px solid #2563eb;
                background:#2563eb;
                color:#fff;
                font-size:0.9em;
                cursor:pointer;
            "
        >
            Ch·ªçn nh√≥m file
        </button>
    </div>

    <div class="loading" id="loading">‚è≥ ƒêang x·ª≠ l√Ω file...</div>
</div>


<!-- TI·∫æN ƒê·ªò ƒêO KI·ªÇM (IMPORT FILE EXCEL) gi·ªØ nguy√™n ph√≠a d∆∞·ªõi -->

        <!-- TI·∫æN ƒê·ªò ƒêO KI·ªÇM (IMPORT FILE EXCEL) -->
        <div class="data-table" id="progressCard" style="margin-top: 16px;">
            <h3>Ti·∫øn ƒê·ªô ƒêo Ki·ªÉm</h3>
            <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:8px;">
                <label style="
                    display:inline-flex;
                    align-items:center;
                    padding:6px 10px;
                    border-radius:6px;
                    background:#f0f4ff;
                    border:1px solid #b0c4ff;
                    font-size:0.9em;
                    cursor:pointer;
                ">
                    üìÇ Ch·ªçn file Excel ti·∫øn ƒë·ªô
                    <input type="file" id="progressFileInput" accept=".xlsx,.xls" style="display:none;">
                </label>
                <span id="progressStatus" style="font-size:0.85em;color:#666;">
                    Ch·ªçn file Excel ti·∫øn ƒë·ªô ƒëo ki·ªÉm (t·∫£i t·ª´ Google Sheet v·ªÅ m√°y, sheet "CQT-SSV").
                </span>
                <select id="progressPOFilter" style="padding:6px 10px; border-radius:6px; border:1px solid #b0b0b0; display:none;">
                    <option value="ALL">T·∫•t c·∫£ PO</option>
                </select>
            </div>
            <div id="progressTable"></div>
        </div>



        <div class="charts-section" id="chartsSection">
            <!-- 1. T√ôY CH·ªàNH BI·ªÇU ƒê·ªí -->
            <div class="chart-controls">
                <h3>‚öôÔ∏è T√πy ch·ªânh bi·ªÉu ƒë·ªì</h3>
                <div class="control-grid">
                    <div class="control-group">
                        <label>üìÑ Sheet:</label>
                        <select id="sheetSelect" onchange="updateCharts()"></select>
                    </div>

                    <div class="control-group">
                        <label>üß© S·ªë chart tr√™n 1 h√†ng:</label>
                        <select id="chartsPerRowSelect">
                            <option value="1">1 chart / h√†ng</option>
                            <option value="2" selected>2 chart / h√†ng</option>
                            <option value="3">3 chart / h√†ng</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label>‚è± Kho·∫£ng ng√†y g·∫ßn nh·∫•t:</label>
                        <select id="daysWindowSelect">
                            <option value="7">7 ng√†y</option>
                            <option value="14" selected>14 ng√†y</option>
                            <option value="30">30 ng√†y</option>
                            <option value="40">40 ng√†y</option>
                            <option value="ALL">To√†n b·ªô</option>
                        </select>
                    </div>
                </div>

                <div class="control-group" style="margin-top: 14px">
                    <!-- ƒê√É ƒê·ªîI WS_NAME -> CELL_NAME -->
                    <label>üßµ Ch·ªçn WS/SITE/CELL_NAME hi·ªÉn th·ªã:</label>
                    <div id="wsFilterContainer"></div>
                </div>

                <!-- Ch·ªçn KPI hi·ªÉn th·ªã -->
                <div class="control-group" style="margin-top:12px;">
                    <label>üìå Ch·ªçn KPI hi·ªÉn th·ªã:</label>
                    <div id="kpiFilterContainer"></div>
                </div>


                <div class="control-group" style="margin-top:12px; max-width:240px;">
                    <label>üîÄ Th·ª© t·ª± s·∫Øp x·∫øp Funnel:</label>
                    <select id="funnelSortSelect">
                        <option value="desc" selected>L·ªõn ‚Üí nh·ªè</option>
                        <option value="asc">Nh·ªè ‚Üí l·ªõn</option>
                    </select>
                </div>

                <p style="margin-top: 10px; font-size: 0.85em; color: #666">
                    üî¢ H·ªá th·ªëng t·ª± ƒë·ªông nh·∫≠n di·ªán c·ªôt <strong>Period Time</strong> &
                    <strong>WS_NAME / LNCEL name / NRCEL name</strong> theo t√™n c·ªôt. V·∫Ω bi·ªÉu ƒë·ªì cho t·∫•t c·∫£ c√°c c·ªôt s·ªë
                    (tr·ª´ 2 c·ªôt ƒë·∫ßu). M·ªói c·ªôt s·ªë l√† m·ªôt chart, b·∫°n c√≥ th·ªÉ ch·ªçn
                    <strong>ki·ªÉu chart (line / bar / pie / doughnut / stacked area)</strong> v√†
                    <strong>s·ªë chart tr√™n 1 h√†ng</strong>.
                </p>
            </div>

            <!-- 2. KPI OVERVIEW THEO M·∫™U EXCEL -->
            <div
                class="data-table"
                id="excelTableCard"
                style="margin-top: 20px; margin-bottom: 24px"
            >
                <div class="excel-header-row">
                    <h3 id="excelTableTitle">KPI Overview (Ng√†y: ...)</h3>
                    <div class="excel-date-filter">
                        <label for="excelDateInput">Ng√†y:</label>
                        <input type="date" id="excelDateInput" />
                        <button type="button" id="excelLatestBtn" class="excel-latest-btn">Latest</button>
                    </div>
                </div>
                    <div
        id="kpiThresholdPanel"
        style="
            margin-bottom: 10px;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px dashed #d1d5db;
            background: #f9fafb;
            font-size: 0.85em;
            display: none;
        "
    >
<div style="display:flex; flex-wrap:wrap; gap:12px; align-items:center;">

    <!-- H√†ng 1: Ti√™u ƒë·ªÅ -->
    <strong>‚öôÔ∏è T√πy ch·ªânh ng∆∞·ª°ng:</strong>

    <!-- B·∫ÆT BU·ªòC TH√äM D√íNG N√ÄY ƒë·ªÉ xu·ªëng h√†ng -->
    <div style="width:100%;"></div>

    <!-- H√†ng 2: KPI + Operator + Threshold + Button -->
    <label style="display:flex; align-items:center;">
        KPI:
        <select
            id="thresholdKpiSelect"
            style="margin-left:4px; padding:4px 8px; min-width:220px;"
        ></select>
    </label>

    <label style="display:flex; align-items:center;">
        Operator:
        <select
            id="thresholdOpSelect"
            style="margin-left:4px; padding:4px 8px; min-width:80px;"
        >
            <option value="">--</option>
            <option value="<">&lt;</option>
            <option value="<=">&lt;=</option>
            <option value=">">&gt;</option>
            <option value=">=">&gt;=</option>
            <option value="=">=</option>
            <option value="==">==</option>
        </select>
    </label>

    <label style="display:flex; align-items:center;">
        Threshold:
        <input
            id="thresholdValueInput"
            type="number"
            step="any"
            style="margin-left:4px; padding:4px 6px; width:110px;"
        />
    </label>

    <button
        type="button"
        id="thresholdApplyBtn"
        style="
            padding:6px 12px;
            border-radius:6px;
            border:1px solid #2563eb;
            background:#2563eb;
            color:#fff;
            cursor:pointer;
        "
    >
        √Åp d·ª•ng
    </button>
    
    <label style="display:inline-flex; align-items:center; gap:6px; font-size:0.85em;">
        <input
            type="checkbox"
            id="thresholdGlobalToggle"
            style="accent-color:#4f46e5;"
        />
        <span>K√≠ch ho·∫°t t√πy ch·ªânh</span>
    </label>

</div>

    </div>

    <div id="excelTable"></div>
</div>

            </div>

            <!-- Charts -->
            <div id="chartsContainer"></div>

            <!-- 4. WORST CELL -->
            <div class="data-table" id="worstCellCard" style="margin-top: 10px; display:none;">
                <h3 id="worstCellTitle">Worst Cell (Th·ªùi ƒëi·ªÉm g·∫ßn nh·∫•t)</h3>

                <!-- üîé B·ªô l·ªçc gi√° tr·ªã cho b·∫£ng Worst Cell -->
                <div id="worstFilterBar"
                    style="margin:4px 0 8px; font-size:0.85em; display:flex; flex-wrap:wrap; gap:8px; align-items:center;">
                    <strong>L·ªçc theo KPI:</strong>

                    <label style="display:flex; align-items:center; gap:4px;">
                        Logic:
                        <select
                            id="worstFilterLogic"
                            style="padding:4px 6px; border-radius:6px; border:1px solid #cbd5e1;"
                        >
                            <option value="AND">AND</option>
                            <option value="OR">OR</option>
                        </select>
                    </label>

                    <button type="button" id="worstFilterAddBtn"
                            style="padding:4px 8px; border-radius:6px; border:1px solid #2563eb; background:#2563eb; color:#fff; cursor:pointer;">
                        + Th√™m ƒëi·ªÅu ki·ªán
                    </button>

                    <button type="button" id="worstFilterClearBtn"
                            style="padding:4px 8px; border-radius:6px; border:1px solid #6b7280; background:#f3f4f6; color:#111827; cursor:pointer;">
                        X√≥a filter
                    </button>

                    <!-- Danh s√°ch c√°c d√≤ng ƒëi·ªÅu ki·ªán KPI -->
                    <div id="worstFilterRules"
                        style="width:100%; margin-top:4px; display:flex; flex-direction:column; gap:4px;"></div>
                </div>

                <div id="worstCellTable"></div>
            </div>


            <!-- CELL NON-TRAFFIC -->
            <div class="data-table" id="nonTrafficCard" style="margin-top: 16px; display:none;">
                <h3 id="nonTrafficTitle">Cell Non-Traffic (Cell avail R = 0)</h3>
                <div id="nonTrafficTable"></div>
            </div>

            <!-- 3. B·∫¢NG KPI TH·ªúI ƒêI·ªÇM G·∫¶N NH·∫§T -->
            <div class="data-table" id="latestTableCard" style="margin-top: 10px">
                <h3 id="latestTableTitle">B·∫£ng KPI th·ªùi ƒëi·ªÉm g·∫ßn nh·∫•t</h3>
                <div id="latestTable"></div>
            </div>

            <!-- 4. EMAIL -->
            <div class="email-section">
                <div class="chart-card">
                    <h3>üìß G·ª≠i Email b√°o c√°o</h3>
                    <p
                        style="
                            text-align: center;
                            color: #666;
                            margin-bottom: 16px;
                            font-size: 0.9em;
                        "
                    >
                    </p>
                    <form id="emailForm">
                        <div class="email-form-group">
                            <label for="emailTo">Danh s√°ch email (c√°ch nhau b·ªüi d·∫•u ph·∫©y)</label>
                            <input
                                type="text"
                                id="emailTo"
                                name="to"
                                placeholder="vd: a@example.com, b@example.com"
                            />
                        </div>

                        <div class="email-form-group">
                            <label for="emailSubject">Ti√™u ƒë·ªÅ</label>
                            <input
                                type="text"
                                id="emailSubject"
                                name="subject"
                                placeholder="B√°o c√°o hi·ªáu su·∫•t theo ng√†y..."
                                required
                            />
                        </div>

                        <div class="email-form-group">
                            <label for="emailMessage">N·ªôi dung (m·ªü ƒë·∫ßu email)</label>
                            <textarea
                                id="emailMessage"
                                name="message"
                                placeholder="Nh·∫≠p n·ªôi dung email..."
                                required
                            ></textarea>
                            <div style="font-size: 12px; color: #6b7280; margin-top: 4px;">
                                G·ª£i √Ω: Ti√™u ƒë·ªÅ v√† N·ªôi dung c√≥ th·ªÉ d√πng placeholder 
                                <code>(POx)</code>, <code>(ng√†y g·∫ßn nh·∫•t)</code>, 
                                <code>(S·ªë tr·∫°m onair)</code>, <code>(T·ªïng s·ªë tr·∫°m POx)</code>. 
                                Khi xu·∫•t file .eml, c√°c placeholder n√†y s·∫Ω t·ª± thay b·∫±ng s·ªë li·ªáu th·ª±c t·∫ø.
                            </div>
                        </div>




                        <!-- Tick box PNG: n·∫±m NGAY d∆∞·ªõi label, m·∫∑c ƒë·ªãnh t√≠ch s·∫µn -->
                        <div style="margin:4px 0 8px 0;">
                            <label style="font-size:13px;">
                                <input
                                    type="checkbox"
                                    id="emailTablesAsImages"
                                    checked
                                >
                                Xu·∫•t c√°c b·∫£ng d∆∞·ªõi d·∫°ng h√¨nh PNG
                            </label>
                        </div>

                        <!-- CH·ªåN SECTION ƒê∆ØA V√ÄO EMAIL -->
                        <div class="email-form-group">
                        <label>C√°c ph·∫ßn s·∫Ω ch√®n v√†o email</label>

                        <div class="email-section-options">
                            <label>
                                <input type="checkbox" class="email-section-checkbox" value="progress" checked>
                                Ti·∫øn ƒë·ªô ƒëo ki·ªÉm
                            </label>
                            <label>
                                <input type="checkbox" class="email-section-checkbox" value="excel" checked>
                                KPI Overview
                            </label>
                            <label>
                                <input type="checkbox" class="email-section-checkbox" value="charts" checked>
                                Bi·ªÉu ƒë·ªì KPI
                            </label>
                            <label>
                                <input type="checkbox" class="email-section-checkbox" value="worst" checked>
                                Worst Cell
                            </label>
                            <label>
                                <input type="checkbox" class="email-section-checkbox" value="nonTraffic" checked>
                                Cell Non-Traffic
                            </label>
                        </div>



                        </div>

                        <div class="email-actions-row">
                            <button type="button" id="exportEmlChartsBtn" class="btn">
                                üíæ Xu·∫•t file Outlook
                            </button>


                        </div>
                        <div class="email-status" id="emailStatus"></div>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <script>
        let workbook = null;
        let currentData = null;
        let chartInstances = {};
        let numericColumns = [];
        let wsFilterValues = null;
        let currentWsValues = [];
        let periodColumnName = null;
        let wsNameColumnName = null;
        let chartDaysWindow = 14;
        let selectedKpiColumns = new Set();
        let mergedDataPerSheet = null;

        let wsSearchKeywords = ["", "", ""];
        let kpiMetaMap = {};
        let kpiMetaList = [];
        let excelSelectedDate = null;
        let funnelSortOrder = "desc";
        let emailIntroTouched = false;
        let chartConfigAppliedOnce = false;   // √°p sheet t·ª´ c·∫•u h√¨nh c≈© ƒë√∫ng 1 l·∫ßn
        let chartTargetVisible = {}; // NEW: l∆∞u tr·∫°ng th√°i checkbox "Target" theo t·ª´ng KPI
        let globalThresholdEnabled = false; // Checkbox t·ªïng: Target column + highlight + target line

        // ===== LINK TH∆Ø M·ª§C KPI TR√äN ONEDRIVE (C√ÅCH 2) =====
        const ONEDRIVE_KPI_URL = "https://rnovnpt-my.sharepoint.com/personal/anhnqt_rnovnpt_onmicrosoft_com/_layouts/15/onedrive.aspx?id=%2Fpersonal%2Fanhnqt%5Frnovnpt%5Fonmicrosoft%5Fcom%2FDocuments%2FKPI%20Scheduler&ga=1";

        // M·ªü th∆∞ m·ª•c KPI tr√™n OneDrive trong tab m·ªõi
        function openOneDriveKpiFolder() {
            // N·∫øu sau n√†y ƒë·ªïi link, ch·ªâ c·∫ßn s·ª≠a ONEDRIVE_KPI_URL ·ªü tr√™n
            window.open(ONEDRIVE_KPI_URL, "_blank");
        }


        // B·∫¢NG NG∆Ø·ª†NG KPI
        let kpiThresholdMap = null;
        let customThresholdMap = {}; // l∆∞u t√πy ch·ªânh vƒ©nh vi·ªÖn
        let worstCellThresholdMap = null;   // sheet "WorstCell Threshold"
        // ==== C·∫§U H√åNH FILE KPI N·∫∂NG ====
        const HEAVY_KPI_ROW_THRESHOLD = 5000;   // > 3k d√≤ng coi l√† file n·∫∑ng
        let isHeavyKpiFile = false;

        Chart.register(ChartDataLabels);

        function updateWsSearchKeywordsFromInputs() {
            const i1 = document.getElementById("wsSearchInput1");
            const i2 = document.getElementById("wsSearchInput2");
            const i3 = document.getElementById("wsSearchInput3");
            wsSearchKeywords = [
                i1 ? i1.value : "",
                i2 ? i2.value : "",
                i3 ? i3.value : "",
            ];
        }
        // Load custom thresholds t·ª´ LocalStorage
        function loadCustomThresholds() {
            try {
                const data = localStorage.getItem("customThresholdMap");
                if (data) {
                    customThresholdMap = JSON.parse(data);
                }
            } catch (e) {
                console.error("Cannot load custom thresholds", e);
            }
        }
        loadCustomThresholds();
        function wsPassesTextFilters(wsLower) {
            for (const kw of wsSearchKeywords) {
                const trimmed = (kw || "").trim().toLowerCase();
                if (!trimmed) continue;

                const terms = trimmed
                    .split(";")
                    .map((t) => t.trim())
                    .filter(Boolean);
                if (!terms.length) continue;

                const matchesThisBox = terms.some((term) => wsLower.includes(term));
                if (!matchesThisBox) {
                    return false;
                }
            }
            return true;
        }

        // Drag & drop ch·ªâ ho·∫°t ƒë·ªông khi tr√™n trang c√≥ ph·∫ßn t·ª≠ #uploadArea
const uploadArea = document.getElementById("uploadArea");

if (uploadArea) {
    uploadArea.addEventListener("dragover", (e) => {
        e.preventDefault();
        uploadArea.classList.add("dragover");
    });

    uploadArea.addEventListener("dragleave", () => {
        uploadArea.classList.remove("dragover");
    });

    uploadArea.addEventListener("drop", (e) => {
        e.preventDefault();
        uploadArea.classList.remove("dragover");

        const files = Array.from(e.dataTransfer.files || []).filter(f =>
            /\.(xlsx|xls)$/i.test(f.name)
        );

        if (!files.length) {
            alert("K√©o th·∫£ kh√¥ng c√≥ file Excel (.xlsx, .xls) h·ª£p l·ªá!");
            return;
        }

        if (files.length === 1) {
            processFile(files[0]);
        } else {
            processMultipleFiles(files);
        }
    });
}


        function handleFileFromFiles(e) {
            const files = Array.from(e.target.files || []).filter(f =>
                /\.(xlsx|xls)$/i.test(f.name)
            );
            if (!files.length) return;

            if (files.length === 1) {
                processFile(files[0]);
            } else {
                processMultipleFiles(files);
            }
        }

        // ====== Bi·∫øn global l∆∞u map folder & nh√≥m file ======
        let folderFileMap = {};      // { folderName: File[] }
        let currentFolderName = "";
        let currentGroupMap = {};    // { groupName: File[] }

// L·∫•y t√™n folder con.
// N·∫øu t·∫•t c·∫£ file n·∫±m ngay trong th∆∞ m·ª•c ƒë∆∞·ª£c ch·ªçn (kh√¥ng c√≥ folder con)
// th√¨ tr·∫£ v·ªÅ "(ROOT)"
        function getFolderNameFromFile(file) {
            const rel = file.webkitRelativePath;

            if (!rel) {
                // Tr∆∞·ªùng h·ª£p ch·ªçn t·ª´ng file (kh√¥ng ph·∫£i ch·ªçn th∆∞ m·ª•c)
                return "(ROOT)";
            }

            // Chu·∫©n h√≥a c·∫£ / v√† \
            const parts = rel.split(/[\\/]/);
            // V√≠ d·ª•:
            //  - Ch·ªçn folder: KPI Scheduler
            //    + Kh√¥ng c√≥ folder con: "KPI Scheduler\\file1.xlsx"  -> parts.length = 2
            //    + C√≥ folder con:       "KPI Scheduler\\Sub\\f1.xlsx" -> parts.length >= 3

            if (parts.length <= 2) {
                // Ch·ªâ c√≥ [T√™n th∆∞ m·ª•c ƒë∆∞·ª£c ch·ªçn, T√™n file]
                return "(ROOT)";
            }

            // C√≥ folder con
            return parts[1] || "(ROOT)";
        }



        // L·∫•y group name = ph·∫ßn tr∆∞·ªõc d·∫•u "-" trong t√™n file
        // 5G_KPI_Daily_Report-vnpt_tec-2025_11_20-... -> 5G_KPI_Daily_Report
        function getGroupNameFromFile(file) {
            const name = file.name || "";
            const idx = name.indexOf("-");
            if (idx > 0) {
                return name.substring(0, idx);
            }
            // kh√¥ng c√≥ d·∫•u "-" th√¨ tr·∫£ lu√¥n full name
            return name;
        }

// Gi√° tr·ªã ƒë·∫∑c bi·ªát cho l·ª±a ch·ªçn "T·∫•t c·∫£"
// Gi√° tr·ªã ƒë·∫∑c bi·ªát cho l·ª±a ch·ªçn "T·∫•t c·∫£"
const ALL_FOLDERS_VALUE = "__ALL__";

function populateFolderSelectOptions() {
    const folderSelect = document.getElementById("folderSelect");
    const groupSelect  = document.getElementById("fileGroupSelect");
    const wrapper      = document.getElementById("folderFileSelectors");

    if (!folderSelect || !groupSelect || !wrapper) return;

    // T·∫•t c·∫£ folder ƒë·ªçc ƒë∆∞·ª£c t·ª´ th∆∞ m·ª•c KPI (local)
    const allFolderNames = Object.keys(folderFileMap);

    if (!allFolderNames.length) {
        wrapper.style.display = "none";
        return;
    }

    // Tr∆∞·ªùng h·ª£p ch·ªâ c√≥ ROOT
    const hasOnlyRoot =
        allFolderNames.length === 1 && allFolderNames[0] === "(ROOT)";

    wrapper.style.display = "flex";

    if (hasOnlyRoot) {
        // Ch·ªâ c√≥ ROOT ‚Üí ·∫©n combobox Th∆∞ m·ª•c, ch·ªâ hi·ªán Nh√≥m file
        folderSelect.parentElement.style.display = "none";

        currentFolderName = "(ROOT)";
        buildGroupMapForCurrentFolder("(ROOT)");
        return;
    }

    // üîπ C√≥ folder con ‚Üí ch·ªâ gi·ªØ nh·ªØng th∆∞ m·ª•c b·∫Øt ƒë·∫ßu b·∫±ng "NA"
    let folderNames = allFolderNames.filter((name) => /^NA/i.test(name));

    // N·∫øu kh√¥ng c√≥ th∆∞ m·ª•c NAxx n√†o th√¨ fallback v·ªÅ to√†n b·ªô danh s√°ch
    // (ƒë·ªÉ tr√°nh tr∆∞·ªùng h·ª£p th∆∞ m·ª•c kh√¥ng c√≥ NA nh∆∞ng v·∫´n d√πng ƒë∆∞·ª£c)
    if (!folderNames.length) {
        folderNames = allFolderNames;
    }

    // Hi·ªán combobox Th∆∞ m·ª•c + th√™m l·ª±a ch·ªçn "T·∫•t c·∫£"
    folderSelect.parentElement.style.display = "inline-block";

    folderSelect.innerHTML = "";

    // ‚ûï Option "T·∫•t c·∫£"
    const allOpt = document.createElement("option");
    allOpt.value = ALL_FOLDERS_VALUE;
    allOpt.textContent = "T·∫•t c·∫£";
    folderSelect.appendChild(allOpt);

    // C√°c folder c√≤n l·∫°i (ƒë√£ l·ªçc)
    folderNames.sort().forEach((folder) => {
        const opt = document.createElement("option");
        opt.value = folder;
        opt.textContent = folder;
        folderSelect.appendChild(opt);
    });

    // M·∫∑c ƒë·ªãnh ch·ªçn "T·∫•t c·∫£"
    currentFolderName = ALL_FOLDERS_VALUE;
    folderSelect.value = ALL_FOLDERS_VALUE;
    buildGroupMapForCurrentFolder(ALL_FOLDERS_VALUE);
}

function buildGroupMapForCurrentFolder(folderName) {
    const folderSelect = document.getElementById("folderSelect");
    const groupSelect = document.getElementById("fileGroupSelect");
    if (!groupSelect) return;

    // ∆Øu ti√™n: tham s·ªë truy·ªÅn v√†o -> gi√° tr·ªã combobox -> folder hi·ªán t·∫°i
    let effectiveFolder =
        folderName ||
        (folderSelect && folderSelect.value) ||
        currentFolderName ||
        "(ROOT)";


    currentFolderName = effectiveFolder;

    let filesInFolder = [];

    if (effectiveFolder === ALL_FOLDERS_VALUE) {
        // ‚úÖ T·∫•t c·∫£ folder: g·ªôp to√†n b·ªô file trong folderFileMap
        Object.values(folderFileMap).forEach(list => {
            filesInFolder = filesInFolder.concat(list);
        });
    } else {
        // M·ªôt folder c·ª• th·ªÉ
        filesInFolder = folderFileMap[effectiveFolder] || [];
    }

    currentGroupMap = {};

    filesInFolder.forEach((file) => {
        const gName = getGroupNameFromFile(file); // h√†m anh ƒëang d√πng
        if (!currentGroupMap[gName]) currentGroupMap[gName] = [];
        currentGroupMap[gName].push(file);
    });

    const groupNames = Object.keys(currentGroupMap).sort();

    groupSelect.innerHTML = "";
    groupNames.forEach((g) => {
        const opt = document.createElement("option");
        opt.value = g;
        opt.textContent = `${g} (${currentGroupMap[g].length} file)`;
        groupSelect.appendChild(opt);
    });

    if (groupNames.length) {
        groupSelect.value = groupNames[0];
    }
}

        function loadSelectedGroupFiles() {
            const groupSelect = document.getElementById("fileGroupSelect");
            if (!groupSelect) return;
            const gName = groupSelect.value;
            const files = currentGroupMap[gName] || [];

            if (!files.length) {
                alert("Nh√≥m file ƒëang ch·ªçn kh√¥ng c√≥ file Excel n√†o.");
                return;
            }

            // G·ªçi l·∫°i logic g·ªôp nhi·ªÅu file c√≥ s·∫µn
            processMultipleFiles(files);
        }
// ========== OneDrive Graph API ‚Äì ƒë·ªçc tr·ª±c ti·∫øp file (KPI Scheduler) ==========

// 1. C·∫•u h√¨nh ·ª©ng d·ª•ng Azure AD (anh T·ª∞ THAY clientId / tenantId cho ƒë√∫ng)
const msalConfig = {
    auth: {
        clientId: "25293ad9-adbd-4a01-b437-790c1846deb6", // TODO: thay b·∫±ng Application (client) ID t·ª´ Azure portal
        authority: "https://login.microsoftonline.com/59368d93-4334-44cb-86ac-acd0bde56fcd", // TODO: thay b·∫±ng Directory (tenant) ID
        redirectUri: window.location.origin
    }
};

// Ph·∫°m vi ch·ªâ c·∫ßn ƒë·ªÉ ƒë·ªçc file trong OneDrive
const loginRequest = {
    scopes: ["Files.Read.All"]
};

// ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c KPI trong OneDrive (t∆∞∆°ng ƒë·ªëi so v·ªõi root)
// V√≠ d·ª• chu·∫©n v·ªõi link anh g·ª≠i: "/Documents/KPI Scheduler"
const graphKpiConfig = {
    kpiFolderPath: "/KPI Scheduler"
};

// Bi·∫øn d√πng chung
let msalInstance = null;
let oneDriveAccount = null;
// Map th∆∞ m·ª•c OneDrive -> danh s√°ch file (metadata)
let oneDriveFolderFileMap = {}; // { folderName: [{ itemId, name, downloadUrl, lastModified }] }
let oneDriveCurrentFolderName = "";
// Map nh√≥m file trong th∆∞ m·ª•c ƒëang ch·ªçn
let oneDriveGroupMap = {}; // { groupName: [{ itemId, name, downloadUrl, lastModified }] }


// Kh·ªüi t·∫°o UI OneDrive: g·∫Øn event cho c√°c n√∫t / select
function initOneDriveGraphUI() {
    if (typeof msal === "undefined") {
        console.warn(
            "MSAL library ch∆∞a ƒë∆∞·ª£c load ‚Äì ki·ªÉm tra <script src='...msal-browser.min.js'>"
        );
        return;
    }

    msalInstance = new msal.PublicClientApplication(msalConfig);

    // N·∫øu ƒë√£ c√≥ account t·ª´ session tr∆∞·ªõc th√¨ l·∫•y l·∫°i
    const accounts = msalInstance.getAllAccounts();
    if (accounts && accounts.length > 0) {
        oneDriveAccount = accounts[0];
    }

    const loginBtn           = document.getElementById("odLoginBtn");
    const loadGroupBtn       = document.getElementById("odLoadGroupBtn");
    const statusSpan         = document.getElementById("odStatus");
    const statusRow          = document.getElementById("odGroupBar"); // d√πng ƒë√∫ng id
    const kpiFolderInput     = document.getElementById("kpiFolderInput");
    const kpiFolderUpdateBtn = document.getElementById("kpiFolderUpdateBtn");

    // G√°n s·∫µn ƒë∆∞·ªùng d·∫´n ƒëang c·∫•u h√¨nh v√†o textbox
    if (kpiFolderInput) {
        kpiFolderInput.value = graphKpiConfig.kpiFolderPath || "/";
    }

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i ban ƒë·∫ßu
    if (statusSpan) {
        if (oneDriveAccount) {
            if (statusRow) statusRow.style.display = "flex";
            statusSpan.textContent =
                "ƒê√£ ƒëƒÉng nh·∫≠p: " +
                (oneDriveAccount.username || oneDriveAccount.name || "") +
                " ‚Äì Th∆∞ m·ª•c: " +
                (graphKpiConfig.kpiFolderPath || "/");

            // N·∫øu ƒë√£ c√≥ session ƒëƒÉng nh·∫≠p ‚Üí load lu√¥n danh s√°ch nh√≥m
            odLoadKpiGroupsFromOneDrive();
        } else {
            statusSpan.textContent = "Ch∆∞a ƒëƒÉng nh·∫≠p";
            if (statusRow) statusRow.style.display = "none";
        }
    }

    if (loginBtn) {
        loginBtn.addEventListener("click", async () => {
            await handleOneDriveLogin();
        });
    }

    if (loadGroupBtn) {
        loadGroupBtn.addEventListener("click", async () => {
            await odLoadSelectedGroupFromOneDrive();
        });
    }

    // Khi b·∫•m ‚ÄúC·∫≠p nh·∫≠t‚Äù ‚Üí ƒë·ªïi kpiFolderPath + load l·∫°i combobox
    if (kpiFolderUpdateBtn) {
        kpiFolderUpdateBtn.addEventListener("click", async () => {
            await updateKpiFolderPathAndReload();
        });
    }

    // Nh·∫•n Enter trong textbox c≈©ng nh∆∞ b·∫•m n√∫t C·∫≠p nh·∫≠t
    if (kpiFolderInput) {
        kpiFolderInput.addEventListener("keydown", async (evt) => {
            if (evt.key === "Enter") {
                evt.preventDefault();
                await updateKpiFolderPathAndReload();
            }
        });
    }
}

async function updateKpiFolderPathAndReload() {
    const input = document.getElementById("kpiFolderInput");
    const statusSpan = document.getElementById("odStatus");

    if (!input) return;

    const newPath = input.value.trim();

    if (!newPath) {
        alert("Vui l√≤ng nh·∫≠p ƒë∆∞·ªùng d·∫´n th∆∞ m·ª•c, v√≠ d·ª•: /KPI Scheduler");
        return;
    }

    // C·∫≠p nh·∫≠t c·∫•u h√¨nh
    graphKpiConfig.kpiFolderPath = newPath;

    // C·∫≠p nh·∫≠t text tr·∫°ng th√°i (n·∫øu ƒë√£ ƒëƒÉng nh·∫≠p)
    if (statusSpan && oneDriveAccount) {
        statusSpan.textContent =
            "ƒê√£ ƒëƒÉng nh·∫≠p: " +
            (oneDriveAccount.username || oneDriveAccount.name || "") +
            " ‚Äì Th∆∞ m·ª•c: " +
            (graphKpiConfig.kpiFolderPath || "/");
    }

    // N·∫øu ƒë√£ ƒëƒÉng nh·∫≠p OneDrive ‚Üí load l·∫°i danh s√°ch nh√≥m theo path m·ªõi
    if (oneDriveAccount) {
        await odLoadKpiGroupsFromOneDrive();
    } else {
        alert("ƒê√£ c·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n, h√£y ƒëƒÉng nh·∫≠p OneDrive ƒë·ªÉ ƒë·ªçc danh s√°ch file.");
    }
}

// ƒêƒÉng nh·∫≠p OneDrive (popup)
// ƒêƒÉng nh·∫≠p OneDrive (popup)
async function handleOneDriveLogin() {
    const statusSpan = document.getElementById("odStatus");
    const statusRow  = document.getElementById("odGroupBar");

    try {
        if (!msalInstance) {
            msalInstance = new msal.PublicClientApplication(msalConfig);
        }

        const loginResp = await msalInstance.loginPopup(loginRequest);
        oneDriveAccount = loginResp.account;

        if (statusRow) statusRow.style.display = "flex";
        if (statusSpan) {
            statusSpan.textContent =
                "ƒê√£ ƒëƒÉng nh·∫≠p: " +
                (oneDriveAccount.username || oneDriveAccount.name || "") +
                " ‚Äì Th∆∞ m·ª•c: " +
                (graphKpiConfig.kpiFolderPath || "/");
        }

        // Sau khi login xong ‚Üí load danh s√°ch nh√≥m file trong th∆∞ m·ª•c KPI Scheduler
        await odLoadKpiGroupsFromOneDrive();
    } catch (err) {
        console.error("L·ªói ƒëƒÉng nh·∫≠p OneDrive:", err);
        if (statusSpan) {
            statusSpan.textContent = "ƒêƒÉng nh·∫≠p th·∫•t b·∫°i";
        }
        if (statusRow) statusRow.style.display = "flex"; // v·∫´n hi·ªán ƒë·ªÉ th·∫•y l·ªói
        alert(
            "Kh√¥ng ƒëƒÉng nh·∫≠p ƒë∆∞·ª£c OneDrive. Ki·ªÉm tra l·∫°i c·∫•u h√¨nh Azure AD v√† th·ª≠ l·∫°i.\n" +
                err.message
        );
    }
}

// L·∫•y access token ƒë·ªÉ g·ªçi Graph
async function getGraphAccessToken() {
    if (!msalInstance) {
        msalInstance = new msal.PublicClientApplication(msalConfig);
    }

    const account = oneDriveAccount || (msalInstance.getAllAccounts()[0] || null);
    if (!account) {
        // Ch∆∞a login ‚Üí b·∫≠t popup
        const loginResp = await msalInstance.loginPopup(loginRequest);
        oneDriveAccount = loginResp.account;
    }

    const request = {
        ...loginRequest,
        account: oneDriveAccount || msalInstance.getAllAccounts()[0]
    };

    try {
        const tokenResp = await msalInstance.acquireTokenSilent(request);
        return tokenResp.accessToken;
    } catch (silentErr) {
        console.warn("Silent token th·∫•t b·∫°i, fallback loginPopup:", silentErr);
        const tokenResp = await msalInstance.acquireTokenPopup(request);
        return tokenResp.accessToken;
    }
}

// Helper g·ªçi Graph API tr·∫£ v·ªÅ JSON
async function graphGetJson(endpoint) {
    const token = await getGraphAccessToken();
    const url = "https://graph.microsoft.com/v1.0" + endpoint;

    const res = await fetch(url, {
        headers: {
            Authorization: "Bearer " + token
        }
    });

    if (!res.ok) {
        const txt = await res.text();
        throw new Error("Graph API l·ªói " + res.status + ": " + txt);
    }

    return res.json();
}

// L·∫•y danh s√°ch file trong th∆∞ m·ª•c KPI Scheduler, build group theo prefix
// ================= OneDrive: Folder + Nh√≥m file gi·ªëng local =================

// Build l·∫°i combobox Th∆∞ m·ª•c OneDrive & Nh√≥m file OneDrive d·ª±a tr√™n oneDriveFolderFileMap
function odPopulateFolderSelectOptions() {
    const folderSelect = document.getElementById("odFolderSelect");
    const groupSelect  = document.getElementById("odGroupSelect");

    if (!folderSelect || !groupSelect) return;

    // L·∫•y to√†n b·ªô t√™n folder th·∫≠t s·ª± c√≥ file
    const allFolders = Object.keys(oneDriveFolderFileMap);

    if (!allFolders.length) {
        // Kh√¥ng c√≥ file Excel n√†o trong th∆∞ m·ª•c KPI
        folderSelect.parentElement.style.display = "none";
        groupSelect.innerHTML = "";
        oneDriveGroupMap = {};
        return;
    }

    const hasOnlyRoot = allFolders.length === 1 && allFolders[0] === "(ROOT)";

    // Lu√¥n hi·ªÉn th·ªã thanh tr·∫°ng th√°i; ch·ªâ ·∫©n/hi·ªán combobox Th∆∞ m·ª•c
    if (hasOnlyRoot) {
        // Ch·ªâ c√≥ ROOT ‚Üí ·∫©n combobox Th∆∞ m·ª•c, ch·ªâ hi·ªán Nh√≥m file
        folderSelect.parentElement.style.display = "none";

        oneDriveCurrentFolderName = "(ROOT)";
        odBuildGroupMapForCurrentFolder("(ROOT)");
        return;
    }

    // üîé CH·ªà GI·ªÆ C√ÅC FOLDER B·∫ÆT ƒê·∫¶U B·∫∞NG "NA"
    let displayFolders = allFolders.filter(name => /^NA/i.test(name || ""));

    // N·∫øu kh√¥ng c√≥ folder NA n√†o th√¨ fallback: d√πng t·∫•t c·∫£ folder tr·ª´ (ROOT)
    if (!displayFolders.length) {
        displayFolders = allFolders.filter(name => name !== "(ROOT)");
    }

    // C√≥ folder con ‚Üí hi·ªán combobox Th∆∞ m·ª•c + th√™m l·ª±a ch·ªçn "T·∫•t c·∫£"
    folderSelect.parentElement.style.display = "inline-block";

    folderSelect.innerHTML = "";

    // ‚ûï Option "T·∫•t c·∫£"
    const allOpt = document.createElement("option");
    allOpt.value = ALL_FOLDERS_VALUE;
    allOpt.textContent = "T·∫•t c·∫£";
    folderSelect.appendChild(allOpt);

    // C√°c folder c√≤n l·∫°i (ƒë√£ l·ªçc ch·ªâ c√≤n NAxx)
    displayFolders.sort().forEach((folder) => {
        const opt = document.createElement("option");
        opt.value = folder;
        opt.textContent = folder;
        folderSelect.appendChild(opt);
    });

    // M·∫∑c ƒë·ªãnh ch·ªçn "T·∫•t c·∫£"
    oneDriveCurrentFolderName = ALL_FOLDERS_VALUE;
    folderSelect.value = ALL_FOLDERS_VALUE;
    odBuildGroupMapForCurrentFolder(ALL_FOLDERS_VALUE);
}

// Build oneDriveGroupMap (nh√≥m file) theo folder ƒëang ch·ªçn
// Build oneDriveGroupMap (nh√≥m file) theo folder ƒëang ch·ªçn
function odBuildGroupMapForCurrentFolder(folderName) {
    const folderSelect = document.getElementById("odFolderSelect");
    const groupSelect  = document.getElementById("odGroupSelect");
    if (!groupSelect) return;

    let effectiveFolder =
        folderName ||
        (folderSelect && folderSelect.value) ||
        oneDriveCurrentFolderName ||
        "(ROOT)";

    oneDriveCurrentFolderName = effectiveFolder;

    let filesInFolder = [];

    if (effectiveFolder === ALL_FOLDERS_VALUE) {
        // üîÅ G·ªôp t·∫•t c·∫£ folder NAxx (v√† b·ªè qua c√°c folder kh√°c nh∆∞ Report, Test,‚Ä¶)
        const allFolders = Object.keys(oneDriveFolderFileMap);
        let includeFolders = allFolders.filter(name => /^NA/i.test(name || ""));

        // N·∫øu kh√¥ng c√≥ folder NA n√†o th√¨ d√πng to√†n b·ªô (gi·ªØ nguy√™n behaviour c≈©)
        if (!includeFolders.length) {
            includeFolders = allFolders;
        }

        includeFolders.forEach((name) => {
            const list = oneDriveFolderFileMap[name] || [];
            filesInFolder = filesInFolder.concat(list);
        });
    } else {
        // M·ªôt folder c·ª• th·ªÉ
        filesInFolder = oneDriveFolderFileMap[effectiveFolder] || [];
    }

    oneDriveGroupMap = {};

    filesInFolder.forEach((item) => {
        const gName = getGroupNameFromFile(item); // d√πng c√πng logic group nh∆∞ local
        if (!oneDriveGroupMap[gName]) oneDriveGroupMap[gName] = [];
        oneDriveGroupMap[gName].push(item);
    });

    const groupNames = Object.keys(oneDriveGroupMap).sort();

    groupSelect.innerHTML = "";
    groupNames.forEach((g) => {
        const opt = document.createElement("option");
        opt.value = g;
        opt.textContent = `${g} (${oneDriveGroupMap[g].length} file)`;
        groupSelect.appendChild(opt);
    });

    if (groupNames.length) {
        groupSelect.value = groupNames[0];
    }
}

// Tr·∫£ v·ªÅ map: { folderName: [ { itemId, name, downloadUrl, lastModified } ] }
// ƒê·ªçc c√°c file Excel ƒë∆∞·ª£c share (SharedWithMe) c√≥ li√™n quan t·ªõi ƒë∆∞·ªùng d·∫´n KPI
async function odLoadSharedExcelFilesForKpiPath() {
    // L·∫•y t·ª´ kh√≥a cu·ªëi c·ªßa ƒë∆∞·ªùng d·∫´n KPI, v√≠ d·ª•: "/Documents/KPI Scheduler" -> "KPI Scheduler"
    const rawPath = graphKpiConfig.kpiFolderPath || "/";
    let keyword = rawPath
        .split("/")
        .filter(Boolean)
        .pop() || "";
    keyword = keyword.toLowerCase();

    // G·ªçi Graph API sharedWithMe
    const data = await graphGetJson("/me/drive/sharedWithMe");
    const items = (data && data.value) || [];

    const isExcel = (name) => /\.(xlsx|xlsm?|xls)$/i.test(name || "");
    const resultMap = {}; // { folderName: [item...] }

    items.forEach((it) => {
        const remote = it.remoteItem || {};
        const name = remote.name || it.name || "";
        if (!isExcel(name)) return;

        const parentRef  = remote.parentReference || {};
        const parentPath = (parentRef.path || "").toLowerCase();

        // N·∫øu c√≥ c·∫•u h√¨nh KPI path, ch·ªâ gi·ªØ c√°c file m√† path cha c√≥ ch·ª©a keyword (vd "KPI Scheduler")
        if (keyword && parentPath && !parentPath.includes(keyword)) {
            return;
        }

        const folderName = parentRef.name || "Shared (t·ª´ ng∆∞·ªùi kh√°c)";

        if (!resultMap[folderName]) {
            resultMap[folderName] = [];
        }

        resultMap[folderName].push({
            itemId: remote.id || it.id,
            name,
            downloadUrl:
                (remote["@microsoft.graph.downloadUrl"]) ||
                it["@microsoft.graph.downloadUrl"] ||
                null,
            lastModified:
                remote.lastModifiedDateTime ||
                it.lastModifiedDateTime ||
                ""
        });
    });

    return resultMap;
}

// ƒê·ªçc th∆∞ m·ª•c KPI ƒë∆∞·ª£c share (SharedWithMe) b·∫±ng remoteItem
// D√πng t√™n th∆∞ m·ª•c cu·ªëi trong graphKpiConfig.kpiFolderPath, v√≠ d·ª•:
//  "/KPI Scheduler"  -> t√¨m folder share t√™n "KPI Scheduler"

// ƒê·ªá quy duy·ªát to√†n b·ªô c√¢y th∆∞ m·ª•c trong 1 drive, l·∫•y t·∫•t c·∫£ file Excel
async function getAllExcelFiles(driveId, rootFolderId) {
    const result = [];
    const isExcel = (name) => /\.(xlsx|xlsm?|xls)$/i.test(name || "");

    async function traverse(folderId) {
        const childrenData = await graphGetJson(
            `/drives/${encodeURIComponent(driveId)}/items/${encodeURIComponent(folderId)}/children`
        );
        const children = (childrenData && childrenData.value) || [];

        for (const c of children) {
            if (c.folder) {
                // üëâ c√≥ subfolder th√¨ ƒëi ti·∫øp
                await traverse(c.id);
            } else if (isExcel(c.name)) {
                result.push({
                    itemId: c.id,
                    name: c.name,
                    downloadUrl: c["@microsoft.graph.downloadUrl"] || null,
                    lastModified: c.lastModifiedDateTime || ""
                });
            }
        }
    }

    await traverse(rootFolderId);
    return result;
}


// ƒê·ªçc th∆∞ m·ª•c KPI share (v√≠ d·ª• /KPI Scheduler) + t√°ch t·ª´ng subfolder cho combobox Th∆∞ m·ª•c
// ƒê·ªçc th∆∞ m·ª•c KPI ƒë∆∞·ª£c share (SharedWithMe) b·∫±ng remoteItem
// D√πng t√™n th∆∞ m·ª•c cu·ªëi trong graphKpiConfig.kpiFolderPath, v√≠ d·ª•:
// "/KPI Scheduler"  -> t√¨m folder share t√™n "KPI Scheduler"
async function odLoadKpiSharedFolderViaRemoteItem() {
    const rawPath = graphKpiConfig.kpiFolderPath || "/";
    const folderName = rawPath
        .split("/")
        .filter(Boolean)
        .pop(); // l·∫•y ƒëo·∫°n cu·ªëi

    if (!folderName) {
        console.warn("Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c t√™n th∆∞ m·ª•c t·ª´ kpiFolderPath:", rawPath);
        return {};
    }

    const folderNameLower = folderName.toLowerCase();

    // 1. T√¨m th∆∞ m·ª•c share t∆∞∆°ng ·ª©ng trong /me/drive/sharedWithMe
    const data  = await graphGetJson("/me/drive/sharedWithMe");
    const items = (data && data.value) || [];

    let targetRemote = null;

    for (const it of items) {
        const remote = it.remoteItem;
        if (!remote) continue;
        if (!remote.folder) continue; // ch·ªâ quan t√¢m th∆∞ m·ª•c share

        const remoteName = (remote.name || "").toLowerCase();
        if (remoteName === folderNameLower) {
            targetRemote = remote;
            break;
        }
    }

    if (!targetRemote) {
        console.warn("Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c share t√™n:", folderName);
        return {};
    }

    // 2. L·∫•y driveId + itemId th·∫≠t c·ªßa folder share
    const driveId = targetRemote.parentReference
        ? targetRemote.parentReference.driveId
        : null;
    const itemId  = targetRemote.id;

    if (!driveId || !itemId) {
        console.warn("remoteItem kh√¥ng c√≥ driveId ho·∫∑c id:", targetRemote);
        return {};
    }

    // 3. ƒê·ªá quy duy·ªát T·∫§T C·∫¢ subfolder ƒë·ªÉ l·∫•y file Excel
    const isExcel = (name) => /\.(xlsx|xls)$/i.test(name || "");
    const resultMap = {}; // { folderKey: [ { itemId, name, downloadUrl, lastModified } ] }

    async function traverse(folderId, pathParts) {
        const childrenData = await graphGetJson(
            `/drives/${encodeURIComponent(driveId)}/items/${encodeURIComponent(folderId)}/children`
        );
        const children = (childrenData && childrenData.value) || [];

        for (const c of children) {
            if (c.folder) {
                // Ti·∫øp t·ª•c ƒë·ªá quy xu·ªëng subfolder
                const nextParts = pathParts.concat(c.name || "");
                await traverse(c.id, nextParts);
            } else if (isExcel(c.name)) {
                // X√°c ƒë·ªãnh kh√≥a folder ƒë·ªÉ group gi·ªëng th∆∞ m·ª•c local:
                //  - File n·∫±m ngay trong th∆∞ m·ª•c share g·ªëc -> d√πng t√™n folder share
                //  - File n·∫±m trong subfolder -> d√πng t√™n subfolder c·∫•p 1
                let folderKey = folderName;
                if (pathParts.length > 0) {
                    folderKey = pathParts[0] || folderName;
                }

                if (!resultMap[folderKey]) {
                    resultMap[folderKey] = [];
                }

                resultMap[folderKey].push({
                    itemId: c.id,
                    name: c.name,
                    downloadUrl: c["@microsoft.graph.downloadUrl"] || null,
                    lastModified: c.lastModifiedDateTime || ""
                });
            }
        }
    }

    // B·∫Øt ƒë·∫ßu duy·ªát t·ª´ th∆∞ m·ª•c share g·ªëc, pathParts = []
    await traverse(itemId, []);

    return resultMap;
}

// ƒê·ªçc danh s√°ch file KPI t·ª´ OneDrive v√† build map folder -> file
// ƒê·ªçc danh s√°ch file KPI t·ª´ OneDrive (th∆∞ m·ª•c ri√™ng + file share) v√† build map folder -> file
// ƒê·ªçc danh s√°ch file KPI t·ª´ OneDrive v√† build map folder -> file
// ƒê·ªçc danh s√°ch file KPI t·ª´ OneDrive (h·ªó tr·ª£ c·∫£ folder th∆∞·ªùng v√† shortcut / remoteItem)
async function odLoadKpiGroupsFromOneDrive() {
    const loading      = document.getElementById("loading");
    const folderSelect = document.getElementById("odFolderSelect");
    const groupSelect  = document.getElementById("odGroupSelect");

    if (loading) {
        loading.textContent = "‚è≥ ƒêang t·∫£i danh s√°ch file t·ª´ OneDrive...";
        loading.classList.add("show");
    }

    try {
        const rawPath = graphKpiConfig.kpiFolderPath || "/";
        let endpoint;

        if (!rawPath || rawPath === "/") {
            endpoint = "/me/drive/root/children";
        } else {
            const encodedPath = rawPath
                .split("/")
                .filter(Boolean)
                .map(encodeURIComponent)
                .join("/");
            endpoint = `/me/drive/root:/${encodedPath}:/children`;
        }

        const data  = await graphGetJson(endpoint);
        const items = (data && data.value) || [];

        oneDriveFolderFileMap   = {};
        oneDriveGroupMap        = {};
        oneDriveCurrentFolderName = "";

        const isExcel = (name) => /\.(xlsx|xls)$/i.test(name || "");

        const rootFiles  = [];
        const subFolders = [];
        // Ph√¢n lo·∫°i: file Excel ·ªü ROOT + c√°c folder con (ch·ªâ gi·ªØ folder b·∫Øt ƒë·∫ßu b·∫±ng "NA")
        items.forEach((it) => {
            if (it.folder) {
                // T√™n th∆∞ m·ª•c
                const folderName = it.name || "(no-name)";

                // ‚ùó CH·ªà gi·ªØ c√°c folder c√≥ t√™n b·∫Øt ƒë·∫ßu b·∫±ng "NA" (NA08, NA09, ...)
                if (/^NA\d+/i.test(folderName.trim())) {
                    subFolders.push({
                        id: it.id,
                        name: folderName
                    });
                }
                // c√°c folder kh√°c (Parameter..., Report, Test...) s·∫Ω b·ªã b·ªè qua
            } else if (isExcel(it.name)) {
                // File Excel n·∫±m ngay trong root th∆∞ m·ª•c KPI
                rootFiles.push({
                    itemId: it.id,
                    name: it.name,
                    downloadUrl: it["@microsoft.graph.downloadUrl"],
                    lastModified: it.lastModifiedDateTime || ""
                });
            }
        });

        if (rootFiles.length) {
            oneDriveFolderFileMap["(ROOT)"] = rootFiles;
        }

        for (const f of subFolders) {
            const childData = await graphGetJson(
                `/me/drive/items/${encodeURIComponent(f.id)}/children`
            );
            const childItems = (childData && childData.value) || [];

            const excelInFolder = childItems
                .filter((it) => !it.folder && isExcel(it.name))
                .map((it) => ({
                    itemId: it.id,
                    name: it.name,
                    downloadUrl: it["@microsoft.graph.downloadUrl"],
                    lastModified: it.lastModifiedDateTime || ""
                }));

            if (excelInFolder.length) {
                oneDriveFolderFileMap[f.name] = excelInFolder;
            }
        }

        // üîπüîπ TH√äM ƒêO·∫†N N√ÄY: ƒë·ªçc th√™m th∆∞ m·ª•c share b·∫±ng remoteItem
        try {
            const sharedMap = await odLoadKpiSharedFolderViaRemoteItem();
            Object.keys(sharedMap || {}).forEach((folderName) => {
                const list = sharedMap[folderName];
                if (!list || !list.length) return;

                if (!oneDriveFolderFileMap[folderName]) {
                    oneDriveFolderFileMap[folderName] = [];
                }
                oneDriveFolderFileMap[folderName] =
                    oneDriveFolderFileMap[folderName].concat(list);
            });
        } catch (e) {
            console.warn("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c th∆∞ m·ª•c share qua remoteItem:", e);
        }
        // üîπüîπ H·∫æT ƒêO·∫†N TH√äM

        const allFolders = Object.keys(oneDriveFolderFileMap);

        if (!allFolders.length) {
            if (groupSelect) groupSelect.innerHTML = "";
            alert("Kh√¥ng t√¨m th·∫•y file Excel n√†o trong th∆∞ m·ª•c KPI (k·ªÉ c·∫£ th∆∞ m·ª•c share).");
            return;
        }

        odPopulateFolderSelectOptions();
    } catch (err) {
        console.error("L·ªói t·∫£i danh s√°ch file KPI t·ª´ OneDrive:", err);
        alert("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c danh s√°ch file t·ª´ OneDrive.\n" + err.message);
    } finally {
        if (loading) {
            loading.textContent = "‚è≥ ƒêang x·ª≠ l√Ω file...";
            loading.classList.remove("show");
        }
    }
}


// T·∫£i c√°c file trong nh√≥m ƒë√£ ch·ªçn t·ª´ OneDrive ‚Üí chuy·ªÉn th√†nh File[] ‚Üí processMultipleFiles
async function odLoadSelectedGroupFromOneDrive() {
    const groupSelect = document.getElementById("odGroupSelect");
    if (!groupSelect) {
        alert("Kh√¥ng t√¨m th·∫•y combobox Nh√≥m file OneDrive.");
        return;
    }

    const gName = groupSelect.value;
    const list = oneDriveGroupMap[gName] || [];
    if (!list.length) {
        alert("Nh√≥m file OneDrive ƒëang ch·ªçn kh√¥ng c√≥ file.");
        return;
    }

    const loading = document.getElementById("loading");
    if (loading) {
        loading.textContent = "‚è≥ ƒêang t·∫£i file nh√≥m '" + gName + "' t·ª´ OneDrive...";
        loading.classList.add("show");
    }

    try {
        // C√≥ th·ªÉ sort theo lastModified (m·ªõi nh·∫•t tr∆∞·ªõc)
        const sorted = [...list].sort((a, b) =>
            (b.lastModified || "").localeCompare(a.lastModified || "")
        );

        const fileObjs = [];

        for (const item of sorted) {
            let downloadUrl = item.downloadUrl;

            // üîÅ Fallback: n·∫øu ch∆∞a c√≥ downloadUrl (th∆∞·ªùng g·∫∑p v·ªõi SharedWithMe)
            if (!downloadUrl && item.itemId) {
                try {
                    const detail = await graphGetJson(
                        `/me/drive/items/${encodeURIComponent(item.itemId)}`
                    );
                    downloadUrl = detail["@microsoft.graph.downloadUrl"];
                } catch (e) {
                    console.warn("Kh√¥ng l·∫•y ƒë∆∞·ª£c downloadUrl cho", item.name, e);
                }
            }

            if (!downloadUrl) {
                console.warn("B·ªè qua file v√¨ kh√¥ng c√≥ downloadUrl:", item.name);
                continue;
            }

            const res = await fetch(downloadUrl);
            if (!res.ok) {
                console.warn("Kh√¥ng t·∫£i ƒë∆∞·ª£c file:", item.name, res.status);
                continue;
            }

            const blob = await res.blob();
            const file = new File([blob], item.name, {
                type:
                    blob.type ||
                    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            });
            fileObjs.push(file);
        }

        if (!fileObjs.length) {
            alert("Kh√¥ng t·∫£i ƒë∆∞·ª£c file n√†o trong nh√≥m n√†y.");
            return;
        }

        // D√πng l·∫°i logic g·ªôp nhi·ªÅu file ƒëang c√≥
        processMultipleFiles(fileObjs);
    } catch (err) {
        console.error("L·ªói t·∫£i file t·ª´ OneDrive:", err);
        alert("L·ªói khi t·∫£i file nh√≥m t·ª´ OneDrive.\n" + err.message);
    } finally {
        if (loading) {
            loading.textContent = "‚è≥ ƒêang x·ª≠ l√Ω file...";
            loading.classList.remove("show");
        }
    }
}

// G·∫Øn event cho combobox local + kh·ªüi t·∫°o OneDrive
window.addEventListener("DOMContentLoaded", () => {
    // --- Folder/Group LOCAL (ch·ªçn th∆∞ m·ª•c tr√™n m√°y) ---
    const folderSelect = document.getElementById("folderSelect");
    const loadBtn = document.getElementById("loadGroupBtn");

    if (folderSelect) {
        folderSelect.addEventListener("change", () => {
            buildGroupMapForCurrentFolder(folderSelect.value);
        });
    }

    if (loadBtn) {
        loadBtn.addEventListener("click", () => {
            loadSelectedGroupFiles();
        });
    }

    // --- OneDrive: Folder + Group (gi·ªëng local) ---
    const odFolderSelect = document.getElementById("odFolderSelect");
    if (odFolderSelect) {
        odFolderSelect.addEventListener("change", () => {
            odBuildGroupMapForCurrentFolder(odFolderSelect.value);
        });
    }

    // --- OneDrive (Graph API) ---
    initOneDriveGraphUI();
});



        // ‚úÖ H√†m x·ª≠ l√Ω khi ch·ªçn "üìÇ Ch·ªçn th∆∞ m·ª•c Excel"
        function handleFileFromFolder(e) {
            const files = Array.from(e.target.files || []).filter((f) =>
                /\.(xlsx|xls)$/i.test(f.name)
            );
            if (!files.length) {
                alert("Th∆∞ m·ª•c kh√¥ng c√≥ file Excel (.xlsx, .xls)");
                return;
            }

            // Build map folder -> danh s√°ch file
            folderFileMap = {};
            files.forEach((file) => {
                const folderName = getFolderNameFromFile(file);
                if (!folderFileMap[folderName]) folderFileMap[folderName] = [];
                folderFileMap[folderName].push(file);
            });

            // C·∫≠p nh·∫≠t UI combobox
            populateFolderSelectOptions();

            // M·∫∑c ƒë·ªãnh: c≈©ng c√≥ th·ªÉ auto load nh√≥m ƒë·∫ßu ti√™n lu√¥n n·∫øu anh mu·ªën
            // loadSelectedGroupFiles();
        }


        function handleFile(e) {
            const files = Array.from(e.target.files || []).filter(f =>
                /\.(xlsx|xls)$/i.test(f.name)
            );

            if (!files.length) {
                alert("Kh√¥ng t√¨m th·∫•y file Excel (.xlsx, .xls) trong th∆∞ m·ª•c ƒë√£ ch·ªçn!");
                return;
            }

            if (files.length === 1) {
                processFile(files[0]);
                return;
            }

            processMultipleFiles(files);
        }

// G·ªòP NHI·ªÄU FILE EXCEL
function processMultipleFiles(files) {
    if (!files || !files.length) return;

    // üîÅ Reset state gi·ªëng processFile ƒë·ªÉ kh√¥ng d√≠nh d·ªØ li·ªáu c≈©
    mergedDataPerSheet = {};
    currentData = null;
    wsFilterValues = null;
    selectedKpiColumns = new Set();
    isHeavyKpiFile = false;   // reset c·ªù file n·∫∑ng khi ch·ªçn b·ªô file m·ªõi
    // Xo√° chart c≈© n·∫øu c√≤n
    Object.values(chartInstances).forEach(ch => ch.destroy());
    chartInstances = {};
    const chartsContainer = document.getElementById("chartsContainer");
    if (chartsContainer) chartsContainer.innerHTML = "";

    const loading = document.getElementById("loading");
    const fileInfo = document.getElementById("fileInfo");

    loading.classList.add("show");
    fileInfo.innerHTML = "";
    fileInfo.classList.remove("show");

    let totalRows = 0;
    let pending = files.length;

    files.forEach((file, index) => {
        const reader = new FileReader();

        reader.onload = function (e) {
            try {
                const data = new Uint8Array(e.target.result);
                const wb = XLSX.read(data, { type: "array", cellStyles: true });

                // File ƒë·∫ßu ti√™n d√πng l√†m "workbook ch√≠nh"
                if (index === 0) {
                    workbook = wb;
                    buildGlobalKpiMetaMap();
                }

                wb.SheetNames.forEach((sheetName) => {
                    const lower = sheetName.toLowerCase();
                    if (lower.includes("report execution for")) return;
                    if (lower.includes("documentation for")) return;

                    const sheet = wb.Sheets[sheetName];
                    if (!sheet) return;

                    const jsonData = XLSX.utils.sheet_to_json(sheet, { defval: null });
                    if (!mergedDataPerSheet[sheetName]) {
                        mergedDataPerSheet[sheetName] = [];
                    }

                    jsonData.forEach((row) => {
                        // n·∫øu c·∫ßn bi·∫øt file g·ªëc th√¨ c√≥ th·ªÉ th√™m row.__file = file.name;
                        mergedDataPerSheet[sheetName].push(row);
                    });

                    totalRows += jsonData.length;
                });

                pending--;
                if (pending === 0) {
                    loading.classList.remove("show");

                    fileInfo.innerHTML = `
                        <strong>‚úÖ ƒê√£ t·∫£i ${files.length} file.</strong><br>
                        <strong>S·ªë sheets (theo file ƒë·∫ßu ti√™n):</strong> ${workbook.SheetNames.length}<br>
                        <strong>T·ªïng s·ªë d√≤ng (t·∫•t c·∫£ file):</strong> ${totalRows}
                    `;
                    fileInfo.classList.add("show");

                    // Sau khi g·ªôp xong ‚Üí build l·∫°i dropdown sheet + chart + worst cell
                    populateSheetSelect();
                    updateCharts();
                    renderWorstCellTable();

                    const chartsSection = document.getElementById("chartsSection");
                    if (chartsSection) chartsSection.classList.add("show");
                }
            } catch (error) {
                console.error("L·ªói ƒë·ªçc file Excel:", error);
                pending--;
                if (pending === 0) {
                    loading.classList.remove("show");
                    fileInfo.innerHTML =
                        `<span style="color:red;">‚ùå L·ªói khi ƒë·ªçc m·ªôt ho·∫∑c nhi·ªÅu file Excel.</span>`;
                    fileInfo.classList.add("show");
                }
            }
        };

        reader.readAsArrayBuffer(file);
    });
}

        function processFile(file) {
            mergedDataPerSheet = null;      // r·∫•t quan tr·ªçng: b·ªè d·ªØ li·ªáu g·ªôp c≈©
            currentData = null;
            wsFilterValues = null;
            selectedKpiColumns = new Set();
            isHeavyKpiFile = false;        // reset c·ªù file n·∫∑ng khi ch·ªçn file l·∫ª

            // xo√° chart c≈© n·∫øu c√≤n
            Object.values(chartInstances).forEach(ch => ch.destroy());
            chartInstances = {};
            const chartsContainer = document.getElementById("chartsContainer");
            if (chartsContainer) chartsContainer.innerHTML = "";

            const loading = document.getElementById("loading");
            const fileInfo = document.getElementById("fileInfo");

            loading.classList.add("show");
            fileInfo.innerHTML = "";
            fileInfo.classList.remove("show");

            const reader = new FileReader();

            reader.onload = function (e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    workbook = XLSX.read(data, { type: "array", cellStyles: true });

                    buildGlobalKpiMetaMap();

                    loading.classList.remove("show");
                    fileInfo.innerHTML = `
                        <strong>‚úÖ File ƒë√£ ƒë∆∞·ª£c t·∫£i:</strong> ${file.name}<br>
                        <strong>S·ªë sheets:</strong> ${
                            workbook.SheetNames.length
                        }<br>
                        <strong>K√≠ch th∆∞·ªõc:</strong> ${(
                            file.size / 1024
                        ).toFixed(2)} KB
                    `;
                    fileInfo.classList.add("show");

                    populateSheetSelect();
                    updateCharts();
                    renderWorstCellTable();

                    document
                        .getElementById("chartsSection")
                        .classList.add("show");
                } catch (error) {
                    loading.classList.remove("show");
                    alert("‚ùå L·ªói khi ƒë·ªçc file: " + error.message);
                }
                renderWorstCellTable();
            };

            reader.readAsArrayBuffer(file);
        }

        function populateSheetSelect() {
            const select = document.getElementById("sheetSelect");
            select.innerHTML = "";

            const filtered = workbook.SheetNames.filter((name) => {
                const lower = name.toLowerCase();
                if (lower.includes("report execution for")) return false;
                if (lower.includes("documentation for")) return false;
                return true;
            });

            const sheetList = filtered.length > 0 ? filtered : workbook.SheetNames;

            sheetList.forEach((name) => {
                const option = document.createElement("option");
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            });
        }

        function buildGlobalKpiMetaMap() {
            kpiMetaMap = {};
            kpiMetaList = [];

            if (!workbook) return;

            workbook.SheetNames.forEach((sheetName) => {
                if (!sheetName.toLowerCase().includes("documentation for")) return;

                const sheet = workbook.Sheets[sheetName];
                if (!sheet) return;

                const rows = XLSX.utils.sheet_to_json(sheet, {
                    header: 1,
                    defval: "",
                });
                if (!rows.length) return;

                let headerRowIndex = -1;
                for (let i = 0; i < rows.length; i++) {
                    const r0 = String(rows[i][0] || "").toLowerCase();
                    const r1 = String(rows[i][1] || "").toLowerCase();
                    if (r0.includes("kpi id") && r1.includes("kpi alias")) {
                        headerRowIndex = i;
                        break;
                    }
                }
                if (headerRowIndex === -1) return;

                for (let i = headerRowIndex + 1; i < rows.length; i++) {
                    const row = rows[i];
                    const id = String(row[0] || "").trim();
                    const alias = String(row[1] || "").trim();
                    const unit = String(row[4] || "").trim();
                    const category = "";

                    if (!id && !alias) continue;

                    const meta = { id, name: alias || id, unit, category };
                    kpiMetaList.push(meta);
                    if (alias) kpiMetaMap[alias] = meta;
                    if (id) kpiMetaMap[id] = meta;
                }
            });

            console.log("Loaded KPI meta count =", kpiMetaList.length);
        }

        function getKpiScaleForColumn(kpiCol) {
            const meta = findKpiMetaForColumn(kpiCol);
            if (!meta || !meta.unit) return 1;

            const unitNorm = String(meta.unit).trim().toLowerCase();
            if (unitNorm === "[mb]") {
                return 1 / 1024;
            }
            return 1;
        }

        function getKpiTitleWithUnit(kpiCol) {
            const meta = findKpiMetaForColumn(kpiCol) || {};
            const unitLabel = getDisplayUnit(meta);
            if (unitLabel) {
                return `${kpiCol} (${unitLabel})`;
            }
            return kpiCol;
        }

        function getDisplayUnit(meta) {
            if (!meta || !meta.unit) return '';
            const unitNorm = String(meta.unit).trim().toLowerCase();
            return unitNorm === "[mb]" ? "[GB]" : meta.unit;
        }

        function findKpiMetaForColumn(kpiCol) {
            if (!kpiCol) return null;
            const key = String(kpiCol).trim();

            if (kpiMetaMap[key]) return kpiMetaMap[key];

            if (!kpiMetaList || !kpiMetaList.length) return null;

            const lower = key.toLowerCase();
            let best = null;

            kpiMetaList.forEach((meta) => {
                ["name", "id"].forEach((field) => {
                    const v = meta[field];
                    if (!v) return;
                    const vLower = String(v).toLowerCase();

                    if (
                        vLower === lower ||
                        vLower.includes(lower) ||
                        lower.includes(vLower)
                    ) {
                        if (!best) best = meta;
                    }
                });
            });

            return best;
        }
// ====== ƒê·ªåC FILE "KPI Threshhold.xlsx" ======
async function ensureKpiThresholdsLoaded() {
    // ƒê√£ load r·ªìi th√¨ th√¥i
    if (kpiThresholdMap !== null) return kpiThresholdMap;

    kpiThresholdMap = {}; // tr√°nh null ƒë·ªÉ kh√¥ng g·ªçi l·∫°i nhi·ªÅu l·∫ßn

    try {
        // File KPI Threshhold.xlsx ƒë·ªÉ c√πng th∆∞ m·ª•c v·ªõi index.html
        const resp = await fetch("KPI Threshhold.xlsx");
        if (!resp.ok) throw new Error("HTTP " + resp.status);

        const buf = await resp.arrayBuffer();
        const wb = XLSX.read(buf, { type: "array" });

        // T√™n sheet ƒë√∫ng trong file b·∫°n g·ª≠i l√† "KPI Threshold"
        const sheet =
            wb.Sheets["KPI Threshold"] || wb.Sheets[wb.SheetNames[0]];
        if (!sheet) return kpiThresholdMap;

        const rows = XLSX.utils.sheet_to_json(sheet, { defval: "" });

        rows.forEach((r) => {
            const id = String(r["KPI ID"] || "").trim();
            const name = String(r["KPI Name"] || "").trim();
            const op = String(r["operator"] || "").trim();   // <, >, =
            const thr = parseFloat(r["Threshold"]);

            if (!op || isNaN(thr)) return;

            const entry = { op, value: thr };

            // map theo KPI ID, KPI Name v√† c√≥ th·ªÉ reuse cho nhi·ªÅu ch·ªó
            if (id) kpiThresholdMap[id] = entry;
            if (name) kpiThresholdMap[name] = entry;
        });

        console.log("Loaded KPI threshold count =", Object.keys(kpiThresholdMap).length);
    } catch (e) {
        console.warn("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c KPI Threshhold.xlsx:", e);
        kpiThresholdMap = {}; // ƒë·ªÉ kh·ªèi th·ª≠ l·∫°i nhi·ªÅu l·∫ßn
    }

    return kpiThresholdMap;
}

function getThresholdForKpiColumn(kpiCol) {
    if (!kpiCol) return null;

    const meta = findKpiMetaForColumn(kpiCol) || {};
    const keysToTry = [];

    if (meta.id)   keysToTry.push(String(meta.id).trim());
    if (meta.name) keysToTry.push(String(meta.name).trim());
    keysToTry.push(String(kpiCol).trim());

    // 1. ∆Øu ti√™n custom threshold (k·ªÉ c·∫£ tr∆∞·ªùng h·ª£p T·∫ÆT NG∆Ø·ª†NG)
    for (const key of keysToTry) {
        if (Object.prototype.hasOwnProperty.call(customThresholdMap, key)) {
            const entry = customThresholdMap[key];

            // entry = null ho·∫∑c entry.disabled => t·∫Øt ho√†n to√†n ng∆∞·ª°ng cho KPI n√†y
            if (!entry || entry.disabled) return null;

            return entry; // { op, value }
        }
    }

    // 2. N·∫øu kh√¥ng c√≥ custom ‚Üí d√πng file KPI Threshold (load 1 l·∫ßn)
    if (kpiThresholdMap) {
        for (const key of keysToTry) {
            if (kpiThresholdMap[key]) {
                return kpiThresholdMap[key];
            }
        }
    }

    return null;
}


function setCustomThresholdForKpiColumn(kpiCol, op, value) {
    if (!kpiCol) return;

    const key = String(kpiCol).trim();

    // Tr∆∞·ªùng h·ª£p T·∫ÆT NG∆Ø·ª†NG (op = "")
    if (!op) {
        customThresholdMap[key] = { disabled: true };

        try {
            localStorage.setItem(
                "customThresholdMap",
                JSON.stringify(customThresholdMap)
            );
        } catch (e) {
            console.warn("Cannot save customThresholdMap", e);
        }

        // Kh√¥ng ghi ƒë√® v√†o kpiThresholdMap ƒë·ªÉ gi·ªØ nguy√™n default trong file,
        // nh∆∞ng do getThresholdForKpiColumn ∆∞u ti√™n custom n√™n KPI n√†y s·∫Ω KH√îNG d√πng ng∆∞·ª°ng n·ªØa.
        return;
    }

    // C√°c tr∆∞·ªùng h·ª£p c√≤n l·∫°i: ph·∫£i c√≥ value s·ªë
    if (value == null || isNaN(value)) return;

    const entry = { op, value: Number(value) };

    // L∆∞u v√†o custom map
    customThresholdMap[key] = entry;

    // L∆∞u vƒ©nh vi·ªÖn v√†o localStorage
    try {
        localStorage.setItem(
            "customThresholdMap",
            JSON.stringify(customThresholdMap)
        );
    } catch (e) {
        console.warn("Cannot save customThresholdMap", e);
    }

    // Ghi ƒë√® tr√™n map t·ªïng h·ª£p ƒë·ªÉ b·∫£ng/chart d√πng ngay
    if (!kpiThresholdMap) kpiThresholdMap = {};
    kpiThresholdMap[key] = entry;

    console.log("Saved custom threshold:", kpiCol, entry);
}


// ====== ƒê·ªåC SHEET "WorstCell Threshold" CHO WORST CELL & NON-TRAFFIC ======
async function ensureWorstCellThresholdsLoaded() {
    // ƒê√£ load r·ªìi th√¨ th√¥i
    if (worstCellThresholdMap !== null) return worstCellThresholdMap;

    worstCellThresholdMap = {}; // tr√°nh null ƒë·ªÉ kh√¥ng g·ªçi l·∫°i nhi·ªÅu l·∫ßn

    try {
        const resp = await fetch("KPI Threshhold.xlsx");
        if (!resp.ok) throw new Error("HTTP " + resp.status);

        const buf = await resp.arrayBuffer();
        const wb  = XLSX.read(buf, { type: "array" });

        const sheet = wb.Sheets["WorstCell Threshold"];
        if (!sheet) {
            console.warn('Kh√¥ng t√¨m th·∫•y sheet "WorstCell Threshold" trong KPI Threshhold.xlsx');
            return worstCellThresholdMap;
        }

        const rows = XLSX.utils.sheet_to_json(sheet, { defval: "" });

        rows.forEach((r) => {
            const name = String(r["KPI Name"] || "").trim();
            const op   = String(r["operator"] || "").trim();   // <, >, <=, >=, =, ...
            const thr  = parseFloat(r["Threshold"]);

            if (!name || !op || isNaN(thr)) return;

            worstCellThresholdMap[name] = { op, value: thr };
        });

        console.log(
            "Loaded WorstCell threshold count =",
            Object.keys(worstCellThresholdMap).length
        );
    } catch (e) {
        console.warn("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c sheet WorstCell Threshold:", e);
        worstCellThresholdMap = {}; // ƒë·ªÉ kh·ªèi th·ª≠ l·∫°i nhi·ªÅu l·∫ßn
    }

    return worstCellThresholdMap;
}

// L·∫•y threshold cho 1 KPI theo t√™n hi·ªÉn th·ªã c·ªôt (KPI Name)
function getWorstCellThresholdByName(kpiDisplayName) {
    if (!worstCellThresholdMap || !Object.keys(worstCellThresholdMap).length) return null;
    if (!kpiDisplayName) return null;

    const key = String(kpiDisplayName).trim();
    return worstCellThresholdMap[key] || null;
}

        // üëâ KPI MAC SDU: d√πng ƒë·ªÉ set default chart = stackedArea
        function isMacSduKpi(kpiCol) {
            if (!kpiCol) return false;
            const lower = String(kpiCol).toLowerCase();
            return (
                lower.includes("mac sdu data vol trans dl dtch") ||
                lower.includes("mac sdu data vol rcvd ul dtch") ||
                lower.includes("pdcp sdu volume, dl") ||
                lower.includes("pdcp sdu volume, ul")
            );
        }

        function populateSheetSelectDirect() {
            const sheetSelect = document.getElementById("sheetSelect");

            sheetSelect.innerHTML = `
                <option value="merged" selected>üìÇ Merged Dataset (${originalRows.length} d√≤ng)</option>
            `;
        }

        function processMergedExcelData(rows) {
            originalRows = rows;
            currentData = [...rows];

            populateSheetSelectDirect();
            populateKpiSelect(currentData);
            populateDateSelect(currentData);

            updateCharts();
        }

function updateCharts() {
    if (!workbook) return;

    const sheetSelect = document.getElementById("sheetSelect");

    // √Åp sheet ƒë√£ l∆∞u trong localStorage l·∫ßn ƒë·∫ßu sau khi c√≥ danh s√°ch sheet
    if (!chartConfigAppliedOnce && sheetSelect) {
        try {
            const raw = localStorage.getItem("chartConfig");
            if (raw) {
                const cfg = JSON.parse(raw);
                if (cfg.sheet) {
                    const hasOption = Array.from(sheetSelect.options).some(
                        (opt) => opt.value === cfg.sheet
                    );
                    if (hasOption) {
                        sheetSelect.value = cfg.sheet;
                    }
                }
            }
        } catch (e) {
            console.warn("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c chartConfig:", e);
        }
        chartConfigAppliedOnce = true;
    }

    const sheetName =
        (sheetSelect && sheetSelect.value) || workbook.SheetNames[0];

    let jsonData;

    if (mergedDataPerSheet && mergedDataPerSheet[sheetName]) {
        jsonData = mergedDataPerSheet[sheetName];
    } else {
        const sheet = workbook.Sheets[sheetName];
        jsonData = XLSX.utils.sheet_to_json(sheet);
    }

    if (!jsonData || jsonData.length === 0) {
        alert("Sheet kh√¥ng c√≥ d·ªØ li·ªáu!");
        return;
    }

    currentData = jsonData;
    const columns = Object.keys(jsonData[0]);
    numericColumns = detectColumnsAndNumeric(columns);

    // ==== ƒê√ÅNH D·∫§U SHEET KPI N·∫∂NG ====
    // ƒêi·ªÅu ki·ªán file n·∫∑ng:
    // 1) S·ªë d√≤ng > ng∆∞·ª°ng
    // 2) S·ªë c·ªôt > 30
    const colCount = columns.length;

    isHeavyKpiFile =
        (Array.isArray(jsonData) && jsonData.length > HEAVY_KPI_ROW_THRESHOLD) ||
        colCount > 30;

    console.log(
        "S·ªë d√≤ng:", jsonData.length,
        "S·ªë c·ªôt:", colCount,
        "isHeavyKpiFile =", isHeavyKpiFile
    );


    // m·ªói l·∫ßn ƒë·ªïi sheet th√¨ reset l·∫°i KPI & filter
    //  - n·∫øu file n·∫∑ng -> T·∫ÆT H·∫æT KPI (set r·ªóng)
    //  - n·∫øu file b√¨nh th∆∞·ªùng -> b·∫≠t h·∫øt KPI nh∆∞ c≈©
    selectedKpiColumns = isHeavyKpiFile
        ? new Set()
        : new Set(numericColumns);

    wsFilterValues = null;


    buildWsFilterOptions(jsonData);
    buildKpiFilterOptions();
    buildExcelDateOptions();
    buildThresholdCustomUi();
    renderCharts();
    fillDefaultEmailText();

    // l∆∞u l·∫°i c·∫•u h√¨nh (sheet, daysWindow, chartsPerRow, funnelSort)
    if (typeof saveChartConfig === "function") {
        saveChartConfig();
    }
}


        // ==== ƒêO·∫†N QUAN TR·ªåNG: ∆ØU TI√äN LNCEL name / NRCEL name L√ÄM CELL_NAME ====
        // Ch·ªçn c·ªôt CELL_NAME d√πng chung: ∆∞u ti√™n LNCEL name -> NRCEL name -> WS_NAME
// ==== CH·ªåN CH√çNH X√ÅC CELL_NAME (∆∞u ti√™n LNCEL/NRCEL) ====
// ==== CH·ªåN CH√çNH X√ÅC CELL_NAME (∆∞u ti√™n NRCEL / LNCEL) ====
function getCellNameColumn() {
    if (!currentData || !currentData.length) return wsNameColumnName;

    const columns = Object.keys(currentData[0]);
    const meta = columns.map(c => ({
        name: c,
        lower: String(c).toLowerCase().trim()
    }));

    const candidates = [];

    function pushIf(testFn, weight) {
        meta.forEach(col => {
            if (testFn(col.lower)) {
                candidates.push({ name: col.name, weight });
            }
        });
    }

    // 1. ∆ØU TI√äN CAO NH·∫§T: NRCEL name (ƒë√∫ng case c·ªßa b·∫°n)
    pushIf(l => l === "nrcel name" || l === "nrcell name", 110);
    pushIf(l =>
        (l.includes("nrcel") || l.includes("nrcell")) &&
        l.includes("name"),
        100
    );

    // 2. LNCEL name
    pushIf(l => l === "lncel name", 95);
    pushIf(l => l.includes("lncel") && l.includes("name"), 90);

    // 3. CELL_NAME chung chung
    pushIf(l =>
        l === "cell name" ||
        l === "cell_name" ||
        l === "cellname",
        80
    );
    pushIf(l => l.includes("cell") && l.includes("name"), 75);

    // 4. WS_NAME / site name fallback
    pushIf(l =>
        l === "ws_name" ||
        l === "wsname" ||
        l === "ws name",
        60
    );
    pushIf(l => l.includes("ws") && l.includes("name"), 55);

    // 5. NRBTS / MRBTS ch·ªâ l√† fallback th·∫•p (trong file b·∫°n c√≥ 2 c·ªôt n√†y)
    pushIf(l => l.includes("nrbts") && l.includes("name"), 40);
    pushIf(l => l.includes("mrbts") && l.includes("name"), 35);

    // N·∫øu t√¨m ƒë∆∞·ª£c ·ª©ng vi√™n th√¨ l·∫•y c√°i c√≥ weight cao nh·∫•t
    if (candidates.length) {
        candidates.sort((a, b) => b.weight - a.weight);
        return candidates[0].name;
    }

    // 6. Fallback th√¥ng minh: ch·ªçn c·ªôt text (√≠t numeric) ƒë·∫ßu ti√™n, KH√îNG ph·∫£i Period/Time/Date
    const periodSet = new Set();
    meta.forEach(col => {
        if (
            col.lower.includes("period") ||
            col.lower.includes("time") ||
            col.lower.includes("date")
        ) {
            periodSet.add(col.name);
        }
    });

    for (const colName of columns) {
        if (periodSet.has(colName)) continue;

        let numericCount = 0;
        let total = 0;

        currentData.forEach(row => {
            const v = row[colName];
            if (v === null || v === undefined || v === "") return;
            total++;
            if (!isNaN(parseFloat(v))) numericCount++;
        });

        // Ch·ªß y·∫øu l√† text ‚Üí r·∫•t c√≥ th·ªÉ l√† CELL_NAME
        if (total > 0 && numericCount / total < 0.3) {
            return colName;
        }
    }

    // 7. Fallback cu·ªëi c√πng
    return wsNameColumnName || columns[1] || columns[0];
}

function detectColumnsAndNumeric(columns) {
    // 1. X√°c ƒë·ªãnh c·ªôt Period (th·ªùi gian)
    periodColumnName = null;

    columns.forEach((col) => {
        const lower = String(col).toLowerCase();
        if (
            !periodColumnName &&
            (lower.includes("period") ||
                lower.includes("time") ||
                lower.includes("date"))
        ) {
            periodColumnName = col;
        }
    });

    // Fallback n·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c
    if (!periodColumnName) {
        periodColumnName = columns[0];
    }

    // 2. X√°c ƒë·ªãnh CELL_NAME chung (∆∞u ti√™n NRCEL/LNCEL)
    wsNameColumnName = getCellNameColumn();

    // 3. C√°c c·ªôt ki·ªÉu "name" (MRBTS name, NRBTS name, NRCEL name, ‚Ä¶)
    //    => coi l√† c·ªôt dimension, KH√îNG ph·∫£i KPI
    const nameLikeCols = new Set();
    columns.forEach(col => {
        const lower = String(col).toLowerCase();
        if (lower.includes("name")) {
            nameLikeCols.add(col);
        }
    });

    // 4. H√†m check s·ªë "th·∫≠t": b·ªè %, d·∫•u ph·∫©y, kho·∫£ng tr·∫Øng,
    //    v√† y√™u c·∫ßu c·∫£ chu·ªói ch·ªâ l√† s·ªë (kh√¥ng cho ki·ªÉu "5G-..." n·ªØa)
    function isTrulyNumeric(val) {
        if (val === null || val === undefined) return false;
        let s = String(val).trim();
        if (!s) return false;

        // lo·∫°i b·ªè kho·∫£ng tr·∫Øng, d·∫•u ph·∫©y
        s = s.replace(/,/g, "").replace(/\s+/g, "");
        // b·ªè d·∫•u % cu·ªëi n·∫øu c√≥
        s = s.replace(/%$/, "");

        // n·∫øu sau khi x·ª≠ l√Ω m√† v·∫´n c√≥ ch·ªØ => kh√¥ng ph·∫£i s·ªë
        if (!/^[-+]?\d*\.?\d+(e[+-]?\d+)?$/i.test(s)) return false;

        return !isNaN(Number(s));
    }

    // 5. Detect c√°c c·ªôt KPI s·ªë: b·ªè Period, CELL_NAME v√† m·ªçi c·ªôt "*name"
    const numericCols = [];
    columns.forEach((col) => {
        if (col === periodColumnName) return;
        if (col === wsNameColumnName) return;
        if (nameLikeCols.has(col)) return; // MRBTS name, NRBTS name, NRCEL name,...

        const isNumeric = currentData.some((row) => {
            const v = row[col];
            if (v === null || v === undefined || v === "") return false;
            return isTrulyNumeric(v);
        });

        if (isNumeric) numericCols.push(col);
    });

    return numericCols;
}

        // ==== H·∫æT PH·∫¶N S·ª¨A CELL_NAME ====

        function buildKpiFilterOptions() {
            const container = document.getElementById('kpiFilterContainer');
            if (!container) return;
            if (!numericColumns || !numericColumns.length) {
                container.innerHTML = '<div style="font-size:0.85em;color:#6b7280;">Kh√¥ng t√¨m th·∫•y KPI d·∫°ng s·ªë.</div>';
                return;
            }

            const prevInput = container.querySelector('#kpiSearchInput');
            const prevKeyword = prevInput ? prevInput.value : '';

            if (!(selectedKpiColumns instanceof Set)) {
                selectedKpiColumns = new Set(numericColumns);
            }

            container.innerHTML = `
                <div class="ws-filter-toolbar">
                    <input type="text" id="kpiSearchInput" class="ws-filter-search"
                        placeholder="T√¨m KPI (vd: THR;Drop)">
                    <button type="button" data-action="kpi-select-all">Ch·ªçn t·∫•t c·∫£</button>
                    <button type="button" data-action="kpi-clear-all">B·ªè h·∫øt</button>
                </div>
                <div class="kpi-filter-list"></div>
            `;

            const listEl = container.querySelector('.kpi-filter-list');
            const searchInput = container.querySelector('#kpiSearchInput');
            if (searchInput) searchInput.value = prevKeyword || '';

            function renderList() {
                listEl.innerHTML = '';
                const searchVal = (searchInput?.value || '').trim().toLowerCase();
                const terms = searchVal
                    ? searchVal.split(';').map(t => t.trim()).filter(Boolean)
                    : [];

                numericColumns.forEach(col => {
                    const colLower = String(col).toLowerCase();
                    if (terms.length && !terms.some(term => colLower.includes(term))) {
                        return;
                    }
                    const checked = selectedKpiColumns.has(col) ? 'checked' : '';
                    listEl.innerHTML += `
                        <label class="ws-chip">
                            <input type="checkbox" class="kpi-filter-checkbox" value="${col}" ${checked}>
                            ${col}
                        </label>
                    `;
                });
            }

            renderList();

            container.onchange = (e) => {
                if (!e.target.classList.contains('kpi-filter-checkbox')) return;
                const value = e.target.value;
                if (e.target.checked) {
                    selectedKpiColumns.add(value);
                } else {
                    selectedKpiColumns.delete(value);
                }

                renderCharts();
                renderExcelStyleTable();
                renderLatestKpiTable();
                renderWorstCellTable();   // üîÅ c·∫≠p nh·∫≠t lu√¥n Worst Cell / Non-Traffic
                buildThresholdCustomUi(); // ‚¨ÖÔ∏è update l·∫°i list KPI cho ph·∫ßn T√πy ch·ªânh ng∆∞·ª°ng
            };

            container.onclick = (e) => {
                const btn = e.target.closest('button[data-action]');
                if (!btn) return;

                const action = btn.dataset.action;
                const checkboxes = listEl.querySelectorAll('.kpi-filter-checkbox');

                if (action === 'kpi-select-all') {
                    checkboxes.forEach(cb => selectedKpiColumns.add(cb.value));
                } else if (action === 'kpi-clear-all') {
                    checkboxes.forEach(cb => selectedKpiColumns.delete(cb.value));
                }

                renderList();
                renderCharts();
                renderExcelStyleTable();
                renderLatestKpiTable();
                renderWorstCellTable();   // üîÅ c·∫≠p nh·∫≠t lu√¥n Worst Cell / Non-Traffic
                buildThresholdCustomUi(); // ‚¨ÖÔ∏è ƒë·ªìng b·ªô ph·∫ßn T√πy ch·ªânh ng∆∞·ª°ng
            };

            if (searchInput) {
                searchInput.addEventListener('input', () => {
                    renderList();
                });
            }
        }
// X√¢y UI "T√πy ch·ªânh ng∆∞·ª°ng" cho c√°c KPI ƒëang ƒë∆∞·ª£c ch·ªçn
function buildThresholdCustomUi() {
    const panel      = document.getElementById("kpiThresholdPanel");
    const kpiSelect  = document.getElementById("thresholdKpiSelect");
    const opSelect   = document.getElementById("thresholdOpSelect");
    const valueInput = document.getElementById("thresholdValueInput");
    const applyBtn   = document.getElementById("thresholdApplyBtn");
    const globalToggle = document.getElementById("thresholdGlobalToggle");

    if (!panel || !kpiSelect || !opSelect || !valueInput || !applyBtn) return;

    if (!numericColumns || !numericColumns.length || !currentData) {
        panel.style.display = "none";
        return;
    }

    // Ch·ªâ show KPI ƒëang ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ v·∫Ω / b·∫£ng (selectedKpiColumns)
    const activeKpiCols = numericColumns.filter(col => selectedKpiColumns.has(col));

    if (!activeKpiCols.length) {
        panel.style.display = "none";
        return;
    }

    panel.style.display = "block";

    // Kh·ªüi t·∫°o tr·∫°ng th√°i checkbox t·ªïng + ƒë·ªìng b·ªô state Target l·∫ßn ƒë·∫ßu
    if (globalToggle) {
        try {
            const saved = localStorage.getItem("globalThresholdEnabled");
            if (saved !== null) {
                globalThresholdEnabled = saved === "1";
            }
        } catch (e) {
            console.warn("Cannot load globalThresholdEnabled", e);
        }
        globalToggle.checked = globalThresholdEnabled;
    }

    // ƒê·ªìng b·ªô tr·∫°ng th√°i checkbox Target tr√™n t·ª´ng chart theo globalThresholdEnabled
    // (√°p d·ª•ng khi m·ªü file, d·ª±a tr√™n c√°c KPI ƒëang active)
    chartTargetVisible = {};
    if (globalThresholdEnabled) {
        activeKpiCols.forEach((col) => {
            chartTargetVisible[col] = true;
        });
    }


    // ƒê·ªï danh s√°ch KPI
    kpiSelect.innerHTML = "";
    activeKpiCols.forEach((col) => {
        const meta      = findKpiMetaForColumn(col) || {};
        const unitLabel = getDisplayUnit(meta);
        const kpiName   = meta.name || col;

        let text = kpiName;
        if (unitLabel) {
            // v√≠ d·ª•: "NSA call access ([%])"
            text += ` (${unitLabel})`;
        }

        const opt = document.createElement("option");
        opt.value = col;
        opt.textContent = text;
        kpiSelect.appendChild(opt);
    });



    // ƒê·ªìng b·ªô √¥ Operator & Threshold theo map hi·ªán t·∫°i (default t·ª´ file + custom + t·∫Øt ng∆∞·ª°ng)
    async function syncInputsFromThreshold() {
        const col = kpiSelect.value;
        if (!col) return;

        // N·∫øu ƒë√£ c√≥ override trong customThresholdMap (k·ªÉ c·∫£ disabled)
        if (Object.prototype.hasOwnProperty.call(customThresholdMap, col)) {
            const entry = customThresholdMap[col];

            // entry null/disabled => coi nh∆∞ ƒëang ch·ªçn "--" v√† Threshold r·ªóng
            if (!entry || entry.disabled) {
                opSelect.value = "";
                valueInput.value = "";
            } else {
                opSelect.value = entry.op || "";
                valueInput.value = entry.value ?? "";
            }
            return;
        }

        // Ch∆∞a c√≥ t√πy ch·ªânh ‚Üí d√πng default trong file KPI Threshhold (ch·ªâ load 1 l·∫ßn)
        if (kpiThresholdMap === null) {
            await ensureKpiThresholdsLoaded();
        }

        const thr = getThresholdForKpiColumn(col);
        opSelect.value = thr?.op || "";
        valueInput.value = thr?.value ?? "";
    }



    kpiSelect.onchange = () => {
        syncInputsFromThreshold();
    };
    // Khi ƒë·ªïi Operator sang "--" (value = ""), t·ª± xo√° √¥ Threshold
    opSelect.onchange = () => {
        if (!opSelect.value) {
            // value r·ªóng = ƒëang ch·ªçn option "--"
            valueInput.value = "";
        }
    };
    applyBtn.onclick = async () => {
        const col    = kpiSelect.value;
        const op     = (opSelect.value || "").trim();
        const valStr = valueInput.value;

        // N·∫øu ch∆∞a ch·ªçn KPI th√¨ b√°o l·ªói nh·∫π
        if (!col) {
            alert("Vui l√≤ng ch·ªçn KPI.");
            return;
        }


    // N·∫øu ch·ªçn "--" th√¨ T·∫ÆT HO√ÄN TO√ÄN NG∆Ø·ª†NG cho KPI n√†y (kh√¥ng d√πng default trong file n·ªØa)
    if (op === "") {
        // Ghi override "disabled" v√†o customThresholdMap
        customThresholdMap[col] = { disabled: true };
        try {
            localStorage.setItem(
                "customThresholdMap",
                JSON.stringify(customThresholdMap)
            );
        } catch (e) {
            console.warn("Cannot save customThresholdMap", e);
        }

        // C·∫≠p nh·∫≠t l·∫°i b·∫£ng & chart
        renderExcelStyleTable();
        if (typeof renderLatestKpiTable === "function") {
            renderLatestKpiTable();
        }
        renderCharts();
        return;
    }


        // C√°c tr∆∞·ªùng h·ª£p c√≤n l·∫°i ‚Üí y√™u c·∫ßu ph·∫£i c√≥ s·ªë
        if (!valStr) {
            alert("Vui l√≤ng nh·∫≠p Threshold.");
            return;
        }

        const num = parseFloat(valStr);
        if (isNaN(num)) {
            alert("Threshold ph·∫£i l√† s·ªë.");
            return;
        }

        if (kpiThresholdMap === null) {
            await ensureKpiThresholdsLoaded();
        }

        // Ghi ƒë√® ng∆∞·ª°ng trong map (t·∫°o/custom)
        setCustomThresholdForKpiColumn(col, op, num);

        // C·∫≠p nh·∫≠t l·∫°i b·∫£ng theo ng∆∞·ª°ng m·ªõi
        renderExcelStyleTable();
        if (typeof renderLatestKpiTable === "function") {
            renderLatestKpiTable();
        }
        renderCharts();
    };
    // ===== Checkbox t·ªïng: K√≠ch ho·∫°t t√πy ch·ªânh =====
    if (globalToggle) {
        globalToggle.onchange = () => {
            // 1) C·∫≠p nh·∫≠t bi·∫øn tr·∫°ng th√°i
            globalThresholdEnabled = globalToggle.checked;

            // 2) L∆∞u l·∫°i ƒë·ªÉ l·∫ßn sau m·ªü file v·∫´n gi·ªØ tr·∫°ng th√°i
            try {
                localStorage.setItem(
                    "globalThresholdEnabled",
                    globalThresholdEnabled ? "1" : "0"
                );
            } catch (e) {
                console.warn("Cannot save globalThresholdEnabled", e);
            }

            // 3) ƒê·ªìng b·ªô state Target cho T·∫§T C·∫¢ KPI ƒëang active
            //    - n·∫øu b·∫≠t: t·∫•t c·∫£ chart ƒë·ªÅu Target = ON
            //    - n·∫øu t·∫Øt: t·∫•t c·∫£ chart ƒë·ªÅu Target = OFF
            chartTargetVisible = {};
            if (globalThresholdEnabled) {
                activeKpiCols.forEach((col) => {
                    chartTargetVisible[col] = true;
                });
            }

            // 4) V·∫Ω l·∫°i b·∫£ng + chart cho kh·ªõp
            renderExcelStyleTable();
            if (typeof renderLatestKpiTable === "function") {
                renderLatestKpiTable();
            }
            renderCharts();
        };
    }
    // Kh·ªüi t·∫°o l·∫ßn ƒë·∫ßu theo KPI ƒë·∫ßu ti√™n
    syncInputsFromThreshold();
}

        function buildWsFilterOptions(data) {
            const wsNameCol = getCellNameColumn();   // üëâ d√πng CELL_NAME ∆∞u ti√™n LNCEL/NRCEL
            const container = document.getElementById("wsFilterContainer");
            if (!container) return;

            const set = new Set();
            data.forEach((row) => {
                const v = row[wsNameCol];
                if (v !== undefined && v !== null && v !== "") {
                    set.add(String(v));
                }
            });
            currentWsValues = Array.from(set).sort();

            if (!(wsFilterValues instanceof Set)) {
                wsFilterValues = new Set(currentWsValues);
            }

            container.innerHTML = `
                <div class="ws-filter-toolbar">
                    <input type="text" id="wsSearchInput1" class="ws-filter-search"
                        placeholder="Filter 1 (vd: PO1;PO2)">
                    <input type="text" id="wsSearchInput2" class="ws-filter-search"
                        placeholder="Filter 2 (l·ªçc ti·∫øp k·∫øt qu·∫£ 1)">
                    <input type="text" id="wsSearchInput3" class="ws-filter-search"
                        placeholder="Filter 3 (l·ªçc ti·∫øp k·∫øt qu·∫£ 2)">
                    <button type="button" data-action="select-all">Ch·ªçn t·∫•t c·∫£</button>
                    <button type="button" data-action="clear-all">B·ªè h·∫øt</button>
                </div>
                <div class="ws-filter-list"></div>
            `;

            const searchInput1 = container.querySelector("#wsSearchInput1");
            const searchInput2 = container.querySelector("#wsSearchInput2");
            const searchInput3 = container.querySelector("#wsSearchInput3");
            const listEl       = container.querySelector(".ws-filter-list");

            const renderWsList = () => {
                updateWsSearchKeywordsFromInputs();
                listEl.innerHTML = "";

                currentWsValues.forEach((v) => {
                    const wsLower = v.toLowerCase();
                    if (!wsPassesTextFilters(wsLower)) return;

                    const checked = wsFilterValues.has(v) ? "checked" : "";
                    listEl.innerHTML += `
                        <label class="ws-chip">
                            <input type="checkbox" class="ws-filter-checkbox" value="${v}" ${checked}>
                            ${v}
                        </label>
                    `;
                });
            };

            renderWsList();

            container.onchange = (e) => {
                if (!e.target.classList.contains("ws-filter-checkbox")) return;
                const value = e.target.value;

                if (e.target.checked) {
                    wsFilterValues.add(value);
                } else {
                    wsFilterValues.delete(value);
                }

                renderCharts();
                renderExcelStyleTable();
                renderLatestKpiTable();
            };

            container.onclick = (e) => {
                const btn = e.target.closest("button[data-action]");
                if (!btn) return;

                const action = btn.dataset.action;
                const checkboxes = listEl.querySelectorAll(".ws-filter-checkbox");

                if (action === "select-all") {
                    checkboxes.forEach((cb) => wsFilterValues.add(cb.value));
                } else if (action === "clear-all") {
                    checkboxes.forEach((cb) => wsFilterValues.delete(cb.value));
                }

                renderWsList();
                renderCharts();
                renderExcelStyleTable();
                renderLatestKpiTable();
            };

            [searchInput1, searchInput2, searchInput3].forEach((inp) => {
                if (!inp) return;
                inp.addEventListener("input", () => {
                    renderWsList();
                    renderCharts();
                    renderExcelStyleTable();
                    renderLatestKpiTable();
                });
            });
        }

        // ===== X·ª≠ l√Ω Period Time (day / hour) =====

        function parsePeriodDateTime(value) {
            let dateObj = null;
            let hasTime = false;

            if (value instanceof Date) {
                dateObj = value;
            } else if (typeof value === "number") {
                // Excel date code (c√≥ th·ªÉ k√®m gi·ªù)
                try {
                    const d = XLSX.SSF.parse_date_code(value);
                    if (d) {
                        dateObj = new Date(
                            d.y,
                            d.m - 1,
                            d.d,
                            d.H || 0,
                            d.M || 0,
                            d.S || 0
                        );
                        hasTime = !!(d.H || d.M || d.S);
                    }
                } catch (e) {}
            } else if (value != null && value !== "") {
                const parsed = new Date(value);
                if (!isNaN(parsed.getTime())) {
                    dateObj = parsed;
                }
            }

            if (dateObj) {
                if (
                    dateObj.getHours() !== 0 ||
                    dateObj.getMinutes() !== 0 ||
                    dateObj.getSeconds() !== 0
                ) {
                    hasTime = true;
                }
            }

            return { dateObj, hasTime };
        }

        // Chu·∫©n h√≥a Period ƒë·ªÉ d√πng chung trong group/tr·ª•c X
        function normalizePeriod(value) {
            const { dateObj, hasTime } = parsePeriodDateTime(value);

            if (dateObj) {
                const yyyy = dateObj.getFullYear();
                const mm = String(dateObj.getMonth() + 1).padStart(2, "0");
                const dd = String(dateObj.getDate()).padStart(2, "0");

                let label = `${yyyy}-${mm}-${dd}`;
                if (hasTime) {
                    const hh = String(dateObj.getHours()).padStart(2, "0");
                    const mi = String(dateObj.getMinutes()).padStart(2, "0");
                    label = `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
                }

                return {
                    label,
                    sortValue: dateObj.getTime(),
                };
            }

            return {
                label: String(value),
                sortValue: 0,
            };
        }

        // Ph√¢n bi·ªát Period l√† m·ª©c day hay hour
        function isPeriodHourly() {
            if (!currentData || !currentData.length || !periodColumnName) return false;

            const periodCol = periodColumnName;
            for (let i = 0; i < currentData.length; i++) {
                const raw = currentData[i][periodCol];
                if (raw === undefined || raw === null || raw === "") continue;

                const { hasTime } = parsePeriodDateTime(raw);
                if (hasTime) return true;
            }
            return false;
        }

        // Text tr·ª•c X cho chart
        function getXAxisLabel(chartType) {
            if (chartType === "funnel") {
                // Funnel: tr·ª•c X l√† CELL_NAME
                return getCellNameColumn();
            }
            // C√°c chart c√≤n l·∫°i: Period Time / Period Hour
            return isPeriodHourly() ? "Period Hour" : "Period Time";
        }
        // L·∫•y ng√†y (Date) m·ªõi nh·∫•t t·ª´ currentData theo c·ªôt periodColumnName
        function getLatestDateFromCurrentData() {
            if (!currentData || !currentData.length || !periodColumnName) return null;

            const periodCol = periodColumnName;
            let latestTs = -Infinity;

            currentData.forEach((row) => {
                const raw = row[periodCol];
                if (raw === undefined || raw === null) return;

                let dateObj = null;

                if (raw instanceof Date) {
                    dateObj = raw;
                } else if (typeof raw === "number") {
                    try {
                        const d = XLSX.SSF.parse_date_code(raw);
                        if (d) {
                            dateObj = new Date(d.y, d.m - 1, d.d);
                        }
                    } catch (e) {}
                } else {
                    const parsed = new Date(raw);
                    if (!isNaN(parsed.getTime())) {
                        dateObj = parsed;
                    }
                }

                if (dateObj) {
                    const ts = dateObj.getTime();
                    if (ts > latestTs) {
                        latestTs = ts;
                    }
                }
            });

            if (latestTs === -Infinity) return null;
            return new Date(latestTs);
        }

        // ƒê∆∞a Date v·ªÅ d·∫°ng dd/mm/yyyy
        function formatDateDDMMYYYY(date) {
            if (!date) return "__/__/____";
            const dd = String(date.getDate()).padStart(2, "0");
            const mm = String(date.getMonth() + 1).padStart(2, "0");
            const yyyy = date.getFullYear();
            return `${dd}/${mm}/${yyyy}`;
        }

        function getLatestPeriodLabel(data) {
            const periodCol = periodColumnName;
            let latestLabel = null;
            let latestSort = -Infinity;

            data.forEach((row) => {
                const rawPeriod = row[periodCol];
                if (rawPeriod === undefined || rawPeriod === null) return;

                const { label, sortValue } = normalizePeriod(rawPeriod);
                if (sortValue > latestSort) {
                    latestSort = sortValue;
                    latestLabel = label;
                }
                if (latestLabel === null && label != null) {
                    latestLabel = label;
                }
            });

            return latestLabel;
        }

        function buildChartDataForColumn(data, valueCol) {
            const periodCol = periodColumnName;
            const wsNameCol = getCellNameColumn();

            const groupedData = {};
            const periodMap   = new Map();

            data.forEach(row => {
                const wsName    = row[wsNameCol];
                const rawPeriod = row[periodCol];
                const rawVal = row[valueCol];
                const scale  = getKpiScaleForColumn(valueCol);
                const numeric = parseFloat(rawVal);

                if (!wsName || rawPeriod === undefined || isNaN(numeric)) return;

                const value = numeric * scale;

                const wsStr   = String(wsName);
                const wsLower = wsStr.toLowerCase();

                if (!wsPassesTextFilters(wsLower)) return;
                if (wsFilterValues && !wsFilterValues.has(wsStr)) return;

                const { label, sortValue } = normalizePeriod(rawPeriod);
                if (!periodMap.has(label) || sortValue < periodMap.get(label)) {
                    periodMap.set(label, sortValue);
                }

                if (!groupedData[wsStr]) groupedData[wsStr] = {};
                groupedData[wsStr][label] = value;
            });

            let labels = Array.from(periodMap.entries())
                .sort((a, b) => a[1] - b[1])
                .map(([lbl]) => lbl);

            if (chartDaysWindow && labels.length > chartDaysWindow) {
                labels = labels.slice(labels.length - chartDaysWindow);
            }

            const datasets = [];
            const colors   = generateDistinctColors(Object.keys(groupedData).length);

            Object.keys(groupedData).forEach((ws, index) => {
                const wsData = groupedData[ws];

                const values = labels.map(label =>
                    wsData[label] !== undefined ? wsData[label] : null
                );

                datasets.push({
                    label: ws,
                    data: values,
                    borderColor: colors[index],
                    backgroundColor: colors[index] + '20',
                    borderWidth: 2,
                    tension: 0.4,
                    fill: false,
                    pointRadius: 1.5,
                    pointHoverRadius: 3
                });
            });

            return { labels, datasets };
        }

        function generateDistinctColors(count) {
            const colors = [
                "#667eea",
                "#764ba2",
                "#f093fb",
                "#4facfe",
                "#43e97b",
                "#fa709a",
                "#fee140",
                "#30cfd0",
                "#a8edea",
                "#fed6e3",
                "#c471ed",
                "#f64f59",
                "#12c2e9",
                "#f5af19",
                "#fbc2eb",
                "#a6c1ee",
            ];
            const result = [];
            for (let i = 0; i < count; i++) {
                result.push(colors[i % colors.length]);
            }
            return result;
        }

        function applyChartsPerRow() {
            const select = document.getElementById("chartsPerRowSelect");
            const container = document.getElementById("chartsContainer");
            if (!select || !container) return;

            const value = parseInt(select.value || "2", 10);
            const perRow = Math.min(Math.max(value, 1), 3);
            container.style.setProperty("--charts-per-row", perRow);
        }

        function handleImportedData(rows) {
            originalRows = rows;
            // copy m·∫£ng rows sang currentData
            currentData = [...rows];
            refreshKpiAndDateOptions(rows);
            renderCharts();
        }


        function renderCharts() {
            if (!currentData || numericColumns.length === 0) return;

            const activeKpiCols = numericColumns.filter(col => selectedKpiColumns.has(col));

            if (!activeKpiCols.length) {
                const container = document.getElementById('chartsContainer');
                if (container) {
                    container.innerHTML =
                        '<p style="padding:8px; font-size:0.9em; color:#6b7280;">Kh√¥ng c√≥ KPI n√†o ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ v·∫Ω bi·ªÉu ƒë·ªì.</p>';
                }

                Object.values(chartInstances).forEach(ch => ch.destroy());
                chartInstances = {};

                // üîÅ Kh√¥ng c√≥ KPI n√†o -> reset lu√¥n c√°c b·∫£ng li√™n quan
                if (typeof renderExcelStyleTable === "function") {
                    renderExcelStyleTable();
                }
                if (typeof renderLatestKpiTable === "function") {
                    renderLatestKpiTable();
                }
                if (typeof renderWorstCellTable === "function") {
                    renderWorstCellTable();
                }

                return;
            }


            const container = document.getElementById("chartsContainer");
            applyChartsPerRow();

            // L∆∞u l·∫°i ki·ªÉu chart ƒë√£ ch·ªçn tr∆∞·ªõc ƒë√≥
            const prevTypes = {};
            document
                .querySelectorAll(".chart-type-select")
                .forEach((sel) => {
                    prevTypes[sel.dataset.column] = sel.value;
                });

            Object.values(chartInstances).forEach((ch) => ch.destroy());
            chartInstances = {};
            container.innerHTML = "";


            // V·∫Ω khung chart + combobox ch·ªçn ki·ªÉu
            activeKpiCols.forEach((valueCol, index) => {
                const chartId = `chart_${index}`;

                // ‚úÖ Default: line, ri√™ng 2 KPI MAC SDU ‚Üí stackedArea
                let prevType = prevTypes[valueCol];
                if (!prevType) {
                    prevType = isMacSduKpi(valueCol) ? "stackedArea" : "line";
                }

                const titleText = getKpiTitleWithUnit(valueCol);

                // Ki·ªÉm tra xem KPI n√†y c√≥ ng∆∞·ª°ng kh√¥ng
                const thr = getThresholdForKpiColumn(valueCol);
                const hasThreshold =
                    thr && typeof thr.value === "number" && !isNaN(thr.value);

                const isTargetOn = !!chartTargetVisible[valueCol];

                container.innerHTML += `
                    <div class="chart-card">
                        <h3>${titleText}</h3>
                        <div class="chart-header-row"
                            style="display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px;">
                            <span id="period-label-${chartId}"
                                style="font-size:0.8em; color:#6b7280;"></span>
                            <div style="display:flex; align-items:center; gap:8px;">
                                <span style="font-size:0.85em; color:#555;">Ki·ªÉu chart:</span>
                                <select class="chart-type-select"
                                        data-chart-id="${chartId}"
                                        data-column="${valueCol}">
                                    <option value="line" ${prevType === "line" ? "selected" : ""}>Line</option>
                                    <option value="bar" ${prevType === "bar" ? "selected" : ""}>Bar</option>
                                    <option value="stackedArea" ${prevType === "stackedArea" ? "selected" : ""}>Stacked Area</option>
                                    <option value="pie" ${prevType === "pie" ? "selected" : ""}>Pie</option>
                                    <option value="doughnut" ${prevType === "doughnut" ? "selected" : ""}>Doughnut</option>
                                    <option value="funnel" ${prevType === "funnel" ? "selected" : ""}>Funnel</option>
                                </select>
                                ${
                                    hasThreshold
                                        ? `
                                <label style="display:flex; align-items:center; gap:4px; font-size:0.8em; color:#374151;">
                                    <input type="checkbox"
                                        class="chart-target-toggle"
                                        data-chart-id="${chartId}"
                                        data-column="${valueCol}"
                                        ${isTargetOn ? "checked" : ""}/>
                                    Target
                                </label>
                                `
                                        : ""
                                }
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="${chartId}"></canvas>
                        </div>
                    </div>
                `;
            });

            // Build d·ªØ li·ªáu & v·∫Ω chart
            activeKpiCols.forEach((valueCol, index) => {
                const chartId = `chart_${index}`;
                const titleText = getKpiTitleWithUnit(valueCol);
                let { labels, datasets } = buildChartDataForColumn(
                    currentData,
                    valueCol
                );
                const canvas = document.getElementById(chartId);
                if (!canvas) return;
                const ctx = canvas.getContext("2d");
                const typeSelect = document.querySelector(
                    `.chart-type-select[data-chart-id="${chartId}"]`
                );
                let chartType = typeSelect ? typeSelect.value : "line";

                // ‚úÖ N·∫øu ch·ªâ c√≥ 1 period time ‚Üí t·ª± ƒë·ªông hi·ªÉn th·ªã d·∫°ng Funnel (bar d·ªçc)
                if (
                    labels &&
                    labels.length === 1 &&
                    (chartType === "line" ||
                     chartType === "bar"  ||
                     chartType === "stackedArea")
                ) {
                    chartType = "funnel";
                    if (typeSelect) {
                        typeSelect.value = "funnel";   // c·∫≠p nh·∫≠t lu√¥n combobox cho ƒë√∫ng
                    }
                }

                const periodLabelEl = document.getElementById(
                    `period-label-${chartId}`
                );
                if (periodLabelEl) periodLabelEl.textContent = "";

                if (chartType === "pie" || chartType === "doughnut") {
                    const latestLabel = getLatestPeriodLabel(currentData);
                    const periodCol = periodColumnName;
                    const wsNameCol = getCellNameColumn();

                    const totalByWS = {};

                    currentData.forEach((row) => {
                        const wsName = row[wsNameCol];
                        const rawPeriod = row[periodCol];
                        const rawVal = row[valueCol];
                        const scale  = getKpiScaleForColumn(valueCol);
                        const numeric = parseFloat(rawVal);

                        if (
                            !wsName ||
                            rawPeriod === undefined ||
                            rawPeriod === null ||
                            isNaN(numeric)
                        )
                            return;
                        const value = numeric * scale;
                        const norm = normalizePeriod(rawPeriod);
                        if (!norm || norm.label !== latestLabel) return;

                        const wsStr = String(wsName);
                        const wsLower = wsStr.toLowerCase();
                        if (!wsPassesTextFilters(wsLower)) return;
                        if (
                            wsFilterValues &&
                            wsFilterValues.size > 0 &&
                            !wsFilterValues.has(wsStr)
                        )
                            return;

                        totalByWS[wsStr] =
                            (totalByWS[wsStr] || 0) + value;
                    });

                    labels = Object.keys(totalByWS);
                    datasets = [
                        {
                            data: Object.values(totalByWS),
                            backgroundColor: generateDistinctColors(
                                labels.length
                            ),
                            borderWidth: 1,
                        },
                    ];

                    if (periodLabelEl && latestLabel) {
                        periodLabelEl.textContent = `Ng√†y: ${latestLabel}`;
                    }
                }

if (chartType === "funnel") {
    const latestLabel = getLatestPeriodLabel(currentData);
    const periodCol = periodColumnName;
    const wsNameCol = getCellNameColumn();

    const totalByWS = {};

    // T√≠nh gi√° tr·ªã KPI cho t·ª´ng WS t·∫°i th·ªùi ƒëi·ªÉm m·ªõi nh·∫•t
    currentData.forEach((row) => {
        const wsName    = row[wsNameCol];
        const rawPeriod = row[periodCol];
        const rawVal    = row[valueCol];
        const scale     = getKpiScaleForColumn(valueCol);
        const numeric   = parseFloat(rawVal);

        if (!wsName || rawPeriod == null || isNaN(numeric)) return;

        const value = numeric * scale;
        const norm  = normalizePeriod(rawPeriod);
        if (!norm || norm.label !== latestLabel) return;

        const wsStr   = String(wsName);
        const wsLower = wsStr.toLowerCase();

        if (!wsPassesTextFilters(wsLower)) return;
        if (wsFilterValues && wsFilterValues.size > 0 && !wsFilterValues.has(wsStr)) return;

        totalByWS[wsStr] = value;
    });

    const entries = Object.entries(totalByWS);

    let filteredEntries;

    if (entries.length <= 30) {
        // √çt h∆°n ho·∫∑c b·∫±ng 30 cell -> gi·ªØ nguy√™n
        filteredEntries = entries.slice();
    } else {
        // Nhi·ªÅu h∆°n 30 cell:
        //   - L·∫•y 20 gi√° tr·ªã cao nh·∫•t
        //   - L·∫•y 10 gi√° tr·ªã th·∫•p nh·∫•t
        const descSorted = [...entries].sort((a, b) => b[1] - a[1]);
        const top20 = descSorted.slice(0, 20);
        const bottom10 = descSorted.slice(-10);

        const seen = new Set();
        filteredEntries = [];

        [...top20, ...bottom10].forEach(([name, val]) => {
            const key = String(name);
            if (!seen.has(key)) {
                seen.add(key);
                filteredEntries.push([name, val]);
            }
        });
    }

    // √Åp th·ª© t·ª± hi·ªÉn th·ªã theo combobox Funnel Sort
    if (funnelSortOrder === "asc") {
        filteredEntries.sort((a, b) => a[1] - b[1]);   // nh·ªè -> l·ªõn
    } else {
        filteredEntries.sort((a, b) => b[1] - a[1]);   // l·ªõn -> nh·ªè
    }

    labels = filteredEntries.map(([ws]) => ws);
    datasets = [
        {
            data: filteredEntries.map(([, v]) => v),
            backgroundColor: generateDistinctColors(filteredEntries.length),
            borderWidth: 1,
        }
    ];

    if (periodLabelEl && latestLabel) {
        periodLabelEl.textContent = `Ng√†y: ${latestLabel}`;
    }
}

// X√°c ƒë·ªãnh lo·∫°i chart th·ª±c t·∫ø
const thrForChart = getThresholdForKpiColumn(valueCol);

let internalType = chartType;
if (chartType === "stackedArea") {
    internalType = "line";
}

if (chartType === "funnel") {
    internalType = "bar";
}

let chartDatasets = datasets;
if (chartType === "stackedArea") {
    chartDatasets = datasets.map((ds, idx) => {
        let solidColor = ds.borderColor || "#667eea";

        return {
            ...ds,
            fill: true,
            backgroundColor: solidColor,
            borderWidth: 1,
            stack: "stack_" + valueCol,
            borderColor: solidColor,
            pointRadius: 0,
            tension: 0.3,
        };
    });
}

const hasThrForChart =
    thrForChart &&
    typeof thrForChart.value === "number" &&
    !isNaN(thrForChart.value);

// Ch·ªâ v·∫Ω target line khi:
// - C√≥ ng∆∞·ª°ng
// - Checkbox t·ªïng ƒëang b·∫≠t
// - Checkbox Target ri√™ng cho KPI n√†y ƒëang b·∫≠t
// - Lo·∫°i chart ph√π h·ª£p
const showTargetLine =
    hasThrForChart &&
    globalThresholdEnabled &&
    chartTargetVisible[valueCol] &&
    (chartType === "line" ||
        chartType === "bar" ||
        chartType === "stackedArea" ||
        chartType === "funnel");

if (showTargetLine) {
    const targetVal = thrForChart.value;
    const targetData = (labels || []).map(() => targetVal);

    chartDatasets = [
        ...chartDatasets,
        {
            label: "Target",
            data: targetData,
            type: "line",
            borderWidth: 5,        // ƒê·ªô d√†y target line
            borderColor: "#ff0000",
            borderDash: [8, 5],
            pointRadius: 0,
            tension: 0,
            fill: false,
            yAxisID: "y",
        },
    ];
}


                chartInstances[chartId] = new Chart(ctx, {
                    type: internalType,
                    data: {
                        labels,
                        datasets: chartDatasets,
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: "index",
                            intersect: false,
                        },
                        plugins: {
                            legend: {
                                display: chartType !== "funnel",   // funnel th√¨ t·∫Øt legend
                                position: "bottom",
                                labels: {
                                    usePointStyle: true,
                                    padding: 12,
                                    font: {
                                        size: 11,
                                    },
                                },
                            },
                            tooltip: {
                                backgroundColor:
                                    "rgba(0, 0, 0, 0.85)",
                                padding: 10,
                                titleFont: {
                                    size: 13,
                                },
                                bodyFont: {
                                    size: 12,
                                },
                                callbacks: {
                                    label: function (ctx) {
                                        const chartTypeInternal =
                                            ctx.chart.config.type;
                                        const raw =
                                            typeof ctx.parsed.y ===
                                            "number"
                                                ? ctx.parsed.y
                                                : ctx.raw;
                                        const value =
                                            typeof raw === "number"
                                                ? Math.round(
                                                      raw * 1000
                                                  ) / 1000
                                                : raw;

                                        if (
                                            chartTypeInternal === "pie" ||
                                            chartTypeInternal === "doughnut"
                                        ) {
                                            const dataArr =
                                                ctx.dataset.data || [];
                                            const total =
                                                dataArr.reduce(
                                                    (s, v) =>
                                                        s +
                                                        (typeof v ===
                                                        "number"
                                                            ? v
                                                            : 0),
                                                    0
                                                );
                                            const pct = total
                                                ? Math.round(
                                                      (value / total) *
                                                          100000
                                                  ) / 1000
                                                : 0;
                                            return `${ctx.label}: ${value} (${pct}%)`;
                                        }

                                        const label = ctx.dataset
                                            .label
                                            ? ctx.dataset.label + ": "
                                            : "";
                                        return label + value;
                                    },
                                },
                            },
                            datalabels: {
                                display: function (ctx) {
                                    const type =
                                        ctx.chart.config.type;
                                    return (
                                        type === "pie" ||
                                        type === "doughnut"
                                    );
                                },
                                formatter: function (value, ctx) {
                                    if (
                                        typeof value !== "number" ||
                                        isNaN(value)
                                    )
                                        return "";
                                    const dataArr =
                                        ctx.chart.data.datasets[
                                            ctx.datasetIndex
                                        ].data || [];
                                    const total = dataArr.reduce(
                                        (s, v) =>
                                            s +
                                            (typeof v === "number"
                                                ? v
                                                : 0),
                                        0
                                    );
                                    if (!total) return "";
                                    const pct =
                                        Math.round(
                                            (value / total) * 100000
                                        ) / 1000;
                                    return pct + "%";
                                },
                                color: "#ffffff",
                                font: {
                                    size: 10,
                                    weight: "bold",
                                },
                                textStrokeColor: "#000",
                                textStrokeWidth: 2,
                                padding: 3,
                                clamp: true,
                                anchor: "center",
                                align: "center",
                            },
                        },
                        scales: {
                            x: {
                                // Hi·ªán tr·ª•c X cho line / bar / stackedArea / funnel
                                display:
                                    chartType === "line" ||
                                    chartType === "bar" ||
                                    chartType === "stackedArea" ||
                                    chartType === "funnel",
                                title: {
                                    display:
                                        chartType === "line" ||
                                        chartType === "bar" ||
                                        chartType === "stackedArea" ||
                                        chartType === "funnel",
                                    // ‚úÖ Funnel: tr·ª•c X l√† CELL_NAME, c√°c chart kh√°c: Period Time / Period Hour
                                    text: getXAxisLabel(chartType),
                                    font: {
                                        size: 13,
                                        weight: "bold",
                                    },
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45,
                                },
                            },
                            y: {
                                // Hi·ªán tr·ª•c Y cho line / bar / stackedArea / funnel
                                display:
                                    chartType === "line" ||
                                    chartType === "bar" ||
                                    chartType === "stackedArea" ||
                                    chartType === "funnel",
                                title: {
                                    display:
                                        chartType === "line" ||
                                        chartType === "bar" ||
                                        chartType === "stackedArea" ||
                                        chartType === "funnel",
                                    text: titleText,   // t√™n KPI, d√πng chung
                                    font: {
                                        size: 13,
                                        weight: "bold",
                                    },
                                },
                                // Gi·ªØ behaviour c≈©, ch·ªâ b·∫Øt ƒë·∫ßu t·ª´ 0 cho Funnel n·∫øu anh mu·ªën
                                beginAtZero: chartType === "funnel" ? true : false,
                                grace: "10%",
                                stacked: chartType === "stackedArea"
                            },
                        },
                    },
                });
            });

            document
                .querySelectorAll(".chart-type-select")
                .forEach((sel) => {
                    sel.onchange = () => {
                        renderCharts();
                    };
                });

            // NEW: checkbox b·∫≠t/t·∫Øt line target
            document
                .querySelectorAll(".chart-target-toggle")
                .forEach((cb) => {
                    cb.onchange = () => {
                        const col = cb.dataset.column;
                        chartTargetVisible[col] = cb.checked;
                        renderCharts();
                    };
                });

            renderLatestKpiTable();
            renderExcelStyleTable();
        }

        function buildExcelDateOptions() {
            if (!currentData || !periodColumnName) return;

            const input = document.getElementById("excelDateInput");
            if (!input) return;

            const periodCol = periodColumnName;
            const labelMap = new Map();

            currentData.forEach((row) => {
                const rawPeriod = row[periodCol];
                if (rawPeriod === undefined || rawPeriod === null) return;
                const norm = normalizePeriod(rawPeriod);
                if (!norm || !norm.label) return;

                if (
                    !labelMap.has(norm.label) ||
                    norm.sortValue > labelMap.get(norm.label)
                ) {
                    labelMap.set(norm.label, norm.sortValue);
                }
            });

            const labels = Array.from(labelMap.entries())
                .sort((a, b) => a[1] - b[1])
                .map(([label]) => label);

            if (!labels.length) {
                input.value = "";
                excelSelectedDate = null;
                return;
            }

            const latestLabel = labels[labels.length - 1];

            excelSelectedDate = latestLabel;
            input.value = latestLabel;

            const latestBtn = document.getElementById("excelLatestBtn");
            if (latestBtn) {
                latestBtn.onclick = function () {
                    excelSelectedDate = latestLabel;
                    input.value = latestLabel;
                    renderExcelStyleTable();
                };
            }

            input.onchange = function () {
                excelSelectedDate = this.value || null;
                renderExcelStyleTable();
            };
        }

        function renderExcelStyleTable() {
            if (!currentData || numericColumns.length === 0) return;

            const tableCard = document.getElementById("excelTableCard");
            const tableDiv  = document.getElementById("excelTable");
            const titleEl   = document.getElementById("excelTableTitle");
            if (!tableCard || !tableDiv || !titleEl) return;
    
            // N·∫øu ch∆∞a load KPI Threshhold th√¨ trigger load & render l·∫°i sau khi xong
            if (kpiThresholdMap === null) {
                ensureKpiThresholdsLoaded().then(() => {
                    if (tableCard && tableCard.style.display !== "none") {
                        renderExcelStyleTable();
                    }
                });
            }

            let targetLabel = excelSelectedDate || getLatestPeriodLabel(currentData);
            if (!targetLabel) {
                tableCard.style.display = "none";
                return;
            }

            const activeKpiCols = numericColumns.filter(col => selectedKpiColumns.has(col));

            if (!activeKpiCols.length) {
                titleEl.textContent = `KPI Overview (Ng√†y: ${targetLabel}) ‚Äì kh√¥ng c√≥ KPI n√†o ƒë∆∞·ª£c ch·ªçn`;
                tableDiv.innerHTML  = "";
                tableCard.style.display = "block";
                return;
            }

            const periodCol = periodColumnName;
            const wsNameCol = getCellNameColumn();   // üëâ KPI Overview l·∫•y ƒë√∫ng CELL_NAME
            const sheetName =
                document.getElementById("sheetSelect")?.value || "";

            const wsSet = new Set();

            currentData.forEach((row) => {
                const wsName    = row[wsNameCol];
                const rawPeriod = row[periodCol];
                if (!wsName || rawPeriod === undefined || rawPeriod === null)
                    return;

                const norm = normalizePeriod(rawPeriod);
                if (!norm || norm.label !== targetLabel) return;

                const wsStr   = String(wsName);
                const wsLower = wsStr.toLowerCase();

                if (!wsPassesTextFilters(wsLower)) return;
                if (wsFilterValues && wsFilterValues.size > 0 && !wsFilterValues.has(wsStr))
                    return;

                wsSet.add(wsStr);
            });

            const wsList = Array.from(wsSet).sort();

            if (wsList.length === 0) {
                titleEl.textContent = `KPI Overview (Ng√†y: ${targetLabel}) ‚Äì kh√¥ng c√≥ d·ªØ li·ªáu kh·ªõp b·ªô l·ªçc`;
                tableDiv.innerHTML  = "";
                tableCard.style.display = "block";
                return;
            }

            const wsSetForLookup = new Set(wsList);
            const valueByKpiWs = {};

            currentData.forEach((row) => {
                const wsName    = row[wsNameCol];
                const rawPeriod = row[periodCol];
                if (!wsName || rawPeriod === undefined || rawPeriod === null)
                    return;

                const norm = normalizePeriod(rawPeriod);
                if (!norm || norm.label !== targetLabel) return;

                const wsStr = String(wsName);
                if (!wsSetForLookup.has(wsStr)) return;

                activeKpiCols.forEach((kpiCol) => {
                    const rawVal = row[kpiCol];
                    const num    = parseFloat(rawVal);
                    if (isNaN(num)) return;

                    const scale  = getKpiScaleForColumn(kpiCol);
                    const scaled = num * scale;

                    if (!valueByKpiWs[kpiCol]) valueByKpiWs[kpiCol] = {};
                    valueByKpiWs[kpiCol][wsStr] = scaled;
                });
            });

            titleEl.textContent = `KPI Overview (Ng√†y: ${targetLabel})`;
            const colSpan = 4 + wsList.length;
            let html = `<table>
                <thead>
                    <tr>
                        <th colspan="${colSpan}" style="background:#1f2937; color:#fff; padding:6px 8px; text-align:center; font-weight:700;">
                            ${sheetName || "KPI Daily Report"}
                        </th>
                    </tr>
                    <tr>
                        <th colspan="${colSpan}" style="background:#fde68a; color:#111827; padding:4px 8px; text-align:right; font-weight:600;">
                            Ng√†y: ${targetLabel}
                        </th>
                    </tr>
                    <tr>
                        <th style="background:#203864; color:#fff; padding:6px 8px; border:1px solid #cbd5e1; white-space:nowrap;">KPI Name</th>
                        <th style="background:#203864; color:#fff; padding:6px 8px; border:1px solid #cbd5e1;">KPI ID</th>
                        <th style="background:#203864; color:#fff; padding:6px 8px; border:1px solid #cbd5e1;">Unit</th>
                        <th style="background:#203864; color:#fff; padding:6px 8px; border:1px solid #cbd5e1;">Target</th>`;

            wsList.forEach((ws) => {
                html += `<th style="background:#9bbb59; color:#111827; padding:6px 8px; border:1px solid #cbd5e1; text-align:center;">${ws}</th>`;
            });

            html += `</tr></thead><tbody>`;

            activeKpiCols.forEach((kpiCol) => {
                const rowValues = valueByKpiWs[kpiCol] || {};
                const meta      = findKpiMetaForColumn(kpiCol) || {};
                const kpiId     = meta.id   || "";
                const unitLabel = getDisplayUnit(meta);
                const kpiName   = meta.name || kpiCol;

                // L·∫•y ng∆∞·ª°ng v√† ƒë·∫£o chi·ªÅu ƒë·ªÉ hi·ªÉn th·ªã Target
                const thr = getThresholdForKpiColumn(kpiCol);
                let targetDisplay = "";

                if (thr && thr.op && typeof thr.value === "number") {
                    const reversedOp =
                        thr.op === "<"  ? ">"  :
                        thr.op === "<=" ? ">=" :
                        thr.op === ">"  ? "<"  :
                        thr.op === ">=" ? "<=" :
                        (thr.op === "=" || thr.op === "==") ? "=" : "";

                    targetDisplay = reversedOp ? `${reversedOp} ${thr.value}` : "";
                }

                html += `<tr>
                    <td style="padding:6px 16px; border:1px solid #e5e7eb; background:#d9e1f2; font-weight:600; white-space:nowrap;">${kpiName}</td>
                    <td style="padding:6px 8px; border:1px solid #e5e7eb; background:#d9e1f2; text-align:center;">${kpiId}</td>
                    <td style="padding:6px 8px; border:1px solid #e5e7eb; background:#d9e1f2; text-align:center;">${unitLabel}</td>
                    <td style="padding:6px 8px; border:1px solid #e5e7eb; background:#d9e1f2; text-align:center; font-weight:600;">${targetDisplay}</td>`;

                wsList.forEach((ws) => {
    const v = rowValues[ws];
    let display = "";
    if (typeof v === "number" && !isNaN(v)) {
        display = Math.round(v * 1000) / 1000;
    }

    // === Highlight theo ng∆∞·ª°ng ch·ªâ khi checkbox t·ªïng ƒëang b·∫≠t ===
    let condStyle = "";
    if (
        globalThresholdEnabled &&             // üî¥ g·∫Øn v·ªõi checkbox t·ªïng
        typeof v === "number" &&
        !isNaN(v) &&
        kpiThresholdMap
    ) {
        const thr = getThresholdForKpiColumn(kpiCol);
        if (thr) {
            const num = v;
            const t   = thr.value;
            const op  = thr.op;
            let isBad = false;

            if (op === "<") {
                isBad = num < t;
            } else if (op === ">") {
                isBad = num > t;
            } else if (op === "<=") {
                isBad = num <= t;
            } else if (op === ">=") {
                isBad = num >= t;
            } else if (op === "=" || op === "==") {
                isBad = num === t;
            }

            if (isBad) {
                condStyle =
                    "background:#fee2e2; color:#b91c1c; font-weight:700;";
            }
        }
    }

    html += `<td style="padding:6px 8px; border:1px solid #e5e7eb; text-align:center; ${condStyle}">${display}</td>`;
});


                html += `</tr>`;
            });

            html += `</tbody></table>`;

            tableDiv.innerHTML = `<div style="min-width:100%; overflow-x:auto;">${html}</div>`;
            tableCard.style.display = "block";

            applyStickyKpiColumns();
            applyKpiOverviewTargetVisibility();


        }

        function applyStickyKpiColumns() {
            const wrapper = document.getElementById('excelTable');
            if (!wrapper) return;

            const table = wrapper.querySelector('table');
            if (!table || !table.tHead) return;

            requestAnimationFrame(() => {
                const headerRows = Array.from(table.tHead.rows);
                if (!headerRows.length) return;

                const headerRow = headerRows[headerRows.length - 1];
                const stickyCount = globalThresholdEnabled ? 4 : 3;

                const tableRect = table.getBoundingClientRect();
                const colLeft = [];

                for (let i = 0; i < stickyCount; i++) {
                    const cell = headerRow.cells[i];
                    if (!cell) continue;
                    const rect = cell.getBoundingClientRect();
                    colLeft[i] = rect.left - tableRect.left;
                }

                const oldSticky = table.querySelectorAll('.sticky-col');
                oldSticky.forEach(c => {
                    c.classList.remove('sticky-col');
                    c.style.left = '';
                    c.style.position = '';
                });

                const rows = Array.from(table.rows);
                rows.forEach(row => {
                    for (let i = 0; i < stickyCount; i++) {
                        const cell = row.cells[i];
                        if (!cell) continue;

                        cell.classList.add('sticky-col');
                        cell.style.position = 'sticky';
                        cell.style.left = (colLeft[i] || 0) + 'px';

                        if (!cell.style.backgroundColor) {
                            if (row.parentNode.tagName === 'THEAD') {
                                cell.style.backgroundColor = '#203864';
                                cell.style.color = '#fff';
                            } else {
                                cell.style.backgroundColor = '#d9e1f2';
                            }
                        }
                    }
                });
            });
        }
// C·ªë ƒë·ªãnh N c·ªôt ƒë·∫ßu cho 1 b·∫£ng b·∫•t k·ª≥ (theo id container)
function applyStickyForTable(wrapperId, stickyCount) {
    const wrapper = document.getElementById(wrapperId);
    if (!wrapper) return;

    const table = wrapper.querySelector("table");
    if (!table || !table.tHead) return;

    requestAnimationFrame(() => {
        const headerRows = Array.from(table.tHead.rows);
        if (!headerRows.length) return;

        const headerRow = headerRows[headerRows.length - 1];

        const tableRect = table.getBoundingClientRect();
        const colLeft = [];

        // T√≠nh left cho t·ª´ng c·ªôt s·∫Ω sticky
        for (let i = 0; i < stickyCount; i++) {
            const cell = headerRow.cells[i];
            if (!cell) continue;
            const rect = cell.getBoundingClientRect();
            colLeft[i] = rect.left - tableRect.left;
        }

        // X√≥a class sticky c≈© n·∫øu c√≥
        const oldSticky = table.querySelectorAll(".sticky-col");
        oldSticky.forEach((c) => {
            c.classList.remove("sticky-col");
            c.style.left = "";
            c.style.position = "";
        });

        // G√°n l·∫°i sticky cho N c·ªôt ƒë·∫ßu
        const rows = Array.from(table.rows);
        rows.forEach((row) => {
            for (let i = 0; i < stickyCount; i++) {
                const cell = row.cells[i];
                if (!cell) continue;

                cell.classList.add("sticky-col");
                cell.style.position = "sticky";
                cell.style.left = (colLeft[i] || 0) + "px";
            }
        });
    });
}

// √Åp d·ª•ng cho Worst Cell + Cell Non-Traffic (4 c·ªôt ƒë·∫ßu)
function applyWorstCellStickyColumns() {
    applyStickyForTable("worstCellTable", 4);
    applyStickyForTable("nonTrafficTable", 4);
}

        function applyKpiOverviewTargetVisibility() {
            const wrapper = document.getElementById("excelTable");
            if (!wrapper) return;

            const table = wrapper.querySelector("table");
            if (!table) return;

            const showTarget = globalThresholdEnabled;

            // Header: ch·ªâ h√†ng cu·ªëi c√πng m·ªõi c√≥ c·ªôt Target
            if (table.tHead) {
                const headerRows = Array.from(table.tHead.rows);
                headerRows.forEach((row) => {
                    if (row.cells.length > 3) {
                        const cell = row.cells[3]; // c·ªôt Target
                        if (cell) cell.style.display = showTarget ? "" : "none";
                    }
                });
            }

            // Body: m·ªói row c√≥ c·ªôt [0: KPI Name, 1: KPI ID, 2: Unit, 3: Target, ...]
            Array.from(table.tBodies || []).forEach((tbody) => {
                Array.from(tbody.rows).forEach((row) => {
                    if (row.cells.length > 3) {
                        const cell = row.cells[3];
                        if (cell) cell.style.display = showTarget ? "" : "none";
                    }
                });
            });
        }
// ===== B·ªô l·ªçc gi√° tr·ªã cho b·∫£ng Worst Cell =====
let worstCellFilterRules   = [];   // [{id, colKey, op, value}, ...]
let worstCellFilterLogic   = "AND";
let worstFilterKpiOptions  = [];   // [{colKey, label}]
let worstFilterUiBound     = false;

function initWorstFilterEvents() {
    if (worstFilterUiBound) return;

    const logicSelect = document.getElementById("worstFilterLogic");
    const addBtn      = document.getElementById("worstFilterAddBtn");
    const clearBtn    = document.getElementById("worstFilterClearBtn");

    if (!logicSelect || !addBtn || !clearBtn) return;

    // Thay ƒë·ªïi AND / OR
    logicSelect.onchange = (e) => {
        worstCellFilterLogic = e.target.value === "OR" ? "OR" : "AND";
        renderWorstCellTable();
    };

    // Th√™m 1 ƒëi·ªÅu ki·ªán m·ªõi
    addBtn.onclick = () => {
        if (!worstFilterKpiOptions.length) return;

        const firstColKey = worstFilterKpiOptions[0].colKey;
        worstCellFilterRules.push({
            id: Date.now() + "_" + Math.random().toString(16).slice(2),
            colKey: firstColKey,
            op: "<",
            value: ""
        });
        renderWorstFilterRules();
        renderWorstCellTable();
    };

    // X√≥a to√†n b·ªô ƒëi·ªÅu ki·ªán
    clearBtn.onclick = () => {
        worstCellFilterRules = [];
        renderWorstFilterRules();
        renderWorstCellTable();
    };

    worstFilterUiBound = true;
}

// T·∫°o danh s√°ch KPI cho combobox filter (t·ª´ orderedCols c·ªßa b·∫£ng)
function initWorstFilterOptionsFromCols(orderedCols) {
    initWorstFilterEvents();

    // KPI: t·ª´ c·ªôt th·ª© 5 tr·ªü ƒëi (b·ªè PO, Province, NRBTS, NRCEL)
    const metricCols = orderedCols.slice(4);

    worstFilterKpiOptions = metricCols.map((colKey) => ({
        colKey,
        label: String(colKey)
    }));

    renderWorstFilterRules();
}

// V·∫Ω l·∫°i list ƒëi·ªÅu ki·ªán d∆∞·ªõi thanh filter
function renderWorstFilterRules() {
    const container = document.getElementById("worstFilterRules");
    if (!container) return;

    container.innerHTML = "";

    if (!worstCellFilterRules.length) {
        const p = document.createElement("div");
        p.style.fontSize = "0.8em";
        p.style.color = "#6b7280";
        p.textContent = "Ch∆∞a c√≥ ƒëi·ªÅu ki·ªán filter.";
        container.appendChild(p);
        return;
    }

    worstCellFilterRules.forEach((rule) => {
        const rowDiv = document.createElement("div");
        rowDiv.style.display = "flex";
        rowDiv.style.gap = "4px";
        rowDiv.style.alignItems = "center";

        // Ch·ªçn KPI
        const kpiSelect = document.createElement("select");
        kpiSelect.style.padding = "4px 6px";
        kpiSelect.style.borderRadius = "6px";
        kpiSelect.style.border = "1px solid #cbd5e1";

        worstFilterKpiOptions.forEach((optInfo) => {
            const opt = document.createElement("option");
            opt.value = optInfo.colKey;
            opt.textContent = optInfo.label;
            if (optInfo.colKey === rule.colKey) opt.selected = true;
            kpiSelect.appendChild(opt);
        });
        kpiSelect.onchange = (e) => {
            rule.colKey = e.target.value;
            renderWorstCellTable();
        };

        // Ch·ªçn to√°n t·ª≠
        const opSelect = document.createElement("select");
        opSelect.style.padding = "4px 6px";
        opSelect.style.borderRadius = "6px";
        opSelect.style.border = "1px solid #cbd5e1";

        ["<", "<=", ">", ">=", "=", "=="].forEach((op) => {
            const opt = document.createElement("option");
            opt.value = op;
            opt.textContent = op;
            if (op === rule.op) opt.selected = true;
            opSelect.appendChild(opt);
        });
        opSelect.onchange = (e) => {
            rule.op = e.target.value;
            renderWorstCellTable();
        };

        // Nh·∫≠p gi√° tr·ªã
        // Nh·∫≠p gi√° tr·ªã - ch·ªâ filter khi k·∫øt th√∫c nh·∫≠p (change ho·∫∑c Enter)
        // Nh·∫≠p gi√° tr·ªã - ch·ªâ filter khi k·∫øt th√∫c nh·∫≠p (change ho·∫∑c Enter)
        const valInput = document.createElement("input");
        valInput.type = "number";
        valInput.step = "any";
        valInput.style.padding = "4px 6px";
        valInput.style.width = "90px";
        valInput.style.borderRadius = "6px";
        valInput.style.border = "1px solid #cbd5e1";

        // üëâ G√°n l·∫°i gi√° tr·ªã ƒëang l∆∞u trong rule (n·∫øu c√≥) ƒë·ªÉ hi·ªÉn th·ªã l√™n √¥ input
        valInput.value = rule.value ?? "";

        // Khi ƒëang g√µ th√¨ ch·ªâ l∆∞u value, KH√îNG render l·∫°i b·∫£ng
        valInput.oninput = (e) => {
            rule.value = e.target.value;
        };

        // Khi ng∆∞·ªùi d√πng r·ªùi kh·ªèi √¥ (blur/change) th√¨ m·ªõi √°p d·ª•ng filter
        valInput.onchange = (e) => {
            rule.value = e.target.value;
            renderWorstCellTable();
        };

        // Nh·∫•n Enter c≈©ng √°p d·ª•ng filter ngay
        valInput.onkeydown = (ev) => {
            if (ev.key === "Enter") {
                ev.preventDefault();
                valInput.blur();        // cho trigger onchange
                renderWorstCellTable();
            }
        };



        // N√∫t x√≥a ƒëi·ªÅu ki·ªán
        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.textContent = "‚úï";
        removeBtn.style.padding = "2px 6px";
        removeBtn.style.borderRadius = "6px";
        removeBtn.style.border = "1px solid #ef4444";
        removeBtn.style.background = "#fee2e2";
        removeBtn.style.cursor = "pointer";
        removeBtn.onclick = () => {
            worstCellFilterRules = worstCellFilterRules.filter((r) => r.id !== rule.id);
            renderWorstFilterRules();
            renderWorstCellTable();
        };

        rowDiv.appendChild(kpiSelect);
        rowDiv.appendChild(opSelect);
        rowDiv.appendChild(valInput);
        rowDiv.appendChild(removeBtn);

        container.appendChild(rowDiv);
    });
}

// √Åp d·ª•ng danh s√°ch ƒëi·ªÅu ki·ªán v√†o rowsArr
function applyWorstCellValueFilters(rowsArr, orderedCols) {
    if (!worstCellFilterRules.length) return rowsArr;

    // Ch·ªâ gi·ªØ rule c√≥ ƒë·ªß KPI + to√°n t·ª≠ + value
    const rules = worstCellFilterRules.filter(
        (r) => r.colKey && r.op && r.value !== ""
    );
    if (!rules.length) return rowsArr;

    const logic = worstCellFilterLogic === "OR" ? "OR" : "AND";

    function toNumberSafe(v) {
        if (v === null || v === undefined || v === "") return null;
        const num = parseFloat(String(v).replace(/\s+/g, "").replace(",", "."));
        return Number.isNaN(num) ? null : num;
    }

    return rowsArr.filter((row) => {
        let anyTrue = false;

        for (const rule of rules) {
            const val = row[rule.colKey];
            const num = toNumberSafe(val);
            const thr = toNumberSafe(rule.value);

            // N·∫øu kh√¥ng convert ƒë∆∞·ª£c sang s·ªë ‚áí coi nh∆∞ kh√¥ng th·ªèa
            if (num === null || thr === null) {
                if (logic === "AND") return false;
                else continue;
            }

            let ok = false;
            if (rule.op === "<") ok = num < thr;
            else if (rule.op === "<=") ok = num <= thr;
            else if (rule.op === ">") ok = num > thr;
            else if (rule.op === ">=") ok = num >= thr;
            else if (rule.op === "=" || rule.op === "==") ok = num === thr;

            if (logic === "AND" && !ok) return false;
            if (logic === "OR" && ok) {
                anyTrue = true;
                break;
            }
        }

        return logic === "AND" ? true : anyTrue;
    });
}

        function renderWorstCellTable() {
            const worstCard    = document.getElementById("worstCellCard");
            const worstTableEl = document.getElementById("worstCellTable");
            const worstTitleEl = document.getElementById("worstCellTitle");

            const nonCard      = document.getElementById("nonTrafficCard");
            const nonTableEl   = document.getElementById("nonTrafficTable");
            const nonTitleEl   = document.getElementById("nonTrafficTitle");

            // Load ng∆∞·ª°ng WorstCell threshold (sheet "WorstCell Threshold") n·∫øu ch∆∞a load
            if (worstCellThresholdMap === null) {
                ensureWorstCellThresholdsLoaded().then(() => {
                    if (worstCard) {
                        // G·ªçi render l·∫°i sau khi ƒë√£ c√≥ ng∆∞·ª°ng
                        renderWorstCellTable();
                    }
                });
            }

            if (!worstCard || !worstTableEl || !worstTitleEl) return;
            if (isHeavyKpiFile && (!selectedKpiColumns || selectedKpiColumns.size === 0)) {
                worstCard.style.display = "none";
                worstTableEl.innerHTML = "";
                if (nonCard && nonTableEl) {
                    nonCard.style.display = "none";
                    nonTableEl.innerHTML = "";
                }
                return;
            }
            let rows = null;

            if (typeof mergedDataPerSheet !== "undefined" &&
                mergedDataPerSheet &&
                mergedDataPerSheet["WorstCell"]) {
                rows = mergedDataPerSheet["WorstCell"];
            }
            else if (workbook && workbook.Sheets["WorstCell"]) {
                const sheet = workbook.Sheets["WorstCell"];
                rows = XLSX.utils.sheet_to_json(sheet, { defval: null });
            }

            if (!rows || !rows.length) {
                worstCard.style.display = "none";
                if (nonCard) nonCard.style.display = "none";
                return;
            }

            const columns = Object.keys(rows[0]);

// Lo·∫°i b·ªè c√°c c·ªôt r√°c Excel t·ª± sinh (_EMPTY, __EMPTY, __EMPTY_1, ...)
const ignorePatterns = ["_empty", "__empty"];
const cleanColumns = columns.filter(col => {
    const lower = String(col).toLowerCase();
    return !ignorePatterns.some(p => lower.includes(p));
});

            let periodCol = null;
            for (const col of columns) {
                const lower = String(col).toLowerCase();
                if (
                    lower.includes("period") ||
                    lower.includes("time") ||
                    lower.includes("date")
                ) {
                    periodCol = col;
                    break;
                }
            }

let nrbtsCol  = null;
let nrCellCol = null;
let availCol  = null;
let macDlCol  = null; // MAC SDU data vol trans DL DTCH
let macUlCol  = null; // MAC SDU data vol rcvd UL DTCH
let traffic5gCol  = null; // 5G Total Traffic Volume

cleanColumns.forEach(col => {
    const lower = String(col).toLowerCase();

    if (!nrbtsCol && lower.includes("nrbts")) nrbtsCol = col;
    if (!nrCellCol && (lower.includes("nrcel") || lower.includes("nrcell")))
        nrCellCol = col;
    if (!availCol && lower.includes("cell avail")) availCol = col;

    if (!macDlCol && lower.startsWith("mac sdu data vol trans dl dtch")) {
        macDlCol = col;
    }
    if (!macUlCol && lower.startsWith("mac sdu data vol rcvd ul dtch")) {
        macUlCol = col;
    }

    // üëâ C·ªôt "5G Total Traffic Volume"
    if (!traffic5gCol && lower.includes("5g total traffic volume")) {
        traffic5gCol = col;
    }
});

            const highlightedKeys = new Set();

            if (workbook && workbook.Sheets && workbook.Sheets["WorstCell"]) {
                const sheet = workbook.Sheets["WorstCell"];
                const ref = sheet["!ref"];
                if (ref) {
                    const range = XLSX.utils.decode_range(ref);
                    const headerRow = range.s.r;

                    let nrbtsIdx = null;
                    let nrCellIdx = null;

                    for (let C = range.s.c; C <= range.e.c; C++) {
                        const addr = XLSX.utils.encode_cell({ r: headerRow, c: C });
                        const cell = sheet[addr];
                        if (!cell || cell.v == null) continue;
                        const headerText = String(cell.v).trim();
                        if (headerText === nrbtsCol)  nrbtsIdx = C;
                        if (headerText === nrCellCol) nrCellIdx = C;
                    }

                    for (let R = headerRow + 1; R <= range.e.r; R++) {
                        let hasColor = false;

                        for (let C = range.s.c; C <= range.e.c; C++) {
                            const addr = XLSX.utils.encode_cell({ r: R, c: C });
                            const cell = sheet[addr];
                            if (!cell || !cell.s || !cell.s.fill) continue;

                            const fill = cell.s.fill;
                            const fg = fill.fgColor || {};
                            const bg = fill.bgColor || {};

                            const hasFg =
                                (fg.rgb && fg.rgb !== "00000000" && fg.rgb !== "FFFFFFFF") ||
                                fg.theme != null ||
                                fg.indexed != null;
                            const hasBg =
                                (bg.rgb && bg.rgb !== "00000000" && bg.rgb !== "FFFFFFFF") ||
                                bg.theme != null ||
                                bg.indexed != null;

                            if (hasFg || hasBg) {
                                hasColor = true;
                                break;
                            }
                        }

                        if (!hasColor) continue;

                        const nrbtsVal = (nrbtsIdx != null
                            ? (sheet[XLSX.utils.encode_cell({ r: R, c: nrbtsIdx })] || {}).v
                            : "") || "";
                        const nrcelVal = (nrCellIdx != null
                            ? (sheet[XLSX.utils.encode_cell({ r: R, c: nrCellIdx })] || {}).v
                            : "") || "";

                        const key = `${String(nrbtsVal).trim()}||${String(nrcelVal).trim()}`;
                        highlightedKeys.add(key);
                    }
                }
            }

            function makeRowKey(row) {
                const nrbtsVal = nrbtsCol ? (row[nrbtsCol] || "") : "";
                const nrcelVal = nrCellCol ? (row[nrCellCol] || "") : "";
                return `${String(nrbtsVal).trim()}||${String(nrcelVal).trim()}`;
            }

            function isNumericLike(v) {
                if (v === null || v === undefined) return false;
                const s = String(v).trim().replace(/\s+/g, "");
                return /^-?\d+(\.\d+)?$/.test(s);
            }

            function formatNumberSmart(v) {
                const num = parseFloat(String(v).trim().replace(/\s+/g, ""));
                if (isNaN(num)) return v ?? "";
                const rounded = Math.round(num * 1000) / 1000;
                return Number.isInteger(rounded)
                    ? String(rounded)
                    : rounded.toFixed(3);
            }

            let latestLabel = null;
            let latestSort  = -Infinity;

            if (periodCol) {
                rows.forEach(r => {
                    const raw = r[periodCol];
                    if (!raw) return;
                    const norm = normalizePeriod(raw);
                    if (!norm) return;
                    if (norm.sortValue > latestSort) {
                        latestSort  = norm.sortValue;
                        latestLabel = norm.label;
                    }
                });
            }

            let latestRows = rows;
            if (periodCol && latestLabel) {
                latestRows = rows.filter(r => {
                    const raw = r[periodCol];
                    if (!raw) return false;
                    const norm = normalizePeriod(raw);
                    return norm && norm.label === latestLabel;
                });
            }

            if (!latestRows.length) {
                worstCard.style.display = "none";
                if (nonCard) nonCard.style.display = "none";
                return;
            }

const trafficRows    = [];
const nonTrafficRows = [];

// check MAC SDU = 0
function isZeroMac(val) {
    if (val === null || val === undefined || val === "") return false;
    const num = parseFloat(String(val).replace(/\s+/g, "").replace(",", "."));
    return !Number.isNaN(num) && num === 0;
}

latestRows.forEach(row => {
    const avail = availCol ? row[availCol] : null;

    // 1Ô∏è‚É£ Cell avail = 0 -> Non-Traffic
    if (availCol && Number(avail) === 0) {
        nonTrafficRows.push(row);
        return;
    }

    // 2Ô∏è‚É£ 2 KPI MAC SDU DL/UL = 0 -> Non-Traffic
    let moveByMac = false;
    if (macDlCol || macUlCol) {
        const dlVal = macDlCol ? row[macDlCol] : null;
        const ulVal = macUlCol ? row[macUlCol] : null;

        if (macDlCol && macUlCol) {
            // c·∫£ DL & UL = 0
            if (isZeroMac(dlVal) && isZeroMac(ulVal)) moveByMac = true;
        } else if (macDlCol) {
            if (isZeroMac(dlVal)) moveByMac = true;
        } else if (macUlCol) {
            if (isZeroMac(ulVal)) moveByMac = true;
        }
    }

    if (moveByMac) {
        nonTrafficRows.push(row);
        return;
    }

    // 3Ô∏è‚É£ 5G Total Traffic Volume < 100 -> Non-Traffic
    if (traffic5gCol) {
        const trafficVal = toNumber(row[traffic5gCol]);
        if (trafficVal !== null && trafficVal < 100) {
            nonTrafficRows.push(row);
            return;
        }
    }

    const hasData = cleanColumns.some(col => {
        if (col === periodCol || col === nrbtsCol || col === nrCellCol || col === availCol) return false;
        const v = row[col];
        return v !== null && v !== "" && !Number.isNaN(parseFloat(v));
    });

    if (!hasData) nonTrafficRows.push(row);
    else trafficRows.push(row);
});

// Remove duplicate theo NRBTS + NRCEL
function deduplicateRows(rowsArr) {
    const seen = new Set();
    const result = [];
    rowsArr.forEach(row => {
        const key = makeRowKey(row); // ƒë√£ ƒë·ªãnh nghƒ©a ·ªü tr√™n
        if (!key) {
            result.push(row);
            return;
        }
        if (seen.has(key)) return;
        seen.add(key);
        result.push(row);
    });
    return result;
}

const trafficRowsDedup    = deduplicateRows(trafficRows);
const nonTrafficRowsDedup = deduplicateRows(nonTrafficRows);

function toNumber(val) {
    if (val === null || val === undefined) return null;
    const num = parseFloat(String(val).replace(/\s+/g, ""));
    return isNaN(num) ? null : num;
}

function buildTable(rowsArr, titleEl, tableEl, baseTitle) {
    if (!rowsArr.length) {
        titleEl.textContent = baseTitle + " (kh√¥ng c√≥ d·ªØ li·ªáu)";
        tableEl.innerHTML = "";
        return;
    }

    const otherCols = cleanColumns.filter(col => {
        const lower = String(col).toLowerCase();
        if (col === periodCol) return false;
        if (col === nrbtsCol) return false;
        if (col === nrCellCol) return false;
        if (col === availCol)  return false;
        if (lower.includes("mrbts")) return false;
        return true;
    });

    const orderedCols = ["__PO", "__province"];
    if (nrbtsCol)  orderedCols.push(nrbtsCol);
    if (nrCellCol) orderedCols.push(nrCellCol);
    if (availCol)  orderedCols.push(availCol);
    orderedCols.push(...otherCols);

    // üî• NEW: n·∫øu l√† b·∫£ng Worst Cell th√¨ apply filter gi√° tr·ªã
    let effectiveRows = rowsArr;
    if (baseTitle.startsWith("Worst Cell")) {
        initWorstFilterOptionsFromCols(orderedCols);
        effectiveRows = applyWorstCellValueFilters(rowsArr, orderedCols);

        if (!effectiveRows.length) {
            titleEl.textContent = baseTitle + " ‚Äì kh√¥ng c√≥ d√≤ng n√†o kh·ªõp filter";
            tableEl.innerHTML = "";
            return;
        }
    }

    const kpiAccessName    = "NSA call access";
    const kpiDropName      = "NSA Active ERAB drop UserR";
    const kpiAvailName     = "Cell avail R";
    const kpiSnChangeName  = "SN Init Change Intra-freq SR src gNB";

    function findColKeyByName(displayName) {
        const target = displayName.toLowerCase();
        return orderedCols.find(colKey =>
            colKey !== "__province" &&
            String(colKey).toLowerCase() === target
        );
    }

    const kpiAccessColKey   = findColKeyByName(kpiAccessName);
    const kpiDropColKey     = findColKeyByName(kpiDropName);
    const kpiAvailColKey    = findColKeyByName(kpiAvailName);
    const kpiSnChangeColKey = findColKeyByName(kpiSnChangeName);

    const sortedRows = [...effectiveRows].sort((a, b) => {
        const aCell = nrCellCol ? String(a[nrCellCol] ?? "") : "";
        const bCell = nrCellCol ? String(b[nrCellCol] ?? "") : "";
        const provA = aCell.slice(-3);
        const provB = bCell.slice(-3);
        return provA.localeCompare(provB);
    });

    let html = "<table><thead><tr>";
    orderedCols.forEach((colKey, idx) => {
        const isFirst4 = idx < 4;

        let title = colKey;
        if (colKey === "__PO")       title = "PO";
        if (colKey === "__province") title = "Province";

        const thStyle =
            "background:#203864; color:#fff; padding:6px 8px; " +
            "border:1px solid #cbd5e1; text-align:center;" +
            (isFirst4 ? "white-space:nowrap;" : "");
        html += `<th style="${thStyle}">${title}</th>`;
    });
    html += "</tr></thead><tbody>";

    sortedRows.forEach(row => {
        const rowKey = makeRowKey(row);
        const isHighlighted = highlightedKeys.has(rowKey);
        const trStyle = isHighlighted ? ' style="background:#fef3c7;"' : "";

        html += `<tr${trStyle}>`;

        orderedCols.forEach((colKey, idx) => {
            const isFirst4 = idx < 4;
            let value;

            if (colKey === "__province") {
                const cellVal = nrCellCol ? row[nrCellCol] : "";
                const str = cellVal == null ? "" : String(cellVal).trim();
                value = str.length >= 3 ? str.slice(-3) : str;
            } else if (colKey === "__PO") {
                const siteName = nrbtsCol ? row[nrbtsCol] : "";
                value = getPoFromProgress(siteName);
            } else {
                value = row[colKey];
            }

            let display = value == null ? "" : value;
            if (idx >= 4 && isNumericLike(display)) {
                display = formatNumberSmart(display);
            }

            let condStyle = "";

            // ∆Øu ti√™n d√πng file c·∫•u h√¨nh sheet "WorstCell Threshold" n·∫øu c√≥
            if (worstCellThresholdMap && Object.keys(worstCellThresholdMap).length) {
                let kpiDisplayName = colKey;
                if (colKey === "__PO")       kpiDisplayName = "PO";
                else if (colKey === "__province") kpiDisplayName = "Province";

                const thr = getWorstCellThresholdByName(kpiDisplayName);

                if (thr && isNumericLike(value)) {
                    const num = toNumber(value);
                    const t   = thr.value;
                    const op  = thr.op;
                    let isBad = false;

                    if (num !== null) {
                        if      (op === "<")  isBad = num <  t;
                        else if (op === ">")  isBad = num >  t;
                        else if (op === "<=") isBad = num <= t;
                        else if (op === ">=") isBad = num >= t;
                        else if (op === "=" || op === "==") isBad = num === t;
                    }

                    if (isBad) {
                        condStyle =
                            "background:#fee2e2; color:#b91c1c; font-weight:700;";
                    }
                }
            }

            // Style √¥ d·ªØ li·ªáu: gi·ªëng file chu·∫©n (n·ªÅn xanh nh·∫°t + ƒë·∫≠m 4 c·ªôt ƒë·∫ßu)
            const baseCell =
                "padding:6px 8px; border:1px solid #e5e7eb; text-align:center;";
            const extraCell = isFirst4
                ? " background:#d9e1f2; font-weight:600; white-space:nowrap; text-align:left;"
                : "";

            const finalStyle = baseCell + extraCell + condStyle;

            html += `<td style="${finalStyle}">${display}</td>`;
        });

        html += "</tr>";
    });

    html += "</tbody></table>";
    tableEl.innerHTML = `<div style="min-width:100%; overflow-x:auto;">${html}</div>`;
    titleEl.textContent = baseTitle;

    // Sau khi v·∫Ω xong ‚Üí c·ªë ƒë·ªãnh 4 c·ªôt ƒë·∫ßu cho Worst Cell & Cell Non-Traffic
    if (
        (baseTitle.startsWith("Worst Cell") ||
         baseTitle.startsWith("Cell Non-Traffic")) &&
        typeof applyWorstCellStickyColumns === "function"
    ) {
        setTimeout(applyWorstCellStickyColumns, 0);
    }
}


const worstTitleText = latestLabel ? `Worst Cell (${latestLabel})` : "Worst Cell";
worstCard.style.display = "block";
buildTable(trafficRowsDedup, worstTitleEl, worstTableEl, worstTitleText);

if (nonCard && nonTableEl && nonTitleEl) {
    if (nonTrafficRowsDedup.length) {
        nonCard.style.display = "block";
        const nonTitleText = "Cell Non-Traffic";
        buildTable(nonTrafficRowsDedup, nonTitleEl, nonTableEl, nonTitleText);
    } else {
        nonCard.style.display = "none";
    }
}

        }

function renderLatestKpiTable() {
    const tableCard = document.getElementById("latestTableCard");
    const tableDiv = document.getElementById("latestTable");
    const titleEl = document.getElementById("latestTableTitle");


    if (!tableCard || !tableDiv || !titleEl) return;
    if (!currentData || !currentData.length || !periodColumnName) {
        tableCard.style.display = "none";
        return;
    }

    // N·∫øu ch∆∞a load KPI Threshhold th√¨ trigger load & render l·∫°i sau khi xong
    if (kpiThresholdMap === null) {
        ensureKpiThresholdsLoaded().then(() => {
            if (tableCard && tableCard.style.display !== "none") {
                renderLatestKpiTable();
            }
        });
    }

    const latestLabel = getLatestPeriodLabel(currentData);
    if (!latestLabel) {
        tableCard.style.display = "none";
        return;
    }

    const activeKpiCols = numericColumns.filter((col) =>
        selectedKpiColumns.has(col)
    );

    if (!activeKpiCols.length) {
        titleEl.textContent = `B·∫£ng KPI th·ªùi ƒëi·ªÉm g·∫ßn nh·∫•t (${latestLabel}) ‚Äì kh√¥ng c√≥ KPI n√†o ƒë∆∞·ª£c ch·ªçn`;
        tableDiv.innerHTML = "";
        tableCard.style.display = "block";
        return;
    }

    const periodCol = periodColumnName;
    const wsNameCol = getCellNameColumn(); // üëâ B·∫£ng ‚ÄúKPI th·ªùi ƒëi·ªÉm g·∫ßn nh·∫•t‚Äù c≈©ng theo CELL_NAME

    const byWs = {};

    currentData.forEach((row) => {
        const wsName = row[wsNameCol];
        const rawPeriod = row[periodCol];
        if (!wsName || rawPeriod === undefined || rawPeriod === null) return;

        const norm = normalizePeriod(rawPeriod);
        if (!norm || norm.label !== latestLabel) return;

        const wsStr = String(wsName);
        const wsLower = wsStr.toLowerCase();

        if (!wsPassesTextFilters(wsLower)) return;
        if (wsFilterValues && wsFilterValues.size > 0 && !wsFilterValues.has(wsStr))
            return;

        if (!byWs[wsStr]) byWs[wsStr] = {};

        activeKpiCols.forEach((col) => {
            const v = row[col];
            const num = parseFloat(v);
            if (!isNaN(num)) {
                const scale = getKpiScaleForColumn(col);
                byWs[wsStr][col] = num * scale;
            }
        });
    });

    const wsList = Object.keys(byWs).sort();
    if (wsList.length === 0) {
        titleEl.textContent = `B·∫£ng KPI th·ªùi ƒëi·ªÉm g·∫ßn nh·∫•t (${latestLabel}) ‚Äì kh√¥ng c√≥ d·ªØ li·ªáu kh·ªõp b·ªô l·ªçc`;
        tableDiv.innerHTML = "";
        tableCard.style.display = "block";
        return;
    }

      titleEl.textContent = `B·∫£ng KPI th·ªùi ƒëi·ªÉm g·∫ßn nh·∫•t (${latestLabel})`;

    // T·∫°o b·∫£ng v√† b·ªçc trong wrapper ƒë·ªÉ c√≥ scroll d·ªçc + c·ªë ƒë·ªãnh header/c·ªôt 1
    let html = '<table id="latestKpiTable"><thead><tr>';
    html +=
        '<th style="background:#1f2937; color:#fff; padding:6px 8px; border:1px solid #e5e7eb;">Name</th>';
    activeKpiCols.forEach((col) => {
        html += `<th style="background:#4b5563; color:#fff; padding:6px 8px; border:1px solid #e5e7eb;">${col}</th>`;
    });
    html += "</tr></thead><tbody>";

    wsList.forEach((ws) => {
        html += `<tr><td style="padding:6px 8px; border:1px solid #e5e7eb; background:#f9fafb; font-weight:600; white-space:nowrap;">${ws}</td>`;
        activeKpiCols.forEach((col) => {
            const v = byWs[ws][col];
            let display = "";
            if (typeof v === "number" && !isNaN(v)) {
                display = Math.round(v * 1000) / 1000;
            }

            // ==== √Åp d·ª•ng ng∆∞·ª°ng t·ª´ KPI Threshhold ====
            let condStyle = "";
            if (typeof v === "number" && !isNaN(v) && kpiThresholdMap) {
                const thr = getThresholdForKpiColumn(col);
                if (thr) {
                    const num = v;
                    const t = thr.value;
                    const op = thr.op;
                    let isBad = false;

                    if (op === "<") {
                        isBad = num < t;
                    } else if (op === ">") {
                        isBad = num > t;
                    } else if (op === "<=") {
                        isBad = num <= t;
                    } else if (op === ">=") {
                        isBad = num >= t;
                    } else if (op === "=" || op === "==") {
                        isBad = num === t;
                    }

                    // N·∫øu vi ph·∫°m ƒëi·ªÅu ki·ªán ‚áí t√¥ ƒë·ªè
                    if (isBad) {
                        condStyle =
                            "background:#fee2e2; color:#b91c1c; font-weight:700;";
                    }
                }
            }

            const baseStyle =
                "padding:6px 8px; border:1px solid #e5e7eb; text-align:center;";
            html += `<td style="${baseStyle}${condStyle}">${display}</td>`;
        });
        html += "</tr>";
    });

    html += "</tbody></table>";
    tableDiv.innerHTML = `<div id="latestTableWrapper">${html}</div>`;
    tableCard.style.display = "block";
}


        async function handleEmailSubmit(e) {
            e.preventDefault();

            const to = document.getElementById("emailTo").value.trim();
            const subject = document
                .getElementById("emailSubject")
                .value.trim();
            const message = document
                .getElementById("emailMessage")
                .value.trim();
            const statusEl = document.getElementById("emailStatus");
            const submitBtn = e.target.querySelector(
                'button[type="submit"]'
            );

            statusEl.textContent = "‚è≥ ƒêang g·ª≠i email...";
            statusEl.className = "email-status";
            submitBtn.disabled = true;

            try {
                const res = await fetch("/api/send-mail", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ to, subject, message }),
                });

                const data = await res.json();
                if (!res.ok) {
                    throw new Error(data.error || "G·ª≠i mail th·∫•t b·∫°i");
                }

                statusEl.textContent = "‚úÖ G·ª≠i email th√†nh c√¥ng!";
                statusEl.className = "email-status success";
            } catch (err) {
                statusEl.textContent = "‚ùå L·ªói: " + err.message;
                statusEl.className = "email-status error";
            } finally {
                submitBtn.disabled = false;
            }
        }

        const emailForm = document.getElementById("emailForm");
        if (emailForm) {
            emailForm.addEventListener("submit", handleEmailSubmit);
        }
        const exportEmlChartsBtn = document.getElementById("exportEmlChartsBtn");
        
        if (exportEmlChartsBtn) {
            exportEmlChartsBtn.addEventListener(
                "click",
                handleExportEmlWithCharts
            );
        }

                // ====== DEFAULT SUBJECT & EMAIL LIST ======
        const DEFAULT_EMAIL_SUBJECT =
            "[NET_ ____] B√°o c√°o KPI D/a NSN ___ khu v·ª±c Mi·ªÅn Nam";

        const DEFAULT_EMAIL_TO = "huylt@vnpt-technology.vn";

        // G√°n default cho Danh s√°ch email n·∫øu ƒëang tr·ªëng
        const emailToEl = document.getElementById("emailTo");
        if (emailToEl && !emailToEl.value.trim()) {
            emailToEl.value = DEFAULT_EMAIL_TO;
        }

        // G√°n default cho Ti√™u ƒë·ªÅ email n·∫øu ƒëang tr·ªëng
        const emailSubjectEl = document.getElementById("emailSubject");
        if (emailSubjectEl && !emailSubjectEl.value.trim()) {
            emailSubjectEl.value = DEFAULT_EMAIL_SUBJECT;
        }

        // ƒê√°nh d·∫•u khi user t·ª± ch·ªânh s·ª≠a n·ªôi dung m·ªü ƒë·∫ßu email
        const emailMessageEl = document.getElementById("emailMessage");
        if (emailMessageEl) {
            emailMessageEl.addEventListener("input", () => {
                emailIntroTouched = true;
            });
        }


// T·ª± ƒë·ªông fill n·ªôi dung email: ch·ªâ load template (c√≥ placeholder), KH√îNG thay b·∫±ng s·ªë li·ªáu
function fillDefaultEmailText() {
    const textarea = document.getElementById("emailMessage");
    if (!textarea) return;

    // N·∫øu user ƒë√£ g√µ s·ª≠a trong phi√™n n√†y th√¨ kh√¥ng ƒë√® n·ªØa
    if (emailIntroTouched) return;

    // 1. L·∫•y template t·ª´ localStorage (n·∫øu c√≥)
    let template = "";
    try {
        const saved = localStorage.getItem("emailConfig");
        if (saved) {
            const cfg = JSON.parse(saved);
            template = (cfg && cfg.message) || "";
        }
    } catch (e) {
        template = "";
    }

    // 2. N·∫øu ch∆∞a c√≥ g√¨ l∆∞u th√¨ d√πng template m·∫∑c ƒë·ªãnh C√ì placeholder
    if (!template.trim()) {
        template = [
            "K√≠nh g·ª≠i c√°c Anh/Ch·ªã,",
            "",
            "- Nokia/VNPT Technology b√°o c√°o KPI cho c√°c tr·∫°m d·ª± √°n 5G Phase 02 (POx) khu v·ª±c Mi·ªÅn Nam (c·∫≠p nh·∫≠t ƒë·∫øn h·∫øt ng√†y (ng√†y g·∫ßn nh·∫•t)).",
            "- (POx) ƒë√£ ho√†n th√†nh ph√°t s√≥ng ƒë∆∞·ª£c (S·ªë tr·∫°m onair)/(T·ªïng s·ªë tr·∫°m POx) tr·∫°m.",
            "- K·∫ø ho·∫°ch ti·∫øp theo: X·ª≠ l√Ω KPI k√©m, duy tr√¨ ·ªïn ƒë·ªãnh v√† c·∫£i thi·ªán KPI."
        ].join("\n");
    }

    // 3. Ch·ªâ set template v√†o textbox, gi·ªØ nguy√™n placeholder
    textarea.value = template;
}

// ==== √ÅP C·∫§U H√åNH BI·ªÇU ƒê·ªí T·ª™ L·∫¶N TR∆Ø·ªöC ====

// ƒê·ªçc config (n·∫øu c√≥) m·ªôt l·∫ßn
let savedChartConfig = null;
try {
    const rawCfg = localStorage.getItem("chartConfig");
    savedChartConfig = rawCfg ? JSON.parse(rawCfg) : null;
} catch (e) {
    savedChartConfig = null;
}

const chartsPerRowSelect = document.getElementById("chartsPerRowSelect");
if (chartsPerRowSelect) {
    // set theo config c≈© n·∫øu c√≥
    if (savedChartConfig && savedChartConfig.chartsPerRow) {
        chartsPerRowSelect.value = savedChartConfig.chartsPerRow;
    }

    chartsPerRowSelect.addEventListener("change", () => {
        applyChartsPerRow();
        saveChartConfig();
    });

    // √°p layout ngay
    applyChartsPerRow();
}

const daysWindowSelect = document.getElementById("daysWindowSelect");
if (daysWindowSelect) {
    function applyDaysWindowFromSelect() {
        const raw = daysWindowSelect.value;

        if (raw === "ALL") {
            // To√†n b·ªô: kh√¥ng c·∫Øt b·ªõt labels theo s·ªë ng√†y
            chartDaysWindow = null;
        } else {
            const v = parseInt(raw, 10);
            chartDaysWindow = isNaN(v) ? 14 : v; // fallback 14 ng√†y n·∫øu l·ªói
        }

        renderCharts();
        saveChartConfig();
    }

    // set theo config c≈© n·∫øu c√≥
    if (savedChartConfig && savedChartConfig.daysWindow) {
        daysWindowSelect.value = savedChartConfig.daysWindow;
    }

    // √°p l·∫ßn ƒë·∫ßu
    applyDaysWindowFromSelect();

    // c·∫≠p nh·∫≠t khi user ƒë·ªïi combobox
    daysWindowSelect.addEventListener("change", applyDaysWindowFromSelect);
}

window.addEventListener("resize", () => {
    applyStickyKpiColumns();
    if (typeof applyWorstCellStickyColumns === "function") {
        applyWorstCellStickyColumns();
    }
});

const funnelSortSelect = document.getElementById("funnelSortSelect");
if (funnelSortSelect) {
    // set theo config c≈© n·∫øu c√≥
    if (savedChartConfig && savedChartConfig.funnelSort) {
        funnelSortSelect.value = savedChartConfig.funnelSort;
        funnelSortOrder = savedChartConfig.funnelSort || "desc";
    }

    funnelSortSelect.addEventListener("change", function () {
        funnelSortOrder = this.value || "desc";   // "asc" ho·∫∑c "desc"
        renderCharts();                           // v·∫Ω l·∫°i t·∫•t c·∫£ chart
        saveChartConfig();
    });
}

        // ====== T·∫†O FILE OUTLOOK (.MSG) T·ª™ C√ÅC SECTION ƒêANG CH·ªåN ======

        function escapeHtml(str) {
            return String(str || "").replace(/[&<>"']/g, function (ch) {
                switch (ch) {
                    case "&":
                        return "&amp;";
                    case "<":
                        return "&lt;";
                    case ">":
                        return "&gt;";
                    case '"':
                        return "&quot;";
                    case "'":
                        return "&#39;";
                    default:
                        return ch;
                }
            });
        }

        function getSelectedEmailSectionsHtml() {
            const checkboxes = document.querySelectorAll(".email-section-checkbox:checked");
            if (!checkboxes.length) return "";

            const parts = [];

            checkboxes.forEach((cb) => {
                const key = cb.value;
                let el = null;

                if (key === "excel") {
                    el = document.getElementById("excelTableCard");
                } else if (key === "charts") {
                    el = document.getElementById("chartsContainer");
                } else if (key === "worst") {
                    el = document.getElementById("worstCellCard");
                } else if (key === "nonTraffic") {
                    el = document.getElementById("nonTrafficCard");
                } else if (key === "latest") {
                    el = document.getElementById("latestTableCard");
                }

                if (el) {
                    const style = window.getComputedStyle(el);
                    if (style.display !== "none") {
                        parts.push(el.outerHTML);
                    }
                }
            });

            if (!parts.length) return "";

            return parts.join(
                '\n<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />\n'
            );
        }

        function exportOutlookMsg() {
            const statusEl = document.getElementById("emailStatus");
            if (statusEl) {
                statusEl.textContent = "";
                statusEl.className = "email-status";
            }

            const toInput = document.getElementById("emailTo");
            const subjectInput = document.getElementById("emailSubject");
            const messageInput = document.getElementById("emailMessage");

            const to = (toInput?.value || "").replace(/\r?\n/g, " ").trim();
            let subject = (subjectInput?.value || "").replace(/\r?\n/g, " ").trim();
            if (!subject) subject = "KPI Report";

            const messageText = messageInput?.value || "";
            const messageHtml = escapeHtml(messageText).replace(/\r?\n/g, "<br>");

            const sectionsHtml = getSelectedEmailSectionsHtml();

            const bodyHtml =
                "<!DOCTYPE html>" +
                '<html><head><meta charset="UTF-8"></head><body ' +
                'style="font-family:-apple-system,BlinkMacSystemFont,\'Segoe UI\',Roboto,sans-serif;font-size:13px;color:#111827;">' +
                "<p>" +
                messageHtml +
                "</p>" +
                (sectionsHtml
                    ? '\n<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />\n' +
                      sectionsHtml
                    : "") +
                "</body></html>";

            // EML/MSG ƒë∆°n gi·∫£n theo chu·∫©n RFC822 ‚Äì Outlook v·∫´n m·ªü ƒë∆∞·ª£c
            const headerLines = [];
            if (to) {
                headerLines.push("To: " + to);
            }
            headerLines.push("Subject: " + subject);
            headerLines.push("MIME-Version: 1.0");
            headerLines.push('Content-Type: text/html; charset="UTF-8"');

            const emlContent = headerLines.join("\r\n") + "\r\n\r\n" + bodyHtml;

            const blob = new Blob([emlContent], { type: "message/rfc822" });

            const safeFileName =
                (subject || "kpi_report").replace(/[^a-zA-Z0-9-_]+/g, "_").slice(0, 80) ||
                "kpi_report";

            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = safeFileName + ".eml"; // d√πng ƒëu√¥i .msg ƒë·ªÉ m·ªü th·∫≥ng b·∫±ng Outlook
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            setTimeout(() => URL.revokeObjectURL(url), 5000);

            if (statusEl) {
                statusEl.textContent =
                    "‚úÖ ƒê√£ t·∫°o file Outlook (.msg). H√£y m·ªü file n√†y b·∫±ng Outlook ƒë·ªÉ g·ª≠i.";
                statusEl.classList.add("success");
            }
        }

        // G·∫Øn event cho n√∫t xu·∫•t .msg sau khi DOM s·∫µn s√†ng
        window.addEventListener("DOMContentLoaded", () => {
            const exportBtn = document.getElementById("exportMsgBtn");
            if (exportBtn) {
                exportBtn.addEventListener("click", exportOutlookMsg);
            }
        });

        function base64ToUint8Array(base64) {
            const raw = atob(base64);
            const arr = new Uint8Array(raw.length);
            for (let i = 0; i < raw.length; i++) arr[i] = raw.charCodeAt(i);
            return arr;
        }

        // ==== L·∫§Y TO√ÄN B·ªò CHART (CANVAS) ‚Üí PNG (BASE64) + TI√äU ƒê·ªÄ ====

        function buildEmlWithCharts(subject, messageHtml, charts) {
            const boundary = "BOUNDARY_" + Date.now();

            let eml = "";
            eml += "Subject: " + subject + "\r\n";
            eml += "MIME-Version: 1.0\r\n";
            eml += `Content-Type: multipart/related; boundary="${boundary}"\r\n\r\n`;

            // PH·∫¶N 1 ‚Äì HTML
            eml += `--${boundary}\r\n`;
            eml += "Content-Type: text/html; charset=UTF-8\r\n\r\n";

            // HTML body c√≥ nh√∫ng chart
            let html = "<html><body>";
            html += messageHtml + "<br><br>";

            charts.forEach((c) => {
                html += `<div><img src="cid:${c.id}" style="max-width:100%;"></div><br>`;
            });

            html += "</body></html>";

            eml += html + "\r\n\r\n";

            // PH·∫¶N 2 ‚Äì Embedded images
            charts.forEach((c) => {
                const imgBytes = base64ToUint8Array(c.base64);

                eml += `--${boundary}\r\n`;
                eml += "Content-Type: image/png\r\n";
                eml += `Content-Transfer-Encoding: base64\r\n`;
                eml += `Content-ID: <${c.id}>\r\n\r\n`;
                eml += c.base64 + "\r\n\r\n";
            });

            eml += `--${boundary}--`;

            return eml;
        }

        function exportEmailWithCharts() {
            const subject = document.getElementById("emailSubject").value || "KPI Report";
            const messageHtml = document.getElementById("emailMessage").value.replace(/\n/g, "<br>");

            const charts = getAllChartPNGs();
            console.log("Charts exported:", charts);

            const emlContent = buildEmlWithCharts(subject, messageHtml, charts);

            const blob = new Blob([emlContent], { type: "message/rfc822" });
            const url = URL.createObjectURL(blob);

            const a = document.createElement("a");
            a.href = url;
            a.download = subject.replace(/[^a-zA-Z0-9_-]/g, "_") + ".eml";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            setTimeout(() => URL.revokeObjectURL(url), 2000);
        }

        // ==== H·ªñ TR·ª¢ ESCAPE HTML ƒê∆†N GI·∫¢N ====
        function escapeHtml(str) {
            return String(str || "").replace(/[&<>"']/g, function (ch) {
                switch (ch) {
                    case "&": return "&amp;";
                    case "<": return "&lt;";
                    case ">": return "&gt;";
                    case '"': return "&quot;";
                    case "'": return "&#39;";
                    default: return ch;
                }
            });
        }

        // ==== SNAPSHOT CHART NGUY√äN CARD (HTML ‚Üí PNG) ====
        // ==== SNAPSHOT CHART NGUY√äN CARD (HTML ‚Üí PNG, C√ì S·∫¥N BORDER TRONG ·∫¢NH) ====
        async function getAllChartPNGs() {
            const cards = document.querySelectorAll("#chartsContainer .chart-card");
            const results = [];
            let idx = 0;

            for (const card of cards) {
                const canvas = card.querySelector("canvas");
                if (!canvas) continue;

                // 1) L·∫•y c√°c ph·∫ßn s·∫Ω t·∫°m ·∫©n / t·∫°m ƒë·ªïi style
                const headerRow = card.querySelector(".chart-header-row");
                const typeWrapper = card.querySelector(".chart-type-select")
                    ? card.querySelector(".chart-type-select").closest("div")
                    : null;

                const prevHeaderVis = headerRow ? headerRow.style.visibility : "";
                const prevTypeVis   = typeWrapper ? typeWrapper.style.visibility : "";
                const prevShadow    = card.style.boxShadow;
                const prevOverflow  = card.style.overflow;
                const prevBg        = card.style.backgroundColor;
                const prevBorder    = card.style.border;
                const prevRadius    = card.style.borderRadius;

                // 2) ·∫®n ‚ÄúKi·ªÉu chart‚Äù (dropdown)
                if (typeWrapper) typeWrapper.style.visibility = "hidden";
                // n·∫øu mu·ªën ·∫©n lu√¥n c·∫£ h√†ng header th√¨ m·ªü d√≤ng b√™n d∆∞·ªõi:
                // if (headerRow) headerRow.style.visibility = "hidden";

                // 3) T·∫Øt b√≥ng, n·ªÅn x√°m; set n·ªÅn tr·∫Øng + TH√äM BORDER 2PX ƒêEN
                card.style.boxShadow = "none";
                card.style.overflow = "visible";
                card.style.backgroundColor = "#ffffff";
                card.style.border = "2px solid #000000";      // <<< border s·∫Ω n·∫±m TRONG ·∫£nh
                card.style.borderRadius = "12px";

                // 4) Ch·ª•p card
                const snap = await html2canvas(card, {
                    scale: 1,                 // ho·∫∑c 1.2 n·∫øu mu·ªën n√©t h∆°n
                    backgroundColor: "#ffffff"
                });

                const dataUrl = snap.toDataURL("image/png");
                const base64  = dataUrl.split(",")[1];

                // 5) Kh√¥i ph·ª•c l·∫°i style
                if (typeWrapper) typeWrapper.style.visibility = prevTypeVis;
                if (headerRow)   headerRow.style.visibility   = prevHeaderVis;
                card.style.boxShadow       = prevShadow;
                card.style.overflow        = prevOverflow;
                card.style.backgroundColor = prevBg;
                card.style.border          = prevBorder;
                card.style.borderRadius    = prevRadius;

                const h3 = card.querySelector("h3");
                const title = h3 ? h3.textContent.trim() : "Chart " + (idx + 1);

                results.push({
                    cid: "chart" + idx,
                    base64,
                    title
                });

                idx++;
            }

            return results;
        }

        // ==== BUILD N·ªòI DUNG EML D·∫†NG multipart/related C√ì INLINE IMAGE ====
        function buildEmlWithCharts(to, subject, bodyHtml, charts) {
            const boundary = "BOUNDARY_" + Date.now();

            let eml = "";
            if (to) {
                eml += "To: " + to + "\r\n";
            }
            eml += "Subject: " + subject + "\r\n";
            eml += "MIME-Version: 1.0\r\n";
            eml += `Content-Type: multipart/related; boundary="${boundary}"\r\n\r\n`;

            // PH·∫¶N 1 ‚Äì HTML ch√≠nh
            eml += `--${boundary}\r\n`;
            eml += 'Content-Type: text/html; charset="UTF-8"\r\n\r\n';
            eml += bodyHtml + "\r\n\r\n";

            // PH·∫¶N 2 ‚Äì C√°c ·∫£nh PNG ƒë∆∞·ª£c encode base64
            charts.forEach((c) => {
                eml += `--${boundary}\r\n`;
                eml += "Content-Type: image/png\r\n";
                eml += "Content-Transfer-Encoding: base64\r\n";
                eml += `Content-ID: <${c.cid}>\r\n\r\n`;
                eml += c.base64 + "\r\n\r\n";
            });

            eml += `--${boundary}--`;

            return eml;
        }

function getSectionHtmlByKey(key) {
    let el = null;

    if (key === "excel") {
        el = document.getElementById("excelTableCard");
    } else if (key === "progress") {
        // card Ti·∫øn ƒë·ªô ƒëo ki·ªÉm ·ªü tr√™n c√πng
        el = document.getElementById("progressCard");
    } else if (key === "worst") {
        el = document.getElementById("worstCellCard");
    } else if (key === "nonTraffic") {
        el = document.getElementById("nonTrafficCard");
    } else if (key === "latest") {
        el = document.getElementById("latestTableCard");
    }

    if (el) {
        const style = window.getComputedStyle(el);
        if (style.display !== "none") {
            return el.outerHTML;
        }
    }
    return "";
}


async function captureSectionCardAsPng(key) {
    let target = null;
    let titleText = "";

    if (key === "excel") {
        // ‚úÖ CH·ªà CH·ª§P CH√çNH X√ÅC TH·∫∫ <table> B√äN TRONG KPI OVERVIEW
        const wrapper = document.getElementById("excelTable");
        const tableEl = wrapper ? wrapper.querySelector("table") : null;

        // n·∫øu c√≥ table th√¨ ch·ª•p table, kh√¥ng th√¨ fallback v·ªÅ wrapper
        target = tableEl || wrapper;

        const t = document.getElementById("excelTableTitle");
        titleText = t ? t.textContent.trim() : "KPI Overview";

    } else if (key === "progress") {
        // ‚úÖ CH·ªà CH·ª§P TABLE TI·∫æN ƒê·ªò ƒêO KI·ªÇM ‚Üí BORDER √îM S√ÅT B·∫¢NG
        const wrapper = document.getElementById("progressTable");
        const tableEl = wrapper ? wrapper.querySelector("table") : null;

        // n·∫øu c√≥ table th√¨ ch·ª•p table, kh√¥ng th√¨ fallback v·ªÅ wrapper
        target = tableEl || wrapper;

        const t = document.querySelector("#progressCard h3");
        titleText = t ? t.textContent.trim() : "Ti·∫øn ƒê·ªô ƒêo Ki·ªÉm";

    } else if (key === "worst") {
        target = document.getElementById("worstCellTable");
        const t = document.getElementById("worstCellTitle");
        titleText = t ? t.textContent.trim() : "Worst Cell";

    } else if (key === "nonTraffic") {
        target = document.getElementById("nonTrafficTable");
        const t = document.getElementById("nonTrafficTitle");
        titleText = t ? t.textContent.trim() : "Cell Non-Traffic";

    } else if (key === "latest") {
        target = document.getElementById("latestTable");
        const t = document.getElementById("latestTableTitle");
        titleText = t ? t.textContent.trim() : "KPI th·ªùi ƒëi·ªÉm g·∫ßn nh·∫•t";
    }

    if (!target) return null;

    // N·∫øu b·∫£ng ch∆∞a render / kh√¥ng c√≥ k√≠ch th∆∞·ªõc th√¨ b·ªè qua
    if (!target.offsetWidth || !target.offsetHeight) {
        return null;
    }

    // L∆∞u style c≈©
    const prevBorder   = target.style.border;
    const prevBg       = target.style.backgroundColor;
    const prevRadius   = target.style.borderRadius;
    const prevShadow   = target.style.boxShadow;
    const prevOverflow = target.style.overflow;

    // ‚úÖ Border + n·ªÅn tr·∫Øng ngay tr√™n ch√≠nh c√°i TABLE ‚Üí PNG √¥m ƒë√∫ng b·∫£ng
    target.style.border          = "2px solid #000000";
    target.style.backgroundColor = "#ffffff";
    target.style.borderRadius    = "12px";
    target.style.boxShadow       = "none";
    target.style.overflow        = "hidden";

    const canvas = await html2canvas(target, {
        scale: 1,
        backgroundColor: "#ffffff",
    });

    // Kh√¥i ph·ª•c style c≈©
    target.style.border          = prevBorder;
    target.style.backgroundColor = prevBg;
    target.style.borderRadius    = prevRadius;
    target.style.boxShadow       = prevShadow;
    target.style.overflow        = prevOverflow;

    const dataUrl = canvas.toDataURL("image/png");
    const base64  = dataUrl.split(",")[1];
    const cid     = "tbl_" + key;

    return {
        cid,
        base64,
        title: titleText || key,
    };
}

        function buildEmailIntroBlock(messageHtml) {
            // B√¢y gi·ªù kh√¥ng t·ª± ch√®n m·∫´u n·ªØa,
            // m√† d√πng ƒë√∫ng n·ªôi dung ƒë√£ g√µ trong textbox (ƒë√£ escape + <br>)
            return messageHtml || "";
        }

        // ==== X·ª¨ L√ù KHI B·∫§M N√öT "Xu·∫•t Outlook (.eml) k√®m chart" ====

// cho c·∫£ TI√äU ƒê·ªÄ v√† N·ªòI DUNG, nh∆∞ng KH√îNG thay trong textbox.
async function handleExportEmlWithCharts() {
    const statusEl = document.getElementById("emailStatus");
    if (statusEl) {
        statusEl.textContent = "";
        statusEl.className = "email-status";
    }

    const to = (document.getElementById("emailTo")?.value || "").trim();

    // Ti√™u ƒë·ªÅ g·ªëc (c√≥ th·ªÉ ch·ª©a placeholder)
    const subjectRaw =
        (document.getElementById("emailSubject")?.value || "").trim() ||
        "KPI Report";

    // ==== 1. L·∫•y template g·ªëc trong textbox (v·∫´n c√≤n placeholder) ====
    const messageRaw = document.getElementById("emailMessage")?.value || "";

    // ==== 2. T√≠nh gi√° tr·ªã ƒë·ªông cho placeholder ====
    let latestStr = "";
    let latestDateObj = null;
    if (typeof getLatestDateFromCurrentData === "function") {
        latestDateObj = getLatestDateFromCurrentData();
        if (latestDateObj) {
            latestStr = formatDateDDMMYYYY(latestDateObj);
        }
    }

    const poFilterEl = document.getElementById("progressPOFilter");
    const selectedPo = poFilterEl ? poFilterEl.value : "ALL";

    let label = "";
    let total = 0;
    let onair = 0;

    if (Array.isArray(progressFullData) && progressFullData.length) {
        if (!selectedPo || selectedPo === "ALL") {
            // T·∫•t c·∫£ PO
            label = "D·ª± √°n";
            progressFullData.forEach((g) => {
                total += g.total || 0;
                onair += g.onair || 0;
            });
        } else {
            // 1 PO c·ª• th·ªÉ
            const filtered = progressFullData.filter((g) => g.po === selectedPo);
            if (filtered.length) {
                label = selectedPo;
                filtered.forEach((g) => {
                    total += g.total || 0;
                    onair += g.onair || 0;
                });
            }
        }
    }

    const finalDate  = latestStr || "(ng√†y g·∫ßn nh·∫•t)";
    const finalLabel = (label || selectedPo || "").trim() || "(POx)";
    const finalOnair = total > 0 ? String(onair) : "(S·ªë tr·∫°m onair)";
    const finalTotal = total > 0 ? String(total) : "(T·ªïng s·ªë tr·∫°m POx)";

    // ==== 3a. Thay placeholder cho TI√äU ƒê·ªÄ (ch·ªâ khi xu·∫•t .eml) ====
    let subjectProcessed = subjectRaw
        .replace(/\(ng√†y g·∫ßn nh·∫•t\)/g, finalDate)
        .replace(/\(POx\)/g, finalLabel)
        .replace(/\(S·ªë tr·∫°m onair\)/g, finalOnair)
        .replace(/\(T·ªïng s·ªë tr·∫°m POx\)/g, finalTotal);

    // ==== 3b. Thay placeholder CHO N·ªòI DUNG S·∫º ƒê∆ØA V√ÄO EML ====
    let messageProcessed = messageRaw || "";
    messageProcessed = messageProcessed
        .replace(/\(ng√†y g·∫ßn nh·∫•t\)/g, finalDate)
        .replace(/\(POx\)/g, finalLabel)
        .replace(/\(S·ªë tr·∫°m onair\)/g, finalOnair)
        .replace(/\(T·ªïng s·ªë tr·∫°m POx\)/g, finalTotal);

    // Convert sang HTML (textbox v·∫´n gi·ªØ template g·ªëc)
    const messageHtml = escapeHtml(messageProcessed).replace(/\r?\n/g, "<br>");

    // ==== 4. X·ª≠ l√Ω ph·∫ßn section/b·∫£ng/chart gi·ªØ nguy√™n nh∆∞ c≈© ====
    const checked = new Set(
        Array.from(
            document.querySelectorAll(".email-section-checkbox:checked")
        ).map((cb) => cb.value)
    );

    const includeCharts = checked.has("charts");
    const tablesAsImages =
        document.getElementById("emailTablesAsImages")?.checked || false;

    let charts = [];
    if (includeCharts) {
        charts = await getAllChartPNGs();
        if (!charts.length && statusEl) {
            statusEl.textContent = "‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y chart n√†o ƒë·ªÉ xu·∫•t.";
            statusEl.classList.add("error");
        }
    }

    let allImages = [...charts];

    let bodyHtml =
        '<!DOCTYPE html><html><head><meta charset="UTF-8"></head>' +
        '<body style="font-family:-apple-system,BlinkMacSystemFont,\'Segoe UI\',Roboto,sans-serif;font-size:13px;color:#111827;">';

    // ph·∫ßn m·ªü ƒë·∫ßu email
    bodyHtml += "<p>" + messageHtml + "</p>";

    // 2. Ti·∫øn ƒë·ªô ƒëo ki·ªÉm
    if (checked.has("progress")) {
        if (tablesAsImages) {
            const img = await captureSectionCardAsPng("progress");
            if (img) {
                allImages.push(img);
                const titleSafe = escapeHtml(img.title || "Ti·∫øn ƒê·ªô ƒêo Ki·ªÉm");
                bodyHtml +=
                    '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                    `<h3 style="margin:0 0 8px 0;">${titleSafe}</h3>` +
                    `<div><img src="cid:${img.cid}" style="max-width:100%;height:auto;"></div>`;
            }
        } else {
            const htmlProgress = getSectionHtmlByKey("progress");
            if (htmlProgress) {
                bodyHtml +=
                    '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                    htmlProgress;
            }
        }
    }

    // 1. KPI Overview
    if (checked.has("excel")) {
        if (tablesAsImages) {
            const img = await captureSectionCardAsPng("excel");
            if (img) {
                allImages.push(img);
                const titleSafe = escapeHtml(img.title || "KPI Overview");
                bodyHtml +=
                    '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                    `<h3 style="margin:0 0 8px 0;">${titleSafe}</h3>` +
                    `<div><img src="cid:${img.cid}" style="max-width:100%;height:auto;"></div>`;
            }
        } else {
            const htmlExcel = getSectionHtmlByKey("excel");
            if (htmlExcel) {
                bodyHtml +=
                    '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                    htmlExcel;
            }
        }
    }

    // 2. Bi·ªÉu ƒë·ªì KPI
    if (includeCharts && charts.length) {
        bodyHtml +=
            '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
            '<h3 style="margin:0 0 8px 0;">Bi·ªÉu ƒë·ªì KPI</h3>';

        bodyHtml += '<div style="text-align:left;">';

        charts.forEach((c, idx) => {
            if (idx % 2 === 0) {
                bodyHtml +=
                    '<div style="white-space:nowrap; margin-bottom:10px;">';
            }

            bodyHtml += `
                <img src="cid:${c.cid}"
                    style="
                        display:inline-block;
                        vertical-align:top;
                        width:520px;
                        height:auto;
                    ">
            `;

            if (idx % 2 === 0 && idx + 1 < charts.length) {
                bodyHtml += "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
            }

            if (idx % 2 === 1 || idx === charts.length - 1) {
                bodyHtml += "</div>";
            }
        });

        bodyHtml += "</div>";
    }

    // 3. Worst Cell
    if (checked.has("worst")) {
        if (tablesAsImages) {
            const img = await captureSectionCardAsPng("worst");
            if (img) {
                allImages.push(img);
                const titleSafe = escapeHtml(img.title || "Worst Cell");
                bodyHtml +=
                    '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                    `<h3 style="margin:0 0 8px 0;">${titleSafe}</h3>` +
                    `<div><img src="cid:${img.cid}" style="max-width:100%;height:auto;"></div>`;
            }
        } else {
            const htmlWorst = getSectionHtmlByKey("worst");
            if (htmlWorst) {
                bodyHtml +=
                    '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                    htmlWorst;
            }
        }
    }

    // 4. Cell Non-Traffic
    if (checked.has("nonTraffic")) {
        if (tablesAsImages) {
            const img = await captureSectionCardAsPng("nonTraffic");
            if (img) {
                allImages.push(img);
                const titleSafe = escapeHtml(img.title || "Cell Non-Traffic");
                bodyHtml +=
                    '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                    `<h3 style="margin:0 0 8px 0;">${titleSafe}</h3>` +
                    `<div><img src="cid:${img.cid}" style="max-width:100%;height:auto;"></div>`;
            }
        } else {
            const htmlNon = getSectionHtmlByKey("nonTraffic");
            if (htmlNon) {
                bodyHtml +=
                    '<hr style="margin:16px 0;border:none;border-top:1px solid #e5e7eb;" />' +
                    htmlNon;
            }
        }
    }

    bodyHtml += "</body></html>";

    // ==== 5. Build multipart/related EML v·ªõi allImages (chart + b·∫£ng PNG) ====
    const emlContent = buildEmlWithCharts(to, subjectProcessed, bodyHtml, allImages);

    const blob = new Blob([emlContent], { type: "message/rfc822" });

    // ==== 6. T√™n file .eml: "KPI Viewer and Report-yyyy-mm-dd" ====
    let fileDatePart = "";
    const d = latestDateObj || new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth() + 1).padStart(2, "0");
    const dd = String(d.getDate()).padStart(2, "0");
    fileDatePart = `${yyyy}-${mm}-${dd}`;

    const safeName = `KPI Viewer and Report-${fileDatePart}`;

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = safeName + ".eml";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(() => URL.revokeObjectURL(url), 5000);

    if (statusEl) {
        statusEl.textContent = "‚úÖ ƒê√£ t·∫°o file .eml";
        statusEl.classList.add("success");
    }
}


let progressFullData = [];
let progressSitePoMap = {}; // map Site Name (CQT-SSV) -> PO

function normalizeSiteKey(name) {
    return String(name || "")
        .trim()
        .toUpperCase()
        .replace(/\s+/g, " ");
}

// L·∫•y PO t·ª´ file Ti·∫øn ƒë·ªô ƒëo ki·ªÉm d·ª±a v√†o Site Name
function getPoFromProgress(siteName) {
    if (!siteName) return "";
    const key = normalizeSiteKey(siteName);
    return progressSitePoMap[key] || "";
}

function initProgressUpload() {
    const input = document.getElementById("progressFileInput");
    const statusEl = document.getElementById("progressStatus");
    const tableContainer = document.getElementById("progressTable");
    const poFilter = document.getElementById("progressPOFilter");

    if (!input || !statusEl || !tableContainer) return;

    input.addEventListener("change", function (e) {
        const file = e.target.files && e.target.files[0];
        if (!file) return;

        statusEl.textContent = "ƒêang ƒë·ªçc file: " + file.name + "...";

        const reader = new FileReader();
        reader.onload = function (evt) {
            try {
                const data = new Uint8Array(evt.target.result);
                const wb = XLSX.read(data, { type: "array" });

                // L·∫•y sheet CQT-SSV
                const sheetName = "CQT-SSV";
                const ws =
                    wb.Sheets[sheetName] ||
                    wb.Sheets[wb.SheetNames[0]];

                if (!ws) {
                    statusEl.textContent =
                        'Kh√¥ng t√¨m th·∫•y sheet "CQT-SSV" trong file Excel.';
                    tableContainer.innerHTML = "";
                    return;
                }

                const allRows = XLSX.utils.sheet_to_json(ws, {
                    header: 1,
                    defval: "",
                });

                if (allRows.length < 4) {
                    statusEl.textContent =
                        "Sheet CQT-SSV kh√¥ng ƒë·ªß d√≤ng d·ªØ li·ªáu.";
                    tableContainer.innerHTML = "";
                    return;
                }

                // Row 2: header th·∫≠t
                const headerRow = allRows[1];
                // D·ªØ li·ªáu t·ª´ row 4 tr·ªü ƒëi
                const dataRows = allRows.slice(3);

                const headers = headerRow.map((h) =>
                    String(h || "").trim()
                );
                const headersLower = headers.map((h) =>
                    h.toLowerCase()
                );

// ==== X√ÅC ƒê·ªäNH C√ÅC C·ªòT C·∫¶N D√ôNG ====
const idxPO = headersLower.indexOf("po");
const idxProvince = headersLower.indexOf("province");
const idxSiteName = headersLower.indexOf("site name"); // ƒë·ªÉ map v·ªõi NRBTS

const idxOnair = headersLower.findIndex((h) =>
    h.includes("onair")
);
const idxCqtDate = headersLower.findIndex((h) =>
    h.includes("ng√†y ƒëo cqt")
);
const idxSsvDate = headersLower.findIndex((h) =>
    h.includes("ng√†y ƒëo ssv/cluster")
);
const idxAtpDate = headersLower.findIndex((h) =>
    h.includes("ng√†y g·ª≠i report atp")
);

if (idxPO === -1 || idxProvince === -1) {
    statusEl.textContent =
        'Kh√¥ng t√¨m th·∫•y c·ªôt "PO" / "Province" trong sheet CQT-SSV.';
    tableContainer.innerHTML = "";
    return;
}

// ==== BUILD MAP Site Name -> PO CHO WORST CELL / NON-TRAFFIC ====
progressSitePoMap = {};
if (idxSiteName !== -1) {
    dataRows.forEach((row) => {
        const po = String(row[idxPO] || "").trim();
        const siteName = String(row[idxSiteName] || "").trim();
        if (!po || !siteName) return;

        const key = normalizeSiteKey(siteName);
        if (!progressSitePoMap[key]) {
            progressSitePoMap[key] = po;
        }
    });
}



                // ==== GOM NH√ìM THEO PO + PROVINCE ====
                const groups = {};

                dataRows.forEach((row) => {
                    const po = String(row[idxPO] || "").trim();
                    const province = String(row[idxProvince] || "").trim();
                    if (!po && !province) return;

                    const key = po + "||" + province;
                    if (!groups[key]) {
                        groups[key] = {
                            po,
                            province,
                            total: 0,
                            onair: 0,
                            cqtOk: 0,
                            ssvOk: 0,
                            atpReport: 0,
                        };
                    }

                    const g = groups[key];
                    g.total++;

                    // On-Air: c√≥ gi√° tr·ªã b·∫•t k·ª≥
                    if (idxOnair !== -1) {
                        const v = String(row[idxOnair] || "").trim();
                        if (v !== "") g.onair++;
                    }

                    // CQT: c√≥ "Ng√†y ƒëo CQT"
                    if (idxCqtDate !== -1) {
                        const v = String(row[idxCqtDate] || "").trim();
                        if (v !== "") g.cqtOk++;
                    }

                    // SSV: c√≥ "Ng√†y ƒëo SSV/Cluster"
                    if (idxSsvDate !== -1) {
                        const v = String(row[idxSsvDate] || "").trim();
                        if (v !== "") g.ssvOk++;
                    }

                    // ATP report: c√≥ "Ng√†y g·ª≠i report ATP vung phu song"
                    if (idxAtpDate !== -1) {
                        const v = String(row[idxAtpDate] || "").trim();
                        if (v !== "") g.atpReport++;
                    }
                });

                const groupList = Object.values(groups).sort((a, b) => {
                    if (a.po === b.po) {
                        return a.province.localeCompare(b.province);
                    }
                    return a.po.localeCompare(b.po);
                });

                // L∆∞u to√†n b·ªô cho combobox filter
                progressFullData = groupList;

                // ==== FILL COMBOBOX PO ====
                if (poFilter) {
                    poFilter.innerHTML =
                        '<option value="ALL">T·∫•t c·∫£ PO</option>';
                    const uniquePO = [...new Set(groupList.map((g) => g.po))];
                    uniquePO.forEach((po) => {
                        const opt = document.createElement("option");
                        opt.value = po;
                        opt.textContent = po;
                        poFilter.appendChild(opt);
                    });
                    poFilter.style.display = "inline-block";
                }

                // Render b·∫£ng l·∫ßn ƒë·∫ßu (t·∫•t c·∫£ PO)
                renderProgressTable(groupList);

                // Sau khi ƒë√£ c√≥ progressSitePoMap -> render l·∫°i Worst Cell / Non-Traffic
                if (typeof renderWorstCellTable === "function") {
                    renderWorstCellTable();
                }

                // C·∫≠p nh·∫≠t l·∫°i n·ªôi dung email m·ªü ƒë·∫ßu theo d·ªØ li·ªáu Ti·∫øn ƒë·ªô
                if (typeof fillDefaultEmailText === "function") {
                    fillDefaultEmailText();
                }


                statusEl.textContent =
                    "ƒê√£ ƒë·ªçc " +
                    dataRows.length +
                    " d√≤ng t·ª´ sheet CQT-SSV trong file " +
                    file.name +
                    ".";
            } catch (err) {
                console.error(err);
                statusEl.textContent = "L·ªói khi ƒë·ªçc file: " + err.message;
                tableContainer.innerHTML = "";
            }
        };

        reader.onerror = function () {
            statusEl.textContent = "Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c file.";
            tableContainer.innerHTML = "";
        };

        reader.readAsArrayBuffer(file);
    });
}

    // G√°n s·ª± ki·ªán upload cho ph·∫ßn Ti·∫øn ƒê·ªô ƒêo Ki·ªÉm
    initProgressUpload();

function renderProgressTable(data) {
    const tableContainer = document.getElementById("progressTable");
    if (!tableContainer) return;

    let totalStations = 0;
    let totalOnair = 0;
    let totalCqtOk = 0;
    let totalSsvOk = 0;
    let totalAtpOk = 0;

    // helper format %
    function formatPct(val) {
        return val === "0.00%" ? "-" : val;
    }

    let html = `
    <table class="progress-table">
        <thead>
            <tr>
                <th>STT</th>
                <th>PO</th>
                <th>T·ªânh</th>
                <th>S·ªë tr·∫°m</th>

                <th>On-Air</th>
                <th>Ti·∫øn ƒë·ªô On-Air (%)</th>
                <th>CQT</th>
                <th>Ti·∫øn ƒë·ªô CQT (%)</th>
                <th>SSV</th>
                <th>Ti·∫øn ƒë·ªô SSV (%)</th>
                <th>ATP report</th>
                <th>Ti·∫øn ƒë·ªô ATP report</th>
            </tr>
        </thead>
        <tbody>
    `;

    data.forEach((g, idx) => {
        totalStations += g.total;
        totalOnair += g.onair;
        totalCqtOk += g.cqtOk;
        totalSsvOk += g.ssvOk;
        totalAtpOk += g.atpReport;

        const onairPct =
            g.total > 0
                ? formatPct(((g.onair / g.total) * 100).toFixed(2) + "%")
                : "-";
        const cqtPct =
            g.total > 0
                ? formatPct(((g.cqtOk / g.total) * 100).toFixed(2) + "%")
                : "-";
        const ssvPct =
            g.total > 0
                ? formatPct(((g.ssvOk / g.total) * 100).toFixed(2) + "%")
                : "-";
        const atpPct =
            g.total > 0
                ? formatPct(((g.atpReport / g.total) * 100).toFixed(2) + "%")
                : "-";

        html += `
        <tr>
            <td>${idx + 1}</td>
            <td>${g.po}</td>
            <td>${g.province}</td>
            <td>${g.total}</td>

            <td>${g.onair}</td>
            <td>${onairPct}</td>
            <td>${g.cqtOk}</td>
            <td>${cqtPct}</td>
            <td>${g.ssvOk}</td>
            <td>${ssvPct}</td>
            <td>${g.atpReport}</td>
            <td>${atpPct}</td>
        </tr>`;
    });

    const totalOnairPct =
        totalStations > 0
            ? ((totalOnair / totalStations) * 100).toFixed(2) + "%"
            : "-";
    const totalCqtPct =
        totalStations > 0
            ? ((totalCqtOk / totalStations) * 100).toFixed(2) + "%"
            : "-";
    const totalSsvPct =
        totalStations > 0
            ? ((totalSsvOk / totalStations) * 100).toFixed(2) + "%"
            : "-";
    const totalAtpPct =
        totalStations > 0
            ? ((totalAtpOk / totalStations) * 100).toFixed(2) + "%"
            : "-";

    html += `
        <tr class="progress-summary-row">
            <td>T·ªïng c·ªông</td>
            <td></td>
            <td></td>
            <td>${totalStations}</td>

            <td>${totalOnair}</td>
            <td>${totalOnairPct === "0.00%" ? "-" : totalOnairPct}</td>
            <td>${totalCqtOk}</td>
            <td>${totalCqtPct === "0.00%" ? "-" : totalCqtPct}</td>
            <td>${totalSsvOk}</td>
            <td>${totalSsvPct === "0.00%" ? "-" : totalSsvPct}</td>
            <td>${totalAtpOk}</td>
            <td>${totalAtpPct === "0.00%" ? "-" : totalAtpPct}</td>
        </tr>
    </tbody></table>
    `;

    tableContainer.innerHTML = html;

    // n·∫øu ƒëang d√πng sticky 4 c·ªôt ƒë·∫ßu
    if (typeof applyProgressStickyColumns === "function") {
        applyProgressStickyColumns();
    }
}

    function applyProgressStickyColumns() {
    const table = document.querySelector("#progressTable table");
    if (!table || !table.tHead) return;

    const stickyCount = 4; // STT, PO, T·ªânh, S·ªë tr·∫°m

    const headerRows = Array.from(table.tHead.rows);
    if (!headerRows.length) return;

    const headerRow = headerRows[headerRows.length - 1];

    const tableRect = table.getBoundingClientRect();
    const colLeft = [];

    for (let i = 0; i < stickyCount; i++) {
        const cell = headerRow.cells[i];
        if (!cell) continue;
        const rect = cell.getBoundingClientRect();
        colLeft[i] = rect.left - tableRect.left;
    }

    // reset sticky c≈©
    const oldSticky = table.querySelectorAll(".sticky-col");
    oldSticky.forEach((c) => {
        c.classList.remove("sticky-col");
        c.style.left = "";
        c.style.position = "";
    });

    // g√°n sticky cho 4 c·ªôt ƒë·∫ßu
    const rows = Array.from(table.rows);
    rows.forEach((row) => {
        for (let i = 0; i < stickyCount; i++) {
            const cell = row.cells[i];
            if (!cell) continue;

            cell.classList.add("sticky-col");
            cell.style.position = "sticky";
            cell.style.left = (colLeft[i] || 0) + "px";
        }
    });
}

// C·ªë ƒë·ªãnh 4 c·ªôt ƒë·∫ßu cho b·∫£ng Worst Cell (PO, Province, NRBTS, NRCEL)
// C·ªë ƒë·ªãnh 4 c·ªôt ƒë·∫ßu cho b·∫£ng Worst Cell (PO, Province, NRBTS, NRCEL)
function applyWorstCellStickyColumns() {
    const wrappers = [
        document.getElementById("worstCellTable"),
        document.getElementById("nonTrafficTable"),
    ].filter(Boolean);

    const stickyCount = 4; // 4 c·ªôt ƒë·∫ßu

    wrappers.forEach((wrapper) => {
        const table = wrapper.querySelector("table");
        if (!table || !table.tHead) return;

        const headerRow = table.tHead.rows[table.tHead.rows.length - 1];
        if (!headerRow) return;

        const tableRect = table.getBoundingClientRect();
        const leftOffsets = [];

        // T√≠nh left cho 4 c·ªôt ƒë·∫ßu
        for (let i = 0; i < stickyCount; i++) {
            const cell = headerRow.cells[i];
            if (!cell) continue;
            const rect = cell.getBoundingClientRect();
            leftOffsets[i] = rect.left - tableRect.left;
        }

        // Reset sticky c≈©
        table.querySelectorAll(".sticky-col-wc").forEach((td) => {
            td.classList.remove("sticky-col-wc");
            td.style.left = "";
            td.style.background = "";
        });

        const rows = Array.from(table.rows);

        rows.forEach((row) => {
            const isHeader = row.parentNode.tagName === "THEAD";

            for (let i = 0; i < stickyCount; i++) {
                const cell = row.cells[i];
                if (!cell) continue;

                // Sticky
                cell.classList.add("sticky-col-wc");
                cell.style.position = "sticky";
                cell.style.left = (leftOffsets[i] || 0) + "px";
                cell.style.zIndex = isHeader ? 5 : 4;

                // In ƒë·∫≠m
                cell.style.fontWeight = "600";

                // ‚≠ê M√ÄU CHU·∫®N GI·ªêNG B·∫¢NG WORST CELL
                if (isHeader) {
                    cell.style.background = "#203864";   // xanh header
                    cell.style.color = "white";
                } else {
                    cell.style.background = "#d9e1f2";   // xanh nh·∫°t body
                    cell.style.color = "#111827";
                }
            }
        });
    });
}

// L·ªçc b·∫£ng Ti·∫øn ƒë·ªô ƒëo ki·ªÉm theo PO ƒë∆∞·ª£c ch·ªçn
const poFilterEl = document.getElementById("progressPOFilter");
if (poFilterEl) {
    poFilterEl.addEventListener("change", function () {
        const val = this.value;

        // N·∫øu ch·ªçn "T·∫•t c·∫£ PO" th√¨ d√πng to√†n b·ªô d·ªØ li·ªáu
        const filtered =
            val === "ALL"
                ? progressFullData
                : progressFullData.filter((g) => g.po === val);

        renderProgressTable(filtered);

        // Sau khi ƒë·ªïi PO, c·∫≠p nh·∫≠t l·∫°i n·ªôi dung email m·ªü ƒë·∫ßu
        if (typeof fillDefaultEmailText === "function") {
            fillDefaultEmailText();
        }
    });
}

/* ==========================================================
    1. SAVE & LOAD CONFIG (Bi·ªÉu ƒë·ªì)
   ========================================================== */

// --- SAVE ---
function saveChartConfig() {
    const config = {
        sheet: document.getElementById("sheetSelect").value,
        chartsPerRow: document.getElementById("chartsPerRowSelect").value,
        daysWindow: document.getElementById("daysWindowSelect").value,
        funnelSort: document.getElementById("funnelSortSelect").value
    };
    localStorage.setItem("chartConfig", JSON.stringify(config));
}

// --- LOAD ---
function loadChartConfig() {
    const saved = localStorage.getItem("chartConfig");
    if (!saved) return;

    const cfg = JSON.parse(saved);

    if (cfg.sheet) document.getElementById("sheetSelect").value = cfg.sheet;
    if (cfg.chartsPerRow) document.getElementById("chartsPerRowSelect").value = cfg.chartsPerRow;
    if (cfg.daysWindow) document.getElementById("daysWindowSelect").value = cfg.daysWindow;
    if (cfg.funnelSort) document.getElementById("funnelSortSelect").value = cfg.funnelSort;
}

// G·ªçi save khi user thay ƒë·ªïi config
["sheetSelect","chartsPerRowSelect","daysWindowSelect","funnelSortSelect"]
.forEach(id => {
    document.getElementById(id).addEventListener("change", saveChartConfig);
});


/* ==========================================================
    2. SAVE & LOAD EMAIL FIELDS
   ========================================================== */

// --- SAVE ---
function saveEmailConfig() {
    const cfg = {
        to: document.getElementById("emailTo").value,
        subject: document.getElementById("emailSubject").value,
        message: document.getElementById("emailMessage").value
    };
    localStorage.setItem("emailConfig", JSON.stringify(cfg));
}

// --- LOAD ---
function loadEmailConfig() {
    const saved = localStorage.getItem("emailConfig");
    if (!saved) return;

    const cfg = JSON.parse(saved);

    if (cfg.to) document.getElementById("emailTo").value = cfg.to;
    if (cfg.subject) document.getElementById("emailSubject").value = cfg.subject;
    if (cfg.message) document.getElementById("emailMessage").value = cfg.message;
}

// G·ªçi auto-save khi ng∆∞·ªùi d√πng g√µ
["emailTo","emailSubject","emailMessage"].forEach(id => {
    document.getElementById(id).addEventListener("input", saveEmailConfig);
});


/* ==========================================================
    3. T·ª∞ ƒê·ªòNG CH√àN L·∫†I BI·∫æN ƒê·ªòNG POx / S·ªê TR·∫†M / NG√ÄY
   ========================================================== */

/* ==========================================================
    3. T·ª∞ ƒê·ªòNG CH√àN L·∫†I BI·∫æN ƒê·ªòNG POx / S·ªê TR·∫†M / NG√ÄY
   ========================================================== */
function updateDynamicEmailFields(
    latestDate,
    selectedPO,
    onairCount,
    totalCount,
    baseText
) {
    const textarea = document.getElementById("emailMessage");
    if (!textarea) return;

    // L·∫•y template g·ªëc: ∆∞u ti√™n baseText, n·∫øu kh√¥ng th√¨ l·∫•y t·ª´ textarea
    let msg =
        typeof baseText === "string" && baseText.length
            ? baseText
            : textarea.value || "";

    // Thay c√°c placeholder b·∫±ng gi√° tr·ªã hi·ªán t·∫°i
    msg = msg
        .replace(/\(ng√†y g·∫ßn nh·∫•t\)/g, latestDate || "(ng√†y g·∫ßn nh·∫•t)")
        .replace(/\(POx\)/g, selectedPO || "(POx)")
        .replace(/\(S·ªë tr·∫°m onair\)/g, onairCount || "(S·ªë tr·∫°m onair)")
        .replace(/\(T·ªïng s·ªë tr·∫°m POx\)/g, totalCount || "(T·ªïng s·ªë tr·∫°m POx)");

    // Hi·ªÉn th·ªã l√™n textarea
    textarea.value = msg;
}


/* ==========================================================
    4. G·ªçi load config khi trang m·ªü l·∫°i
   ========================================================== */

window.addEventListener("DOMContentLoaded", () => {
    loadChartConfig();
    loadEmailConfig();
});
function updateKpiFolderPath() {
    const newPath = document.getElementById("kpiFolderInput").value.trim();

    if (!newPath) {
        alert("Vui l√≤ng nh·∫≠p ƒë∆∞·ªùng d·∫´n h·ª£p l·ªá (v√≠ d·ª•: /KPI Scheduler)");
        return;
    }

    // c·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n v√†o c·∫•u h√¨nh
    graphKpiConfig.kpiFolderPath = newPath;

    alert("ƒê√£ c·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n OneDrive:\n" + newPath);
}





    </script>
</body>
</html>
